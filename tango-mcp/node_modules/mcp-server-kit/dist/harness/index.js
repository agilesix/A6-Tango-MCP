import { readFile } from 'fs/promises';
import { extname } from 'path';
import { parse, stringify } from 'yaml';
import { z } from 'zod';

// src/harness/assertions/success.ts
function checkSuccess(response) {
  const isError = response.isError === true;
  if (isError) {
    return {
      type: "success",
      passed: false,
      message: "Tool call returned an error",
      expected: "success",
      actual: "error"
    };
  }
  return {
    type: "success",
    passed: true,
    message: "Tool call succeeded"
  };
}

// src/harness/assertions/helpers.ts
function getResponseText(response) {
  if ("content" in response && Array.isArray(response.content)) {
    return response.content.filter((item) => item.type === "text").map((item) => item.text).join("\n");
  }
  if ("messages" in response && Array.isArray(response.messages)) {
    return response.messages.map((msg) => {
      if (msg.content.type === "text") {
        return msg.content.text || "";
      }
      return "";
    }).join("\n");
  }
  if ("contents" in response && Array.isArray(response.contents)) {
    return response.contents.filter((item) => item.text).map((item) => item.text).join("\n");
  }
  return "";
}

// src/harness/assertions/error.ts
function checkError(response, messageContains) {
  if (!response.isError) {
    return {
      type: "error",
      passed: false,
      message: "Expected tool call to fail, but it succeeded",
      expected: "error",
      actual: "success"
    };
  }
  if (messageContains) {
    const responseText = getResponseText(response);
    if (!responseText.toLowerCase().includes(messageContains.toLowerCase())) {
      return {
        type: "error",
        passed: false,
        message: `Error message does not contain expected text: "${messageContains}"`,
        expected: `error containing "${messageContains}"`,
        actual: responseText.substring(0, 200)
      };
    }
  }
  return {
    type: "error",
    passed: true,
    message: messageContains ? `Tool call failed as expected with message containing "${messageContains}"` : "Tool call failed as expected"
  };
}

// src/harness/assertions/contains-text.ts
function checkContainsText(response, text, caseInsensitive = false) {
  const responseText = getResponseText(response);
  const searchText = caseInsensitive ? text.toLowerCase() : text;
  const targetText = caseInsensitive ? responseText.toLowerCase() : responseText;
  const contains = targetText.includes(searchText);
  if (!contains) {
    return {
      type: "contains_text",
      passed: false,
      message: `Response does not contain expected text: "${text}"`,
      expected: `text containing "${text}"`,
      actual: responseText.substring(0, 200)
      // First 200 chars
    };
  }
  return {
    type: "contains_text",
    passed: true,
    message: `Response contains expected text: "${text}"`
  };
}
function checkNotContainsText(response, text, caseInsensitive = false) {
  const responseText = getResponseText(response);
  const searchText = caseInsensitive ? text.toLowerCase() : text;
  const targetText = caseInsensitive ? responseText.toLowerCase() : responseText;
  const contains = targetText.includes(searchText);
  if (contains) {
    return {
      type: "not_contains_text",
      passed: false,
      message: `Response should not contain text: "${text}"`,
      expected: `text not containing "${text}"`,
      actual: responseText.substring(0, 200)
      // First 200 chars
    };
  }
  return {
    type: "not_contains_text",
    passed: true,
    message: `Response does not contain unwanted text: "${text}"`
  };
}

// src/harness/assertions/response-time.ts
function checkResponseTime(duration, maxMs) {
  const withinLimit = duration <= maxMs;
  if (!withinLimit) {
    return {
      type: "response_time_ms",
      passed: false,
      message: `Response time ${duration}ms exceeds maximum ${maxMs}ms`,
      expected: `\u2264 ${maxMs}ms`,
      actual: `${duration}ms`
    };
  }
  return {
    type: "response_time_ms",
    passed: true,
    message: `Response time ${duration}ms is within limit (${maxMs}ms)`
  };
}

// src/harness/assertions/json-path.ts
function evaluateJsonPath(obj, path) {
  const normalizedPath = path.replace(/^\$\.?/, "");
  if (!normalizedPath) {
    return obj;
  }
  const segments = normalizedPath.split(/\.|\[/).map((s) => s.replace(/\]/, ""));
  let current = obj;
  for (const segment of segments) {
    if (current === void 0 || current === null) {
      return void 0;
    }
    if (segment === "*") {
      if (!Array.isArray(current)) {
        return void 0;
      }
      return current;
    }
    if (/^\d+$/.test(segment)) {
      const index = Number.parseInt(segment, 10);
      current = current[index];
    } else {
      current = current[segment];
    }
  }
  return current;
}
function deepEqual(a, b) {
  if (a === b) return true;
  if (typeof a !== typeof b) return false;
  if (typeof a !== "object" || a === null || b === null) {
    return a === b;
  }
  if (Array.isArray(a) !== Array.isArray(b)) return false;
  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    return a.every((val, idx) => deepEqual(val, b[idx]));
  }
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  return keysA.every((key) => deepEqual(a[key], b[key]));
}
async function checkJsonPath(response, path, expected) {
  try {
    let responseData;
    if ("messages" in response) {
      responseData = response;
    } else if ("contents" in response && Array.isArray(response.contents)) {
      responseData = response;
    } else if ("content" in response && Array.isArray(response.content)) {
      const responseText = getResponseText(response);
      try {
        responseData = JSON.parse(responseText);
      } catch {
        return {
          type: "json_path",
          passed: false,
          message: "Response is not valid JSON",
          expected: "valid JSON",
          actual: "invalid JSON"
        };
      }
    } else {
      return {
        type: "json_path",
        passed: false,
        message: "Unknown response type",
        expected: "valid MCP response",
        actual: "unknown type"
      };
    }
    const actual = evaluateJsonPath(responseData, path);
    if (expected === void 0) {
      const exists = actual !== void 0;
      return {
        type: "json_path",
        passed: exists,
        message: exists ? `Path "${path}" exists with value: ${JSON.stringify(actual)}` : `Path "${path}" does not exist in response`,
        actual: exists ? actual : void 0
      };
    }
    const matches = deepEqual(actual, expected);
    if (!matches) {
      const actualType = typeof actual;
      const expectedType = typeof expected;
      const typeHint = actualType !== expectedType ? ` (type mismatch: ${actualType} vs ${expectedType})` : "";
      return {
        type: "json_path",
        passed: false,
        message: `Value at path "${path}" does not match expected${typeHint}`,
        expected,
        actual
      };
    }
    return {
      type: "json_path",
      passed: true,
      message: `Value at path "${path}" matches expected value`,
      expected,
      actual
    };
  } catch (error) {
    return {
      type: "json_path",
      passed: false,
      message: error instanceof Error ? error.message : String(error)
    };
  }
}

// src/harness/assertions/regex.ts
function checkRegexMatch(response, pattern, flags) {
  const responseText = getResponseText(response);
  try {
    const regex = new RegExp(pattern, flags);
    const matches = regex.test(responseText);
    if (!matches) {
      return {
        type: "regex_match",
        passed: false,
        message: `Response does not match pattern: ${pattern}`,
        expected: `text matching /${pattern}/${flags || ""}`,
        actual: responseText.substring(0, 200)
        // First 200 chars
      };
    }
    return {
      type: "regex_match",
      passed: true,
      message: `Response matches pattern: ${pattern}`
    };
  } catch (error) {
    return {
      type: "regex_match",
      passed: false,
      message: `Invalid regex pattern: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}

// src/harness/assertions/index.ts
async function runAssertions(assertions, response, duration) {
  const results = [];
  for (const assertion of assertions) {
    let result;
    try {
      switch (assertion.type) {
        case "success":
          result = checkSuccess(response);
          break;
        case "error":
          result = checkError(response, assertion.messageContains);
          break;
        case "contains_text":
          result = checkContainsText(response, assertion.text, assertion.caseInsensitive);
          break;
        case "not_contains_text":
          result = checkNotContainsText(response, assertion.text, assertion.caseInsensitive);
          break;
        case "response_time_ms":
          result = checkResponseTime(duration, assertion.max);
          break;
        case "json_path":
          result = await checkJsonPath(response, assertion.path, assertion.expected);
          break;
        case "regex_match":
          result = checkRegexMatch(response, assertion.pattern, assertion.flags);
          break;
        case "snapshot":
          result = {
            type: "snapshot",
            passed: false,
            message: "Snapshot assertions not yet implemented in this context"
          };
          break;
        case "json_schema":
          result = {
            type: "json_schema",
            passed: false,
            message: "JSON Schema assertions not yet implemented in this context"
          };
          break;
        default:
          result = {
            type: "unknown",
            passed: false,
            message: `Unknown assertion type: ${assertion.type}`
          };
      }
    } catch (error) {
      result = {
        type: assertion.type,
        passed: false,
        message: error instanceof Error ? error.message : String(error)
      };
    }
    results.push(result);
  }
  return results;
}

// src/harness/runner.ts
var TestRunner = class {
  constructor(client) {
    this.client = client;
  }
  /**
   * Run a single test specification
   *
   * @param spec - Test specification to run
   * @returns Test result
   */
  async runTest(spec) {
    if (spec.skip) {
      return {
        name: spec.name,
        description: spec.description,
        passed: false,
        duration: 0,
        assertions: [],
        skipped: true
      };
    }
    const startTime = Date.now();
    try {
      let response;
      switch (spec.type) {
        case "tool":
          response = await this.client.callTool(spec.tool, spec.arguments);
          break;
        case "prompt":
          response = await this.client.getPrompt(spec.prompt, spec.arguments);
          break;
        case "resource":
          response = await this.client.readResource(spec.uri);
          break;
        default:
          throw new Error(`Unknown test type: ${spec.type}`);
      }
      const duration = Date.now() - startTime;
      const assertionResults = await runAssertions(spec.assertions, response, duration);
      const passed = assertionResults.every((a) => a.passed);
      return {
        name: spec.name,
        description: spec.description,
        passed,
        duration,
        assertions: assertionResults
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      return {
        name: spec.name,
        description: spec.description,
        passed: false,
        duration,
        assertions: [],
        error: {
          message: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : void 0
        }
      };
    }
  }
  /**
   * Run multiple test specifications
   *
   * @param specs - Array of test specifications
   * @param serverUrl - Server URL being tested (for reporting)
   * @returns Complete test run results
   */
  async runTests(specs, serverUrl) {
    const startTime = Date.now();
    const results = [];
    const onlyTests = specs.filter((s) => s.only);
    const testsToRun = onlyTests.length > 0 ? onlyTests : specs;
    for (const spec of testsToRun) {
      const result = await this.runTest(spec);
      results.push(result);
    }
    const totalDuration = Date.now() - startTime;
    const summary = {
      total: results.length,
      passed: results.filter((r) => r.passed).length,
      failed: results.filter((r) => !r.passed && !r.skipped).length,
      skipped: results.filter((r) => r.skipped).length,
      duration: totalDuration,
      successRate: results.length > 0 ? results.filter((r) => r.passed).length / results.length : 0
    };
    const failures = results.filter((r) => !r.passed && !r.skipped).flatMap((r) => {
      if (r.error) {
        return [
          {
            test: r.name,
            assertion: "execution",
            expected: "successful execution",
            actual: "error",
            message: r.error.message
          }
        ];
      }
      return r.assertions.filter((a) => !a.passed).map((a) => ({
        test: r.name,
        assertion: a.type,
        expected: a.expected,
        actual: a.actual,
        message: a.message || "Assertion failed"
      }));
    });
    return {
      summary,
      tests: results,
      failures,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      serverUrl
    };
  }
  /**
   * Connect to the MCP server
   *
   * Must be called before running tests.
   */
  async connect() {
    await this.client.connect();
  }
  /**
   * Disconnect from the MCP server
   *
   * Should be called after tests complete.
   */
  async disconnect() {
    await this.client.disconnect();
  }
};
var SuccessAssertionSchema = z.object({
  type: z.literal("success")
});
var ErrorAssertionSchema = z.object({
  type: z.literal("error"),
  messageContains: z.string().optional()
});
var ContainsTextAssertionSchema = z.object({
  type: z.literal("contains_text"),
  text: z.string(),
  caseInsensitive: z.boolean().optional()
});
var NotContainsTextAssertionSchema = z.object({
  type: z.literal("not_contains_text"),
  text: z.string(),
  caseInsensitive: z.boolean().optional()
});
var ResponseTimeAssertionSchema = z.object({
  type: z.literal("response_time_ms"),
  max: z.number().positive()
});
var JsonPathAssertionSchema = z.object({
  type: z.literal("json_path"),
  path: z.string(),
  expected: z.any().optional()
});
var RegexMatchAssertionSchema = z.object({
  type: z.literal("regex_match"),
  pattern: z.string(),
  flags: z.string().optional()
});
var SnapshotAssertionSchema = z.object({
  type: z.literal("snapshot"),
  file: z.string(),
  ignoreFields: z.array(z.string()).optional()
});
var JsonSchemaAssertionSchema = z.object({
  type: z.literal("json_schema"),
  schema: z.string()
});
var AssertionSchema = z.discriminatedUnion("type", [
  SuccessAssertionSchema,
  ErrorAssertionSchema,
  ContainsTextAssertionSchema,
  NotContainsTextAssertionSchema,
  ResponseTimeAssertionSchema,
  JsonPathAssertionSchema,
  RegexMatchAssertionSchema,
  SnapshotAssertionSchema,
  JsonSchemaAssertionSchema
]);
var BaseTestSpecSchema = z.object({
  name: z.string().min(1, "Test name is required"),
  description: z.string().optional(),
  assertions: z.array(AssertionSchema).min(1, "At least one assertion required"),
  timeout: z.number().positive().optional(),
  skip: z.boolean().optional(),
  only: z.boolean().optional()
});
var ToolTestSpecSchema = BaseTestSpecSchema.extend({
  type: z.literal("tool"),
  tool: z.string().min(1, "Tool name is required"),
  arguments: z.record(z.any())
});
var PromptTestSpecSchema = BaseTestSpecSchema.extend({
  type: z.literal("prompt"),
  prompt: z.string().min(1, "Prompt name is required"),
  arguments: z.record(z.any()).optional()
});
var ResourceTestSpecSchema = BaseTestSpecSchema.extend({
  type: z.literal("resource"),
  uri: z.string().min(1, "Resource URI is required")
});
var TestSpecUnionSchema = z.discriminatedUnion("type", [
  ToolTestSpecSchema,
  PromptTestSpecSchema,
  ResourceTestSpecSchema
]);
var TestSpecSchema = z.preprocess(
  (data) => {
    if (typeof data === "object" && data !== null && "type" in data) {
      return data;
    }
    if (typeof data === "object" && data !== null && "tool" in data) {
      return { ...data, type: "tool" };
    }
    return data;
  },
  TestSpecUnionSchema
);
var TestSuiteSpecSchema = z.object({
  name: z.string().min(1, "Suite name is required"),
  description: z.string().optional(),
  tests: z.array(z.union([z.string(), TestSpecSchema])),
  setup: z.object({
    serverUrl: z.string().url().optional()
  }).optional()
});
function validateTestSpec(data) {
  return TestSpecSchema.parse(data);
}
function validateTestSuiteSpec(data) {
  return TestSuiteSpecSchema.parse(data);
}

// src/harness/spec-loader.ts
async function loadTestSpec(filePath) {
  const content = await readFile(filePath, "utf-8");
  const ext = extname(filePath).toLowerCase();
  let data;
  if (ext === ".yaml" || ext === ".yml") {
    data = parse(content);
  } else if (ext === ".json") {
    data = JSON.parse(content);
  } else {
    throw new Error(`Unsupported file format: ${ext}. Use .yaml, .yml, or .json`);
  }
  try {
    return validateTestSpec(data);
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Invalid test spec in ${filePath}: ${error.message}`);
    }
    throw error;
  }
}
async function loadTestSuiteSpec(filePath) {
  const content = await readFile(filePath, "utf-8");
  const ext = extname(filePath).toLowerCase();
  let data;
  if (ext === ".yaml" || ext === ".yml") {
    data = parse(content);
  } else if (ext === ".json") {
    data = JSON.parse(content);
  } else {
    throw new Error(`Unsupported file format: ${ext}. Use .yaml, .yml, or .json`);
  }
  try {
    return validateTestSuiteSpec(data);
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Invalid test suite spec in ${filePath}: ${error.message}`);
    }
    throw error;
  }
}
function parseTestSpec(content, format) {
  let data;
  if (format === "yaml") {
    data = parse(content);
  } else {
    data = JSON.parse(content);
  }
  return validateTestSpec(data);
}
function serializeTestSpecToYAML(spec) {
  return stringify(spec);
}
function serializeTestSpecToJSON(spec, pretty = true) {
  return pretty ? JSON.stringify(spec, null, 2) : JSON.stringify(spec);
}

// src/harness/reporters/json.ts
function formatAsJSON(results, pretty = true) {
  return pretty ? JSON.stringify(results, null, 2) : JSON.stringify(results);
}
function printJSON(results, pretty = true) {
  console.log(formatAsJSON(results, pretty));
}
function formatSimpleSummary(results) {
  const summary = {
    passed: results.summary.passed === results.summary.total,
    total: results.summary.total,
    passed_count: results.summary.passed,
    failed_count: results.summary.failed,
    duration_ms: results.summary.duration,
    success_rate: results.summary.successRate
  };
  return JSON.stringify(summary, null, 2);
}

// src/harness/reporters/console.ts
var colors = {
  reset: "\x1B[0m",
  green: "\x1B[32m",
  red: "\x1B[31m",
  yellow: "\x1B[33m",
  gray: "\x1B[90m",
  bold: "\x1B[1m"
};
function printTestResult(test, index) {
  const status = test.skipped ? `${colors.yellow}SKIP${colors.reset}` : test.passed ? `${colors.green}PASS${colors.reset}` : `${colors.red}FAIL${colors.reset}`;
  const duration = `${colors.gray}${test.duration}ms${colors.reset}`;
  console.log(`  ${status} ${test.name} ${duration}`);
  if (!test.passed && !test.skipped) {
    if (test.error) {
      console.log(`    ${colors.red}\u2717${colors.reset} ${test.error.message}`);
    } else {
      for (const assertion of test.assertions) {
        if (!assertion.passed) {
          console.log(`    ${colors.red}\u2717${colors.reset} ${assertion.type}: ${assertion.message}`);
          if (assertion.expected !== void 0) {
            console.log(
              `      Expected: ${colors.gray}${JSON.stringify(assertion.expected)}${colors.reset}`
            );
            console.log(
              `      Actual:   ${colors.gray}${JSON.stringify(assertion.actual)}${colors.reset}`
            );
          }
        }
      }
    }
  }
}
function printSummary(results) {
  console.log("");
  console.log(`${colors.bold}Test Summary${colors.reset}`);
  console.log(`${colors.gray}${"\u2500".repeat(50)}${colors.reset}`);
  const passed = results.summary.passed;
  const failed = results.summary.failed;
  const skipped = results.summary.skipped;
  const total = results.summary.total;
  console.log(`Total:   ${total}`);
  console.log(`${colors.green}Passed:  ${passed}${colors.reset}`);
  if (failed > 0) {
    console.log(`${colors.red}Failed:  ${failed}${colors.reset}`);
  }
  if (skipped > 0) {
    console.log(`${colors.yellow}Skipped: ${skipped}${colors.reset}`);
  }
  console.log(`Duration: ${results.summary.duration}ms`);
  console.log(`Success Rate: ${(results.summary.successRate * 100).toFixed(1)}%`);
  console.log("");
}
function printConsole(results) {
  console.log("");
  console.log(`${colors.bold}Running Integration Tests${colors.reset}`);
  if (results.serverUrl) {
    console.log(`${colors.gray}Server: ${results.serverUrl}${colors.reset}`);
  }
  console.log(`${colors.gray}Timestamp: ${results.timestamp}${colors.reset}`);
  console.log("");
  results.tests.forEach((test, index) => {
    printTestResult(test);
  });
  printSummary(results);
  if (results.failures.length > 0) {
    console.log(`${colors.bold}${colors.red}Failures:${colors.reset}`);
    console.log(`${colors.gray}${"\u2500".repeat(50)}${colors.reset}`);
    for (const failure of results.failures) {
      console.log(`${colors.red}\u2717${colors.reset} ${failure.test}`);
      console.log(`  Assertion: ${failure.assertion}`);
      console.log(`  Message: ${failure.message}`);
      if (failure.expected !== void 0) {
        console.log(`  Expected: ${JSON.stringify(failure.expected)}`);
        console.log(`  Actual: ${JSON.stringify(failure.actual)}`);
      }
      console.log("");
    }
  }
}
function printSimple(results) {
  const allPassed = results.summary.failed === 0;
  if (allPassed) {
    console.log(
      `${colors.green}${colors.bold}\u2713 All tests passed${colors.reset} (${results.summary.passed}/${results.summary.total})`
    );
  } else {
    console.log(
      `${colors.red}${colors.bold}\u2717 Tests failed${colors.reset} (${results.summary.failed} failed, ${results.summary.passed} passed)`
    );
  }
}

export { AssertionSchema, TestRunner, TestSpecSchema, TestSuiteSpecSchema, formatAsJSON, formatSimpleSummary, loadTestSpec, loadTestSuiteSpec, parseTestSpec, printConsole, printJSON, printSimple, runAssertions, serializeTestSpecToJSON, serializeTestSpecToYAML };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map