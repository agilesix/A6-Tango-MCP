import { z } from 'zod';

/**
 * Generic MCP Test Client Interface
 *
 * This interface abstracts MCP client operations for testing.
 * Projects implement this interface with their own MCP client.
 *
 * Design: Fully portable, no project-specific dependencies
 */
/**
 * Standard MCP tool response format
 */
interface MCPToolResponse {
    /** Response content array */
    content: Array<{
        type: string;
        text: string;
    }>;
    /** Whether the response indicates an error */
    isError?: boolean;
}
/**
 * MCP tool metadata
 */
interface MCPTool {
    /** Tool name */
    name: string;
    /** Tool description */
    description: string;
    /** Input schema (JSON Schema) */
    inputSchema: Record<string, any>;
}
/**
 * MCP server information
 */
interface MCPServerInfo {
    /** Server name */
    name: string;
    /** Server version */
    version: string;
    /** Protocol version */
    protocolVersion: string;
    /** Server capabilities */
    capabilities?: Record<string, any>;
}
/**
 * MCP Prompt metadata
 */
interface MCPPrompt {
    /** Prompt name */
    name: string;
    /** Prompt description */
    description: string;
    /** Optional arguments schema (JSON Schema) */
    argsSchema?: Record<string, any>;
}
/**
 * MCP Prompt response
 */
interface MCPPromptResponse {
    /** Array of messages in the prompt */
    messages: Array<{
        /** Message role */
        role: "user" | "assistant";
        /** Message content */
        content: {
            /** Content type */
            type: "text" | "image" | "resource";
            /** Text content */
            text?: string;
            /** Base64-encoded data */
            data?: string;
            /** MIME type */
            mimeType?: string;
        };
    }>;
}
/**
 * MCP Resource metadata
 */
interface MCPResource {
    /** Resource URI */
    uri: string;
    /** Resource name */
    name: string;
    /** Resource description */
    description?: string;
    /** MIME type */
    mimeType?: string;
}
/**
 * MCP Resource content (single content item)
 */
interface MCPResourceContentItem {
    /** Resource URI */
    uri: string;
    /** Text content */
    text?: string;
    /** Base64-encoded blob */
    blob?: string;
    /** MIME type */
    mimeType?: string;
}
/**
 * MCP Resource content response (matches MCP protocol)
 */
interface MCPResourceContent {
    /** Array of content items */
    contents: MCPResourceContentItem[];
}
/**
 * Generic MCP Test Client Interface
 *
 * Projects must implement this interface to integrate with the test harness.
 * See adapters/README.md for implementation guide.
 */
interface IMCPTestClient {
    /**
     * Connect to the MCP server and initialize session
     */
    connect(): Promise<void>;
    /**
     * Disconnect from the MCP server
     */
    disconnect(): Promise<void>;
    /**
     * Call an MCP tool with arguments
     *
     * @param name - Tool name
     * @param args - Tool arguments
     * @returns Tool response
     */
    callTool(name: string, args: Record<string, any>): Promise<MCPToolResponse>;
    /**
     * List all available tools from the server
     *
     * @returns Array of tool metadata
     */
    listTools(): Promise<MCPTool[]>;
    /**
     * Get server information
     *
     * @returns Server metadata
     */
    getServerInfo(): Promise<MCPServerInfo>;
    /**
     * List all available prompts from the server
     *
     * @returns Array of prompt metadata
     */
    listPrompts(): Promise<MCPPrompt[]>;
    /**
     * Get a prompt with optional arguments
     *
     * @param name - Prompt name
     * @param args - Optional prompt arguments
     * @returns Prompt response with messages
     */
    getPrompt(name: string, args?: Record<string, unknown>): Promise<MCPPromptResponse>;
    /**
     * List all available resources from the server
     *
     * @returns Array of resource metadata
     */
    listResources(): Promise<MCPResource[]>;
    /**
     * Read a resource by URI
     *
     * @param uri - Resource URI
     * @returns Resource content
     */
    readResource(uri: string): Promise<MCPResourceContent>;
}

/**
 * Test Specification Types
 *
 * Defines the declarative YAML/JSON test format for MCP integration tests.
 *
 * Design: Fully portable, no project-specific dependencies
 */
/**
 * Assertion type definitions
 */
type Assertion = SuccessAssertion | ErrorAssertion | ContainsTextAssertion | NotContainsTextAssertion | ResponseTimeAssertion | JsonPathAssertion | RegexMatchAssertion | SnapshotAssertion | JsonSchemaAssertion;
interface SuccessAssertion {
    type: "success";
}
interface ErrorAssertion {
    type: "error";
    /** Optional text that error message should contain */
    messageContains?: string;
}
interface ContainsTextAssertion {
    type: "contains_text";
    text: string;
    /** Case insensitive matching (default: false) */
    caseInsensitive?: boolean;
}
interface NotContainsTextAssertion {
    type: "not_contains_text";
    text: string;
    /** Case insensitive matching (default: false) */
    caseInsensitive?: boolean;
}
interface ResponseTimeAssertion {
    type: "response_time_ms";
    /** Maximum response time in milliseconds */
    max: number;
}
interface JsonPathAssertion {
    type: "json_path";
    /** JSON path expression (e.g., "$.apis[0].name") */
    path: string;
    /** Expected value at path (optional - if omitted, just checks path exists) */
    expected?: any;
}
interface RegexMatchAssertion {
    type: "regex_match";
    /** Regex pattern to match against response text */
    pattern: string;
    /** Regex flags (e.g., "i" for case-insensitive) */
    flags?: string;
}
interface SnapshotAssertion {
    type: "snapshot";
    /** Snapshot file name (relative to snapshotDir) */
    file: string;
    /** Fields to ignore in comparison (e.g., ["timestamp", "requestId"]) */
    ignoreFields?: string[];
}
interface JsonSchemaAssertion {
    type: "json_schema";
    /** JSON Schema file path (relative to contractDir) */
    schema: string;
}
/**
 * Base test specification
 *
 * Shared fields across all test types.
 */
interface BaseTestSpec {
    /** Test name (human-readable) */
    name: string;
    /** Test description (optional, for documentation) */
    description?: string;
    /** Assertions to verify the response */
    assertions: Assertion[];
    /** Test-specific timeout override (milliseconds) */
    timeout?: number;
    /** Skip this test */
    skip?: boolean;
    /** Only run this test (exclusive) */
    only?: boolean;
}
/**
 * Tool test specification (existing functionality)
 */
interface ToolTestSpec extends BaseTestSpec {
    /** Test type discriminator */
    type: "tool";
    /** MCP tool name to test */
    tool: string;
    /** Arguments to pass to the tool */
    arguments: Record<string, any>;
}
/**
 * Prompt test specification (new)
 */
interface PromptTestSpec extends BaseTestSpec {
    /** Test type discriminator */
    type: "prompt";
    /** MCP prompt name to test */
    prompt: string;
    /** Optional arguments to pass to the prompt */
    arguments?: Record<string, any>;
}
/**
 * Resource test specification (new)
 */
interface ResourceTestSpec extends BaseTestSpec {
    /** Test type discriminator */
    type: "resource";
    /** Resource URI to test */
    uri: string;
}
/**
 * Test specification format
 *
 * This is the structure agents will write in YAML/JSON format.
 * Supports tools, prompts, and resources as a discriminated union.
 */
type TestSpec = ToolTestSpec | PromptTestSpec | ResourceTestSpec;
/**
 * Test suite specification
 *
 * Groups multiple test specs together.
 */
interface TestSuiteSpec {
    /** Suite name */
    name: string;
    /** Suite description */
    description?: string;
    /** List of test spec file paths or inline test specs */
    tests: (string | TestSpec)[];
    /** Setup steps before suite runs */
    setup?: {
        /** Server URL override */
        serverUrl?: string;
    };
}

/**
 * Test Results Types
 *
 * Defines the output format for test execution results.
 *
 * Design: Fully portable, structured for agent consumption
 */
/**
 * Result of a single assertion
 */
interface AssertionResult {
    /** Assertion type */
    type: string;
    /** Whether assertion passed */
    passed: boolean;
    /** Error message if failed */
    message?: string;
    /** Expected value (for display) */
    expected?: any;
    /** Actual value (for display) */
    actual?: any;
}
/**
 * Result of a single test
 */
interface TestResult {
    /** Test name */
    name: string;
    /** Test description */
    description?: string;
    /** Whether test passed overall */
    passed: boolean;
    /** Test execution duration in milliseconds */
    duration: number;
    /** Individual assertion results */
    assertions: AssertionResult[];
    /** Error details if test failed to execute */
    error?: {
        message: string;
        stack?: string;
    };
    /** Whether test was skipped */
    skipped?: boolean;
}
/**
 * Summary statistics for test run
 */
interface TestSummary {
    /** Total tests executed */
    total: number;
    /** Tests that passed */
    passed: number;
    /** Tests that failed */
    failed: number;
    /** Tests that were skipped */
    skipped: number;
    /** Total execution duration in milliseconds */
    duration: number;
    /** Success rate (0-1) */
    successRate: number;
}
/**
 * Complete test run results
 *
 * This is the primary output format for agents to consume.
 */
interface TestRunResults {
    /** Summary statistics */
    summary: TestSummary;
    /** Individual test results */
    tests: TestResult[];
    /** List of failed tests with details */
    failures: Array<{
        /** Test name */
        test: string;
        /** Failed assertion type */
        assertion: string;
        /** Expected value */
        expected: any;
        /** Actual value */
        actual: any;
        /** Error message */
        message: string;
        /** Test spec file (if applicable) */
        file?: string;
    }>;
    /** Timestamp when tests were run */
    timestamp: string;
    /** Server URL tested against */
    serverUrl?: string;
}

/**
 * Test Harness Configuration
 *
 * This configuration is injected by the project to customize the test harness.
 *
 * Design: Fully portable, projects provide their own config
 */

/**
 * Test harness configuration
 *
 * Projects create this configuration object to integrate with the harness.
 */
interface TestHarnessConfig {
    /** MCP server URL (used by client factory) */
    serverUrl: string;
    /** Default test timeout in milliseconds */
    timeout?: number;
    /** Number of retries for failed tests */
    retries?: number;
    /** Directory for snapshot storage */
    snapshotDir?: string;
    /** Directory for contract (JSON Schema) storage */
    contractDir?: string;
    /** Factory function that creates an IMCPTestClient instance */
    clientFactory: (serverUrl: string) => IMCPTestClient;
}

/**
 * Core Test Runner
 *
 * Executes test specifications against an MCP server.
 *
 * Design: Fully portable, uses IMCPTestClient interface
 */

/**
 * Test Runner
 *
 * Executes tests using the provided MCP client.
 */
declare class TestRunner {
    private client;
    constructor(client: IMCPTestClient);
    /**
     * Run a single test specification
     *
     * @param spec - Test specification to run
     * @returns Test result
     */
    runTest(spec: TestSpec): Promise<TestResult>;
    /**
     * Run multiple test specifications
     *
     * @param specs - Array of test specifications
     * @param serverUrl - Server URL being tested (for reporting)
     * @returns Complete test run results
     */
    runTests(specs: TestSpec[], serverUrl?: string): Promise<TestRunResults>;
    /**
     * Connect to the MCP server
     *
     * Must be called before running tests.
     */
    connect(): Promise<void>;
    /**
     * Disconnect from the MCP server
     *
     * Should be called after tests complete.
     */
    disconnect(): Promise<void>;
}

/**
 * Test Specification Loader
 *
 * Loads and validates test specifications from YAML or JSON files.
 *
 * Design: Fully portable, no project-specific dependencies
 */

/**
 * Load a test specification from a file
 *
 * Supports both YAML (.yaml, .yml) and JSON (.json) formats.
 *
 * @param filePath - Path to test spec file
 * @returns Validated TestSpec
 * @throws Error if file cannot be read or validation fails
 */
declare function loadTestSpec(filePath: string): Promise<TestSpec>;
/**
 * Load a test suite specification from a file
 *
 * @param filePath - Path to test suite spec file
 * @returns Validated TestSuiteSpec
 * @throws Error if file cannot be read or validation fails
 */
declare function loadTestSuiteSpec(filePath: string): Promise<TestSuiteSpec>;
/**
 * Parse a test spec from a string
 *
 * Useful for programmatic test generation.
 *
 * @param content - YAML or JSON string
 * @param format - Format of the content ('yaml' or 'json')
 * @returns Validated TestSpec
 */
declare function parseTestSpec(content: string, format: "yaml" | "json"): TestSpec;
/**
 * Serialize a test spec to YAML string
 *
 * @param spec - TestSpec object
 * @returns YAML string
 */
declare function serializeTestSpecToYAML(spec: TestSpec): string;
/**
 * Serialize a test spec to JSON string
 *
 * @param spec - TestSpec object
 * @param pretty - Pretty print (default: true)
 * @returns JSON string
 */
declare function serializeTestSpecToJSON(spec: TestSpec, pretty?: boolean): string;

/**
 * Zod Validation Schemas
 *
 * Validates test specifications loaded from YAML/JSON files.
 *
 * Design: Fully portable, uses Zod for runtime validation
 */

/**
 * Union of all assertion types
 */
declare const AssertionSchema: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
    type: z.ZodLiteral<"success">;
}, "strip", z.ZodTypeAny, {
    type: "success";
}, {
    type: "success";
}>, z.ZodObject<{
    type: z.ZodLiteral<"error">;
    messageContains: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    type: "error";
    messageContains?: string | undefined;
}, {
    type: "error";
    messageContains?: string | undefined;
}>, z.ZodObject<{
    type: z.ZodLiteral<"contains_text">;
    text: z.ZodString;
    caseInsensitive: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    text: string;
    type: "contains_text";
    caseInsensitive?: boolean | undefined;
}, {
    text: string;
    type: "contains_text";
    caseInsensitive?: boolean | undefined;
}>, z.ZodObject<{
    type: z.ZodLiteral<"not_contains_text">;
    text: z.ZodString;
    caseInsensitive: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    text: string;
    type: "not_contains_text";
    caseInsensitive?: boolean | undefined;
}, {
    text: string;
    type: "not_contains_text";
    caseInsensitive?: boolean | undefined;
}>, z.ZodObject<{
    type: z.ZodLiteral<"response_time_ms">;
    max: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    type: "response_time_ms";
    max: number;
}, {
    type: "response_time_ms";
    max: number;
}>, z.ZodObject<{
    type: z.ZodLiteral<"json_path">;
    path: z.ZodString;
    expected: z.ZodOptional<z.ZodAny>;
}, "strip", z.ZodTypeAny, {
    type: "json_path";
    path: string;
    expected?: any;
}, {
    type: "json_path";
    path: string;
    expected?: any;
}>, z.ZodObject<{
    type: z.ZodLiteral<"regex_match">;
    pattern: z.ZodString;
    flags: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    type: "regex_match";
    pattern: string;
    flags?: string | undefined;
}, {
    type: "regex_match";
    pattern: string;
    flags?: string | undefined;
}>, z.ZodObject<{
    type: z.ZodLiteral<"snapshot">;
    file: z.ZodString;
    ignoreFields: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    type: "snapshot";
    file: string;
    ignoreFields?: string[] | undefined;
}, {
    type: "snapshot";
    file: string;
    ignoreFields?: string[] | undefined;
}>, z.ZodObject<{
    type: z.ZodLiteral<"json_schema">;
    schema: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "json_schema";
    schema: string;
}, {
    type: "json_schema";
    schema: string;
}>]>;
/**
 * Test specification schema with backward compatibility
 *
 * Handles old test specs without a 'type' field by treating them as tool tests.
 */
declare const TestSpecSchema: z.ZodEffects<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
    name: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    assertions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
        type: z.ZodLiteral<"success">;
    }, "strip", z.ZodTypeAny, {
        type: "success";
    }, {
        type: "success";
    }>, z.ZodObject<{
        type: z.ZodLiteral<"error">;
        messageContains: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        type: "error";
        messageContains?: string | undefined;
    }, {
        type: "error";
        messageContains?: string | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"contains_text">;
        text: z.ZodString;
        caseInsensitive: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    }, {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"not_contains_text">;
        text: z.ZodString;
        caseInsensitive: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    }, {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"response_time_ms">;
        max: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        type: "response_time_ms";
        max: number;
    }, {
        type: "response_time_ms";
        max: number;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"json_path">;
        path: z.ZodString;
        expected: z.ZodOptional<z.ZodAny>;
    }, "strip", z.ZodTypeAny, {
        type: "json_path";
        path: string;
        expected?: any;
    }, {
        type: "json_path";
        path: string;
        expected?: any;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"regex_match">;
        pattern: z.ZodString;
        flags: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    }, {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"snapshot">;
        file: z.ZodString;
        ignoreFields: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    }, {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"json_schema">;
        schema: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: "json_schema";
        schema: string;
    }, {
        type: "json_schema";
        schema: string;
    }>]>, "many">;
    timeout: z.ZodOptional<z.ZodNumber>;
    skip: z.ZodOptional<z.ZodBoolean>;
    only: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"tool">;
    tool: z.ZodString;
    arguments: z.ZodRecord<z.ZodString, z.ZodAny>;
}, "strip", z.ZodTypeAny, {
    tool: string;
    type: "tool";
    name: string;
    assertions: ({
        type: "success";
    } | {
        type: "error";
        messageContains?: string | undefined;
    } | {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        type: "response_time_ms";
        max: number;
    } | {
        type: "json_path";
        path: string;
        expected?: any;
    } | {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    } | {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    } | {
        type: "json_schema";
        schema: string;
    })[];
    arguments: Record<string, any>;
    timeout?: number | undefined;
    description?: string | undefined;
    skip?: boolean | undefined;
    only?: boolean | undefined;
}, {
    tool: string;
    type: "tool";
    name: string;
    assertions: ({
        type: "success";
    } | {
        type: "error";
        messageContains?: string | undefined;
    } | {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        type: "response_time_ms";
        max: number;
    } | {
        type: "json_path";
        path: string;
        expected?: any;
    } | {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    } | {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    } | {
        type: "json_schema";
        schema: string;
    })[];
    arguments: Record<string, any>;
    timeout?: number | undefined;
    description?: string | undefined;
    skip?: boolean | undefined;
    only?: boolean | undefined;
}>, z.ZodObject<{
    name: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    assertions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
        type: z.ZodLiteral<"success">;
    }, "strip", z.ZodTypeAny, {
        type: "success";
    }, {
        type: "success";
    }>, z.ZodObject<{
        type: z.ZodLiteral<"error">;
        messageContains: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        type: "error";
        messageContains?: string | undefined;
    }, {
        type: "error";
        messageContains?: string | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"contains_text">;
        text: z.ZodString;
        caseInsensitive: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    }, {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"not_contains_text">;
        text: z.ZodString;
        caseInsensitive: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    }, {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"response_time_ms">;
        max: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        type: "response_time_ms";
        max: number;
    }, {
        type: "response_time_ms";
        max: number;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"json_path">;
        path: z.ZodString;
        expected: z.ZodOptional<z.ZodAny>;
    }, "strip", z.ZodTypeAny, {
        type: "json_path";
        path: string;
        expected?: any;
    }, {
        type: "json_path";
        path: string;
        expected?: any;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"regex_match">;
        pattern: z.ZodString;
        flags: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    }, {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"snapshot">;
        file: z.ZodString;
        ignoreFields: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    }, {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"json_schema">;
        schema: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: "json_schema";
        schema: string;
    }, {
        type: "json_schema";
        schema: string;
    }>]>, "many">;
    timeout: z.ZodOptional<z.ZodNumber>;
    skip: z.ZodOptional<z.ZodBoolean>;
    only: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"prompt">;
    prompt: z.ZodString;
    arguments: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
}, "strip", z.ZodTypeAny, {
    prompt: string;
    type: "prompt";
    name: string;
    assertions: ({
        type: "success";
    } | {
        type: "error";
        messageContains?: string | undefined;
    } | {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        type: "response_time_ms";
        max: number;
    } | {
        type: "json_path";
        path: string;
        expected?: any;
    } | {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    } | {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    } | {
        type: "json_schema";
        schema: string;
    })[];
    timeout?: number | undefined;
    description?: string | undefined;
    skip?: boolean | undefined;
    only?: boolean | undefined;
    arguments?: Record<string, any> | undefined;
}, {
    prompt: string;
    type: "prompt";
    name: string;
    assertions: ({
        type: "success";
    } | {
        type: "error";
        messageContains?: string | undefined;
    } | {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        type: "response_time_ms";
        max: number;
    } | {
        type: "json_path";
        path: string;
        expected?: any;
    } | {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    } | {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    } | {
        type: "json_schema";
        schema: string;
    })[];
    timeout?: number | undefined;
    description?: string | undefined;
    skip?: boolean | undefined;
    only?: boolean | undefined;
    arguments?: Record<string, any> | undefined;
}>, z.ZodObject<{
    name: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    assertions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
        type: z.ZodLiteral<"success">;
    }, "strip", z.ZodTypeAny, {
        type: "success";
    }, {
        type: "success";
    }>, z.ZodObject<{
        type: z.ZodLiteral<"error">;
        messageContains: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        type: "error";
        messageContains?: string | undefined;
    }, {
        type: "error";
        messageContains?: string | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"contains_text">;
        text: z.ZodString;
        caseInsensitive: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    }, {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"not_contains_text">;
        text: z.ZodString;
        caseInsensitive: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    }, {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"response_time_ms">;
        max: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        type: "response_time_ms";
        max: number;
    }, {
        type: "response_time_ms";
        max: number;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"json_path">;
        path: z.ZodString;
        expected: z.ZodOptional<z.ZodAny>;
    }, "strip", z.ZodTypeAny, {
        type: "json_path";
        path: string;
        expected?: any;
    }, {
        type: "json_path";
        path: string;
        expected?: any;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"regex_match">;
        pattern: z.ZodString;
        flags: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    }, {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"snapshot">;
        file: z.ZodString;
        ignoreFields: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    }, {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"json_schema">;
        schema: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: "json_schema";
        schema: string;
    }, {
        type: "json_schema";
        schema: string;
    }>]>, "many">;
    timeout: z.ZodOptional<z.ZodNumber>;
    skip: z.ZodOptional<z.ZodBoolean>;
    only: z.ZodOptional<z.ZodBoolean>;
} & {
    type: z.ZodLiteral<"resource">;
    uri: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "resource";
    name: string;
    assertions: ({
        type: "success";
    } | {
        type: "error";
        messageContains?: string | undefined;
    } | {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        type: "response_time_ms";
        max: number;
    } | {
        type: "json_path";
        path: string;
        expected?: any;
    } | {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    } | {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    } | {
        type: "json_schema";
        schema: string;
    })[];
    uri: string;
    timeout?: number | undefined;
    description?: string | undefined;
    skip?: boolean | undefined;
    only?: boolean | undefined;
}, {
    type: "resource";
    name: string;
    assertions: ({
        type: "success";
    } | {
        type: "error";
        messageContains?: string | undefined;
    } | {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        type: "response_time_ms";
        max: number;
    } | {
        type: "json_path";
        path: string;
        expected?: any;
    } | {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    } | {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    } | {
        type: "json_schema";
        schema: string;
    })[];
    uri: string;
    timeout?: number | undefined;
    description?: string | undefined;
    skip?: boolean | undefined;
    only?: boolean | undefined;
}>]>, {
    tool: string;
    type: "tool";
    name: string;
    assertions: ({
        type: "success";
    } | {
        type: "error";
        messageContains?: string | undefined;
    } | {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        type: "response_time_ms";
        max: number;
    } | {
        type: "json_path";
        path: string;
        expected?: any;
    } | {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    } | {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    } | {
        type: "json_schema";
        schema: string;
    })[];
    arguments: Record<string, any>;
    timeout?: number | undefined;
    description?: string | undefined;
    skip?: boolean | undefined;
    only?: boolean | undefined;
} | {
    prompt: string;
    type: "prompt";
    name: string;
    assertions: ({
        type: "success";
    } | {
        type: "error";
        messageContains?: string | undefined;
    } | {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        type: "response_time_ms";
        max: number;
    } | {
        type: "json_path";
        path: string;
        expected?: any;
    } | {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    } | {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    } | {
        type: "json_schema";
        schema: string;
    })[];
    timeout?: number | undefined;
    description?: string | undefined;
    skip?: boolean | undefined;
    only?: boolean | undefined;
    arguments?: Record<string, any> | undefined;
} | {
    type: "resource";
    name: string;
    assertions: ({
        type: "success";
    } | {
        type: "error";
        messageContains?: string | undefined;
    } | {
        text: string;
        type: "contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        text: string;
        type: "not_contains_text";
        caseInsensitive?: boolean | undefined;
    } | {
        type: "response_time_ms";
        max: number;
    } | {
        type: "json_path";
        path: string;
        expected?: any;
    } | {
        type: "regex_match";
        pattern: string;
        flags?: string | undefined;
    } | {
        type: "snapshot";
        file: string;
        ignoreFields?: string[] | undefined;
    } | {
        type: "json_schema";
        schema: string;
    })[];
    uri: string;
    timeout?: number | undefined;
    description?: string | undefined;
    skip?: boolean | undefined;
    only?: boolean | undefined;
}, unknown>;
/**
 * Test suite specification schema
 */
declare const TestSuiteSpecSchema: z.ZodObject<{
    name: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    tests: z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
        name: z.ZodString;
        description: z.ZodOptional<z.ZodString>;
        assertions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
            type: z.ZodLiteral<"success">;
        }, "strip", z.ZodTypeAny, {
            type: "success";
        }, {
            type: "success";
        }>, z.ZodObject<{
            type: z.ZodLiteral<"error">;
            messageContains: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            type: "error";
            messageContains?: string | undefined;
        }, {
            type: "error";
            messageContains?: string | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"contains_text">;
            text: z.ZodString;
            caseInsensitive: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        }, {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"not_contains_text">;
            text: z.ZodString;
            caseInsensitive: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        }, {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"response_time_ms">;
            max: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            type: "response_time_ms";
            max: number;
        }, {
            type: "response_time_ms";
            max: number;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"json_path">;
            path: z.ZodString;
            expected: z.ZodOptional<z.ZodAny>;
        }, "strip", z.ZodTypeAny, {
            type: "json_path";
            path: string;
            expected?: any;
        }, {
            type: "json_path";
            path: string;
            expected?: any;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"regex_match">;
            pattern: z.ZodString;
            flags: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        }, {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"snapshot">;
            file: z.ZodString;
            ignoreFields: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        }, "strip", z.ZodTypeAny, {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        }, {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"json_schema">;
            schema: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type: "json_schema";
            schema: string;
        }, {
            type: "json_schema";
            schema: string;
        }>]>, "many">;
        timeout: z.ZodOptional<z.ZodNumber>;
        skip: z.ZodOptional<z.ZodBoolean>;
        only: z.ZodOptional<z.ZodBoolean>;
    } & {
        type: z.ZodLiteral<"tool">;
        tool: z.ZodString;
        arguments: z.ZodRecord<z.ZodString, z.ZodAny>;
    }, "strip", z.ZodTypeAny, {
        tool: string;
        type: "tool";
        name: string;
        assertions: ({
            type: "success";
        } | {
            type: "error";
            messageContains?: string | undefined;
        } | {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            type: "response_time_ms";
            max: number;
        } | {
            type: "json_path";
            path: string;
            expected?: any;
        } | {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        } | {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        } | {
            type: "json_schema";
            schema: string;
        })[];
        arguments: Record<string, any>;
        timeout?: number | undefined;
        description?: string | undefined;
        skip?: boolean | undefined;
        only?: boolean | undefined;
    }, {
        tool: string;
        type: "tool";
        name: string;
        assertions: ({
            type: "success";
        } | {
            type: "error";
            messageContains?: string | undefined;
        } | {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            type: "response_time_ms";
            max: number;
        } | {
            type: "json_path";
            path: string;
            expected?: any;
        } | {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        } | {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        } | {
            type: "json_schema";
            schema: string;
        })[];
        arguments: Record<string, any>;
        timeout?: number | undefined;
        description?: string | undefined;
        skip?: boolean | undefined;
        only?: boolean | undefined;
    }>, z.ZodObject<{
        name: z.ZodString;
        description: z.ZodOptional<z.ZodString>;
        assertions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
            type: z.ZodLiteral<"success">;
        }, "strip", z.ZodTypeAny, {
            type: "success";
        }, {
            type: "success";
        }>, z.ZodObject<{
            type: z.ZodLiteral<"error">;
            messageContains: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            type: "error";
            messageContains?: string | undefined;
        }, {
            type: "error";
            messageContains?: string | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"contains_text">;
            text: z.ZodString;
            caseInsensitive: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        }, {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"not_contains_text">;
            text: z.ZodString;
            caseInsensitive: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        }, {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"response_time_ms">;
            max: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            type: "response_time_ms";
            max: number;
        }, {
            type: "response_time_ms";
            max: number;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"json_path">;
            path: z.ZodString;
            expected: z.ZodOptional<z.ZodAny>;
        }, "strip", z.ZodTypeAny, {
            type: "json_path";
            path: string;
            expected?: any;
        }, {
            type: "json_path";
            path: string;
            expected?: any;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"regex_match">;
            pattern: z.ZodString;
            flags: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        }, {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"snapshot">;
            file: z.ZodString;
            ignoreFields: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        }, "strip", z.ZodTypeAny, {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        }, {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"json_schema">;
            schema: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type: "json_schema";
            schema: string;
        }, {
            type: "json_schema";
            schema: string;
        }>]>, "many">;
        timeout: z.ZodOptional<z.ZodNumber>;
        skip: z.ZodOptional<z.ZodBoolean>;
        only: z.ZodOptional<z.ZodBoolean>;
    } & {
        type: z.ZodLiteral<"prompt">;
        prompt: z.ZodString;
        arguments: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    }, "strip", z.ZodTypeAny, {
        prompt: string;
        type: "prompt";
        name: string;
        assertions: ({
            type: "success";
        } | {
            type: "error";
            messageContains?: string | undefined;
        } | {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            type: "response_time_ms";
            max: number;
        } | {
            type: "json_path";
            path: string;
            expected?: any;
        } | {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        } | {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        } | {
            type: "json_schema";
            schema: string;
        })[];
        timeout?: number | undefined;
        description?: string | undefined;
        skip?: boolean | undefined;
        only?: boolean | undefined;
        arguments?: Record<string, any> | undefined;
    }, {
        prompt: string;
        type: "prompt";
        name: string;
        assertions: ({
            type: "success";
        } | {
            type: "error";
            messageContains?: string | undefined;
        } | {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            type: "response_time_ms";
            max: number;
        } | {
            type: "json_path";
            path: string;
            expected?: any;
        } | {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        } | {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        } | {
            type: "json_schema";
            schema: string;
        })[];
        timeout?: number | undefined;
        description?: string | undefined;
        skip?: boolean | undefined;
        only?: boolean | undefined;
        arguments?: Record<string, any> | undefined;
    }>, z.ZodObject<{
        name: z.ZodString;
        description: z.ZodOptional<z.ZodString>;
        assertions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
            type: z.ZodLiteral<"success">;
        }, "strip", z.ZodTypeAny, {
            type: "success";
        }, {
            type: "success";
        }>, z.ZodObject<{
            type: z.ZodLiteral<"error">;
            messageContains: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            type: "error";
            messageContains?: string | undefined;
        }, {
            type: "error";
            messageContains?: string | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"contains_text">;
            text: z.ZodString;
            caseInsensitive: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        }, {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"not_contains_text">;
            text: z.ZodString;
            caseInsensitive: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        }, {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"response_time_ms">;
            max: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            type: "response_time_ms";
            max: number;
        }, {
            type: "response_time_ms";
            max: number;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"json_path">;
            path: z.ZodString;
            expected: z.ZodOptional<z.ZodAny>;
        }, "strip", z.ZodTypeAny, {
            type: "json_path";
            path: string;
            expected?: any;
        }, {
            type: "json_path";
            path: string;
            expected?: any;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"regex_match">;
            pattern: z.ZodString;
            flags: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        }, {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"snapshot">;
            file: z.ZodString;
            ignoreFields: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        }, "strip", z.ZodTypeAny, {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        }, {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        }>, z.ZodObject<{
            type: z.ZodLiteral<"json_schema">;
            schema: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type: "json_schema";
            schema: string;
        }, {
            type: "json_schema";
            schema: string;
        }>]>, "many">;
        timeout: z.ZodOptional<z.ZodNumber>;
        skip: z.ZodOptional<z.ZodBoolean>;
        only: z.ZodOptional<z.ZodBoolean>;
    } & {
        type: z.ZodLiteral<"resource">;
        uri: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: "resource";
        name: string;
        assertions: ({
            type: "success";
        } | {
            type: "error";
            messageContains?: string | undefined;
        } | {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            type: "response_time_ms";
            max: number;
        } | {
            type: "json_path";
            path: string;
            expected?: any;
        } | {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        } | {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        } | {
            type: "json_schema";
            schema: string;
        })[];
        uri: string;
        timeout?: number | undefined;
        description?: string | undefined;
        skip?: boolean | undefined;
        only?: boolean | undefined;
    }, {
        type: "resource";
        name: string;
        assertions: ({
            type: "success";
        } | {
            type: "error";
            messageContains?: string | undefined;
        } | {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            type: "response_time_ms";
            max: number;
        } | {
            type: "json_path";
            path: string;
            expected?: any;
        } | {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        } | {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        } | {
            type: "json_schema";
            schema: string;
        })[];
        uri: string;
        timeout?: number | undefined;
        description?: string | undefined;
        skip?: boolean | undefined;
        only?: boolean | undefined;
    }>]>, {
        tool: string;
        type: "tool";
        name: string;
        assertions: ({
            type: "success";
        } | {
            type: "error";
            messageContains?: string | undefined;
        } | {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            type: "response_time_ms";
            max: number;
        } | {
            type: "json_path";
            path: string;
            expected?: any;
        } | {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        } | {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        } | {
            type: "json_schema";
            schema: string;
        })[];
        arguments: Record<string, any>;
        timeout?: number | undefined;
        description?: string | undefined;
        skip?: boolean | undefined;
        only?: boolean | undefined;
    } | {
        prompt: string;
        type: "prompt";
        name: string;
        assertions: ({
            type: "success";
        } | {
            type: "error";
            messageContains?: string | undefined;
        } | {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            type: "response_time_ms";
            max: number;
        } | {
            type: "json_path";
            path: string;
            expected?: any;
        } | {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        } | {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        } | {
            type: "json_schema";
            schema: string;
        })[];
        timeout?: number | undefined;
        description?: string | undefined;
        skip?: boolean | undefined;
        only?: boolean | undefined;
        arguments?: Record<string, any> | undefined;
    } | {
        type: "resource";
        name: string;
        assertions: ({
            type: "success";
        } | {
            type: "error";
            messageContains?: string | undefined;
        } | {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            type: "response_time_ms";
            max: number;
        } | {
            type: "json_path";
            path: string;
            expected?: any;
        } | {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        } | {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        } | {
            type: "json_schema";
            schema: string;
        })[];
        uri: string;
        timeout?: number | undefined;
        description?: string | undefined;
        skip?: boolean | undefined;
        only?: boolean | undefined;
    }, unknown>]>, "many">;
    setup: z.ZodOptional<z.ZodObject<{
        serverUrl: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        serverUrl?: string | undefined;
    }, {
        serverUrl?: string | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    name: string;
    tests: (string | {
        tool: string;
        type: "tool";
        name: string;
        assertions: ({
            type: "success";
        } | {
            type: "error";
            messageContains?: string | undefined;
        } | {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            type: "response_time_ms";
            max: number;
        } | {
            type: "json_path";
            path: string;
            expected?: any;
        } | {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        } | {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        } | {
            type: "json_schema";
            schema: string;
        })[];
        arguments: Record<string, any>;
        timeout?: number | undefined;
        description?: string | undefined;
        skip?: boolean | undefined;
        only?: boolean | undefined;
    } | {
        prompt: string;
        type: "prompt";
        name: string;
        assertions: ({
            type: "success";
        } | {
            type: "error";
            messageContains?: string | undefined;
        } | {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            type: "response_time_ms";
            max: number;
        } | {
            type: "json_path";
            path: string;
            expected?: any;
        } | {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        } | {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        } | {
            type: "json_schema";
            schema: string;
        })[];
        timeout?: number | undefined;
        description?: string | undefined;
        skip?: boolean | undefined;
        only?: boolean | undefined;
        arguments?: Record<string, any> | undefined;
    } | {
        type: "resource";
        name: string;
        assertions: ({
            type: "success";
        } | {
            type: "error";
            messageContains?: string | undefined;
        } | {
            text: string;
            type: "contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            text: string;
            type: "not_contains_text";
            caseInsensitive?: boolean | undefined;
        } | {
            type: "response_time_ms";
            max: number;
        } | {
            type: "json_path";
            path: string;
            expected?: any;
        } | {
            type: "regex_match";
            pattern: string;
            flags?: string | undefined;
        } | {
            type: "snapshot";
            file: string;
            ignoreFields?: string[] | undefined;
        } | {
            type: "json_schema";
            schema: string;
        })[];
        uri: string;
        timeout?: number | undefined;
        description?: string | undefined;
        skip?: boolean | undefined;
        only?: boolean | undefined;
    })[];
    description?: string | undefined;
    setup?: {
        serverUrl?: string | undefined;
    } | undefined;
}, {
    name: string;
    tests: unknown[];
    description?: string | undefined;
    setup?: {
        serverUrl?: string | undefined;
    } | undefined;
}>;

/**
 * JSON Reporter
 *
 * Outputs test results in machine-parseable JSON format.
 *
 * Design: Fully portable, optimized for agent consumption
 */

/**
 * Format test results as JSON
 *
 * @param results - Test run results
 * @param pretty - Pretty print (default: true)
 * @returns JSON string
 */
declare function formatAsJSON(results: TestRunResults, pretty?: boolean): string;
/**
 * Print test results as JSON to console
 *
 * @param results - Test run results
 * @param pretty - Pretty print (default: true)
 */
declare function printJSON(results: TestRunResults, pretty?: boolean): void;
/**
 * Get a simple pass/fail summary for agents
 *
 * Returns minimal JSON for quick checks.
 *
 * @param results - Test run results
 * @returns Simplified JSON string
 */
declare function formatSimpleSummary(results: TestRunResults): string;

/**
 * Console Reporter
 *
 * Outputs human-readable test results to console.
 *
 * Design: Fully portable, colorized console output
 */

/**
 * Print full test results in human-readable format
 *
 * @param results - Test run results
 */
declare function printConsole(results: TestRunResults): void;
/**
 * Print a simple pass/fail message
 *
 * @param results - Test run results
 */
declare function printSimple(results: TestRunResults): void;

/**
 * Assertion Engine
 *
 * Runs assertions against MCP tool responses.
 *
 * Design: Fully portable, no project-specific dependencies
 */

/**
 * Run all assertions against a tool response
 *
 * @param assertions - List of assertions to run
 * @param response - MCP tool response
 * @param duration - Response time in milliseconds
 * @returns Array of assertion results
 */
declare function runAssertions(assertions: Assertion[], response: MCPToolResponse, duration: number): Promise<AssertionResult[]>;

export { type Assertion, type AssertionResult, AssertionSchema, type ContainsTextAssertion, type ErrorAssertion, type IMCPTestClient, type JsonPathAssertion, type MCPServerInfo, type MCPTool, type MCPToolResponse, type NotContainsTextAssertion, type RegexMatchAssertion, type ResponseTimeAssertion, type SuccessAssertion, type TestHarnessConfig, type TestResult, type TestRunResults, TestRunner, type TestSpec, TestSpecSchema, TestSuiteSpecSchema, type TestSummary, formatAsJSON, formatSimpleSummary, loadTestSpec, loadTestSuiteSpec, parseTestSpec, printConsole, printJSON, printSimple, runAssertions, serializeTestSpecToJSON, serializeTestSpecToYAML };
