{"version":3,"sources":["../../src/harness/assertions/success.ts","../../src/harness/assertions/helpers.ts","../../src/harness/assertions/error.ts","../../src/harness/assertions/contains-text.ts","../../src/harness/assertions/response-time.ts","../../src/harness/assertions/json-path.ts","../../src/harness/assertions/regex.ts","../../src/harness/assertions/index.ts","../../src/harness/runner.ts","../../src/harness/validation/schemas.ts","../../src/harness/spec-loader.ts","../../src/harness/reporters/json.ts","../../src/harness/reporters/console.ts"],"names":["parseYAML","stringifyYAML"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Success Assertion\n *\n * Verifies that the tool call succeeded (no error).\n */\n\nimport type { MCPToolResponse } from \"../types/client.js\";\nimport type { AssertionResult } from \"../types/results.js\";\n\n/**\n * Check if tool call was successful\n *\n * @param response - MCP tool response\n * @returns Assertion result\n */\nexport function checkSuccess(response: MCPToolResponse): AssertionResult {\n\tconst isError = response.isError === true;\n\n\tif (isError) {\n\t\treturn {\n\t\t\ttype: \"success\",\n\t\t\tpassed: false,\n\t\t\tmessage: \"Tool call returned an error\",\n\t\t\texpected: \"success\",\n\t\t\tactual: \"error\",\n\t\t};\n\t}\n\n\treturn {\n\t\ttype: \"success\",\n\t\tpassed: true,\n\t\tmessage: \"Tool call succeeded\",\n\t};\n}\n","/**\n * Assertion Helpers\n *\n * Shared utility functions for assertions.\n */\n\nimport type {\n\tMCPToolResponse,\n\tMCPPromptResponse,\n\tMCPResourceContent,\n} from \"../types/client.js\";\n\n/** Union type for all MCP response types */\nexport type MCPResponse = MCPToolResponse | MCPPromptResponse | MCPResourceContent;\n\n/**\n * Get text content from any MCP response\n *\n * Helper function to extract text from various response types.\n *\n * @param response - MCP response (tool, prompt, or resource)\n * @returns Concatenated text content\n */\nexport function getResponseText(response: MCPResponse): string {\n\t// Handle tool responses\n\tif (\"content\" in response && Array.isArray(response.content)) {\n\t\treturn response.content\n\t\t\t.filter((item) => item.type === \"text\")\n\t\t\t.map((item) => item.text)\n\t\t\t.join(\"\\n\");\n\t}\n\n\t// Handle prompt responses\n\tif (\"messages\" in response && Array.isArray(response.messages)) {\n\t\treturn response.messages\n\t\t\t.map((msg) => {\n\t\t\t\tif (msg.content.type === \"text\") {\n\t\t\t\t\treturn msg.content.text || \"\";\n\t\t\t\t}\n\t\t\t\treturn \"\";\n\t\t\t})\n\t\t\t.join(\"\\n\");\n\t}\n\n\t// Handle resource responses\n\tif (\"contents\" in response && Array.isArray(response.contents)) {\n\t\treturn response.contents\n\t\t\t.filter((item) => item.text)\n\t\t\t.map((item) => item.text)\n\t\t\t.join(\"\\n\");\n\t}\n\n\t// Unknown response type\n\treturn \"\";\n}\n","/**\n * Error Assertion\n *\n * Checks that a tool call resulted in an error.\n *\n * Design: Fully portable, no project-specific dependencies\n */\n\nimport type { AssertionResult } from \"../types/results.js\";\nimport type { MCPToolResponse } from \"../types/client.js\";\nimport { getResponseText } from \"./helpers.js\";\n\n/**\n * Check that the tool call resulted in an error\n *\n * @param response - MCP tool response\n * @param messageContains - Optional text that error message should contain\n * @returns Assertion result\n */\nexport function checkError(response: MCPToolResponse, messageContains?: string): AssertionResult {\n\t// Check if response indicates an error\n\tif (!response.isError) {\n\t\treturn {\n\t\t\ttype: \"error\",\n\t\t\tpassed: false,\n\t\t\tmessage: \"Expected tool call to fail, but it succeeded\",\n\t\t\texpected: \"error\",\n\t\t\tactual: \"success\",\n\t\t};\n\t}\n\n\t// If messageContains is specified, check error message\n\tif (messageContains) {\n\t\tconst responseText = getResponseText(response);\n\n\t\tif (!responseText.toLowerCase().includes(messageContains.toLowerCase())) {\n\t\t\treturn {\n\t\t\t\ttype: \"error\",\n\t\t\t\tpassed: false,\n\t\t\t\tmessage: `Error message does not contain expected text: \"${messageContains}\"`,\n\t\t\t\texpected: `error containing \"${messageContains}\"`,\n\t\t\t\tactual: responseText.substring(0, 200),\n\t\t\t};\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: \"error\",\n\t\tpassed: true,\n\t\tmessage: messageContains\n\t\t\t? `Tool call failed as expected with message containing \"${messageContains}\"`\n\t\t\t: \"Tool call failed as expected\",\n\t};\n}\n","/**\n * Contains Text Assertions\n *\n * Verifies that response contains (or doesn't contain) specific text.\n */\n\nimport type { AssertionResult } from \"../types/results.js\";\nimport { getResponseText, type MCPResponse } from \"./helpers.js\";\n\n/**\n * Check if response contains specific text\n *\n * @param response - MCP response (tool, prompt, or resource)\n * @param text - Text to search for\n * @param caseInsensitive - Case insensitive matching\n * @returns Assertion result\n */\nexport function checkContainsText(\n\tresponse: MCPResponse,\n\ttext: string,\n\tcaseInsensitive = false,\n): AssertionResult {\n\tconst responseText = getResponseText(response);\n\tconst searchText = caseInsensitive ? text.toLowerCase() : text;\n\tconst targetText = caseInsensitive ? responseText.toLowerCase() : responseText;\n\n\tconst contains = targetText.includes(searchText);\n\n\tif (!contains) {\n\t\treturn {\n\t\t\ttype: \"contains_text\",\n\t\t\tpassed: false,\n\t\t\tmessage: `Response does not contain expected text: \"${text}\"`,\n\t\t\texpected: `text containing \"${text}\"`,\n\t\t\tactual: responseText.substring(0, 200), // First 200 chars\n\t\t};\n\t}\n\n\treturn {\n\t\ttype: \"contains_text\",\n\t\tpassed: true,\n\t\tmessage: `Response contains expected text: \"${text}\"`,\n\t};\n}\n\n/**\n * Check if response does NOT contain specific text\n *\n * @param response - MCP response (tool, prompt, or resource)\n * @param text - Text that should not be present\n * @param caseInsensitive - Case insensitive matching\n * @returns Assertion result\n */\nexport function checkNotContainsText(\n\tresponse: MCPResponse,\n\ttext: string,\n\tcaseInsensitive = false,\n): AssertionResult {\n\tconst responseText = getResponseText(response);\n\tconst searchText = caseInsensitive ? text.toLowerCase() : text;\n\tconst targetText = caseInsensitive ? responseText.toLowerCase() : responseText;\n\n\tconst contains = targetText.includes(searchText);\n\n\tif (contains) {\n\t\treturn {\n\t\t\ttype: \"not_contains_text\",\n\t\t\tpassed: false,\n\t\t\tmessage: `Response should not contain text: \"${text}\"`,\n\t\t\texpected: `text not containing \"${text}\"`,\n\t\t\tactual: responseText.substring(0, 200), // First 200 chars\n\t\t};\n\t}\n\n\treturn {\n\t\ttype: \"not_contains_text\",\n\t\tpassed: true,\n\t\tmessage: `Response does not contain unwanted text: \"${text}\"`,\n\t};\n}\n","/**\n * Response Time Assertion\n *\n * Verifies that the tool response time is within acceptable limits.\n */\n\nimport type { AssertionResult } from \"../types/results.js\";\n\n/**\n * Check if response time is within maximum threshold\n *\n * @param duration - Actual response time in milliseconds\n * @param maxMs - Maximum acceptable response time in milliseconds\n * @returns Assertion result\n */\nexport function checkResponseTime(duration: number, maxMs: number): AssertionResult {\n\tconst withinLimit = duration <= maxMs;\n\n\tif (!withinLimit) {\n\t\treturn {\n\t\t\ttype: \"response_time_ms\",\n\t\t\tpassed: false,\n\t\t\tmessage: `Response time ${duration}ms exceeds maximum ${maxMs}ms`,\n\t\t\texpected: `â‰¤ ${maxMs}ms`,\n\t\t\tactual: `${duration}ms`,\n\t\t};\n\t}\n\n\treturn {\n\t\ttype: \"response_time_ms\",\n\t\tpassed: true,\n\t\tmessage: `Response time ${duration}ms is within limit (${maxMs}ms)`,\n\t};\n}\n","/**\n * JSON Path Assertion\n *\n * Verifies values at specific JSON paths in the response.\n */\n\nimport type { AssertionResult } from \"../types/results.js\";\nimport { getResponseText, type MCPResponse } from \"./helpers.js\";\n\n/**\n * Simple JSON path evaluator\n *\n * Supports basic paths like:\n * - $.property\n * - $.property.nested\n * - $.array[0]\n * - $.array[*].property\n *\n * @param obj - Object to query\n * @param path - JSON path expression\n * @returns Value at path or undefined\n */\nfunction evaluateJsonPath(obj: any, path: string): any {\n\t// Remove leading $. if present\n\tconst normalizedPath = path.replace(/^\\$\\.?/, \"\");\n\n\tif (!normalizedPath) {\n\t\treturn obj;\n\t}\n\n\t// Split path into segments\n\tconst segments = normalizedPath.split(/\\.|\\[/).map((s) => s.replace(/\\]/, \"\"));\n\n\tlet current = obj;\n\n\tfor (const segment of segments) {\n\t\tif (current === undefined || current === null) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Handle array wildcard [*]\n\t\tif (segment === \"*\") {\n\t\t\tif (!Array.isArray(current)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// For wildcards, we'll just return the array for now\n\t\t\t// More complex wildcard handling can be added later\n\t\t\treturn current;\n\t\t}\n\n\t\t// Handle numeric array index\n\t\tif (/^\\d+$/.test(segment)) {\n\t\t\tconst index = Number.parseInt(segment, 10);\n\t\t\tcurrent = current[index];\n\t\t} else {\n\t\t\tcurrent = current[segment];\n\t\t}\n\t}\n\n\treturn current;\n}\n\n/**\n * Deep equality check\n */\nfunction deepEqual(a: any, b: any): boolean {\n\tif (a === b) return true;\n\n\tif (typeof a !== typeof b) return false;\n\n\tif (typeof a !== \"object\" || a === null || b === null) {\n\t\treturn a === b;\n\t}\n\n\tif (Array.isArray(a) !== Array.isArray(b)) return false;\n\n\tif (Array.isArray(a)) {\n\t\tif (a.length !== b.length) return false;\n\t\treturn a.every((val, idx) => deepEqual(val, b[idx]));\n\t}\n\n\tconst keysA = Object.keys(a);\n\tconst keysB = Object.keys(b);\n\n\tif (keysA.length !== keysB.length) return false;\n\n\treturn keysA.every((key) => deepEqual(a[key], b[key]));\n}\n\n/**\n * Check if value at JSON path matches expected value\n *\n * @param response - MCP response (tool, prompt, or resource)\n * @param path - JSON path expression\n * @param expected - Expected value at path (optional - if omitted, checks path existence)\n * @returns Assertion result\n */\nexport async function checkJsonPath(\n\tresponse: MCPResponse,\n\tpath: string,\n\texpected?: any,\n): Promise<AssertionResult> {\n\ttry {\n\t\tlet responseData: any;\n\n\t\t// For prompts and resources, use the response object directly\n\t\t// For tools, parse the text content as JSON\n\t\tif (\"messages\" in response) {\n\t\t\t// Prompt response - use the response object directly\n\t\t\tresponseData = response;\n\t\t} else if (\"contents\" in response && Array.isArray(response.contents)) {\n\t\t\t// Resource response - use the response object directly\n\t\t\tresponseData = response;\n\t\t} else if (\"content\" in response && Array.isArray(response.content)) {\n\t\t\t// Tool response - try to parse the text content as JSON\n\t\t\tconst responseText = getResponseText(response);\n\t\t\ttry {\n\t\t\t\tresponseData = JSON.parse(responseText);\n\t\t\t} catch {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"json_path\",\n\t\t\t\t\tpassed: false,\n\t\t\t\t\tmessage: \"Response is not valid JSON\",\n\t\t\t\t\texpected: \"valid JSON\",\n\t\t\t\t\tactual: \"invalid JSON\",\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: \"json_path\",\n\t\t\t\tpassed: false,\n\t\t\t\tmessage: \"Unknown response type\",\n\t\t\t\texpected: \"valid MCP response\",\n\t\t\t\tactual: \"unknown type\",\n\t\t\t};\n\t\t}\n\n\t\t// Evaluate path\n\t\tconst actual = evaluateJsonPath(responseData, path);\n\n\t\t// If expected is undefined, check path existence\n\t\tif (expected === undefined) {\n\t\t\tconst exists = actual !== undefined;\n\t\t\treturn {\n\t\t\t\ttype: \"json_path\",\n\t\t\t\tpassed: exists,\n\t\t\t\tmessage: exists\n\t\t\t\t\t? `Path \"${path}\" exists with value: ${JSON.stringify(actual)}`\n\t\t\t\t\t: `Path \"${path}\" does not exist in response`,\n\t\t\t\tactual: exists ? actual : undefined,\n\t\t\t};\n\t\t}\n\n\t\t// Compare with expected value\n\t\tconst matches = deepEqual(actual, expected);\n\n\t\tif (!matches) {\n\t\t\t// Provide helpful type mismatch hints\n\t\t\tconst actualType = typeof actual;\n\t\t\tconst expectedType = typeof expected;\n\t\t\tconst typeHint =\n\t\t\t\tactualType !== expectedType\n\t\t\t\t\t? ` (type mismatch: ${actualType} vs ${expectedType})`\n\t\t\t\t\t: \"\";\n\n\t\t\treturn {\n\t\t\t\ttype: \"json_path\",\n\t\t\t\tpassed: false,\n\t\t\t\tmessage: `Value at path \"${path}\" does not match expected${typeHint}`,\n\t\t\t\texpected,\n\t\t\t\tactual,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"json_path\",\n\t\t\tpassed: true,\n\t\t\tmessage: `Value at path \"${path}\" matches expected value`,\n\t\t\texpected,\n\t\t\tactual,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\ttype: \"json_path\",\n\t\t\tpassed: false,\n\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t};\n\t}\n}\n","/**\n * Regex Match Assertion\n *\n * Verifies that response matches a regular expression pattern.\n */\n\nimport type { MCPToolResponse } from \"../types/client.js\";\nimport type { AssertionResult } from \"../types/results.js\";\nimport { getResponseText } from \"./helpers.js\";\n\n/**\n * Check if response matches regex pattern\n *\n * @param response - MCP tool response\n * @param pattern - Regex pattern string\n * @param flags - Regex flags (e.g., \"i\" for case-insensitive)\n * @returns Assertion result\n */\nexport function checkRegexMatch(\n\tresponse: MCPToolResponse,\n\tpattern: string,\n\tflags?: string,\n): AssertionResult {\n\tconst responseText = getResponseText(response);\n\n\ttry {\n\t\tconst regex = new RegExp(pattern, flags);\n\t\tconst matches = regex.test(responseText);\n\n\t\tif (!matches) {\n\t\t\treturn {\n\t\t\t\ttype: \"regex_match\",\n\t\t\t\tpassed: false,\n\t\t\t\tmessage: `Response does not match pattern: ${pattern}`,\n\t\t\t\texpected: `text matching /${pattern}/${flags || \"\"}`,\n\t\t\t\tactual: responseText.substring(0, 200), // First 200 chars\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"regex_match\",\n\t\t\tpassed: true,\n\t\t\tmessage: `Response matches pattern: ${pattern}`,\n\t\t};\n\t} catch (error) {\n\t\treturn {\n\t\t\ttype: \"regex_match\",\n\t\t\tpassed: false,\n\t\t\tmessage: `Invalid regex pattern: ${error instanceof Error ? error.message : String(error)}`,\n\t\t};\n\t}\n}\n","/**\n * Assertion Engine\n *\n * Runs assertions against MCP tool responses.\n *\n * Design: Fully portable, no project-specific dependencies\n */\n\nimport type { Assertion } from \"../types/spec.js\";\nimport type { AssertionResult } from \"../types/results.js\";\nimport type { MCPToolResponse } from \"../types/client.js\";\nimport { checkSuccess } from \"./success.js\";\nimport { checkError } from \"./error.js\";\nimport { checkContainsText, checkNotContainsText } from \"./contains-text.js\";\nimport { checkResponseTime } from \"./response-time.js\";\nimport { checkJsonPath } from \"./json-path.js\";\nimport { checkRegexMatch } from \"./regex.js\";\n\n/**\n * Run all assertions against a tool response\n *\n * @param assertions - List of assertions to run\n * @param response - MCP tool response\n * @param duration - Response time in milliseconds\n * @returns Array of assertion results\n */\nexport async function runAssertions(\n\tassertions: Assertion[],\n\tresponse: MCPToolResponse,\n\tduration: number,\n): Promise<AssertionResult[]> {\n\tconst results: AssertionResult[] = [];\n\n\tfor (const assertion of assertions) {\n\t\tlet result: AssertionResult;\n\n\t\ttry {\n\t\t\tswitch (assertion.type) {\n\t\t\t\tcase \"success\":\n\t\t\t\t\tresult = checkSuccess(response);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"error\":\n\t\t\t\t\tresult = checkError(response, assertion.messageContains);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"contains_text\":\n\t\t\t\t\tresult = checkContainsText(response, assertion.text, assertion.caseInsensitive);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"not_contains_text\":\n\t\t\t\t\tresult = checkNotContainsText(response, assertion.text, assertion.caseInsensitive);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"response_time_ms\":\n\t\t\t\t\tresult = checkResponseTime(duration, assertion.max);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"json_path\":\n\t\t\t\t\tresult = await checkJsonPath(response, assertion.path, assertion.expected);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"regex_match\":\n\t\t\t\t\tresult = checkRegexMatch(response, assertion.pattern, assertion.flags);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"snapshot\":\n\t\t\t\t\t// Snapshot assertions are handled separately (require file system access)\n\t\t\t\t\tresult = {\n\t\t\t\t\t\ttype: \"snapshot\",\n\t\t\t\t\t\tpassed: false,\n\t\t\t\t\t\tmessage: \"Snapshot assertions not yet implemented in this context\",\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"json_schema\":\n\t\t\t\t\t// JSON Schema assertions are handled separately (require file system access)\n\t\t\t\t\tresult = {\n\t\t\t\t\t\ttype: \"json_schema\",\n\t\t\t\t\t\tpassed: false,\n\t\t\t\t\t\tmessage: \"JSON Schema assertions not yet implemented in this context\",\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tresult = {\n\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\tpassed: false,\n\t\t\t\t\t\tmessage: `Unknown assertion type: ${(assertion as any).type}`,\n\t\t\t\t\t};\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tresult = {\n\t\t\t\ttype: assertion.type,\n\t\t\t\tpassed: false,\n\t\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\t};\n\t\t}\n\n\t\tresults.push(result);\n\t}\n\n\treturn results;\n}\n\n// Export individual assertion functions (for testing)\nexport { checkSuccess } from \"./success.js\";\nexport { checkError } from \"./error.js\";\nexport { checkContainsText, checkNotContainsText } from \"./contains-text.js\";\nexport { checkResponseTime } from \"./response-time.js\";\nexport { checkJsonPath } from \"./json-path.js\";\nexport { checkRegexMatch } from \"./regex.js\";\n\n// Export helper functions\nexport { getResponseText } from \"./helpers.js\";\n","/**\n * Core Test Runner\n *\n * Executes test specifications against an MCP server.\n *\n * Design: Fully portable, uses IMCPTestClient interface\n */\n\nimport type { IMCPTestClient } from \"./types/client.js\";\nimport type { TestSpec } from \"./types/spec.js\";\nimport type { TestResult, TestRunResults, TestSummary } from \"./types/results.js\";\nimport { runAssertions } from \"./assertions/index.js\";\n\n/**\n * Test Runner\n *\n * Executes tests using the provided MCP client.\n */\nexport class TestRunner {\n\tconstructor(private client: IMCPTestClient) {}\n\n\t/**\n\t * Run a single test specification\n\t *\n\t * @param spec - Test specification to run\n\t * @returns Test result\n\t */\n\tasync runTest(spec: TestSpec): Promise<TestResult> {\n\t\t// Handle skipped tests\n\t\tif (spec.skip) {\n\t\t\treturn {\n\t\t\t\tname: spec.name,\n\t\t\t\tdescription: spec.description,\n\t\t\t\tpassed: false,\n\t\t\t\tduration: 0,\n\t\t\t\tassertions: [],\n\t\t\t\tskipped: true,\n\t\t\t};\n\t\t}\n\n\t\tconst startTime = Date.now();\n\n\t\ttry {\n\t\t\t// Dispatch based on test type\n\t\t\tlet response: any;\n\n\t\t\tswitch (spec.type) {\n\t\t\t\tcase \"tool\":\n\t\t\t\t\t// Execute tool test\n\t\t\t\t\tresponse = await this.client.callTool(spec.tool, spec.arguments);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"prompt\":\n\t\t\t\t\t// Execute prompt test\n\t\t\t\t\tresponse = await this.client.getPrompt(spec.prompt, spec.arguments);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"resource\":\n\t\t\t\t\t// Execute resource test\n\t\t\t\t\tresponse = await this.client.readResource(spec.uri);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// TypeScript should ensure this is never reached\n\t\t\t\t\t// But provide fallback for safety\n\t\t\t\t\tthrow new Error(`Unknown test type: ${(spec as any).type}`);\n\t\t\t}\n\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\t// Run assertions\n\t\t\tconst assertionResults = await runAssertions(spec.assertions, response, duration);\n\n\t\t\t// Determine if test passed (all assertions must pass)\n\t\t\tconst passed = assertionResults.every((a) => a.passed);\n\n\t\t\treturn {\n\t\t\t\tname: spec.name,\n\t\t\t\tdescription: spec.description,\n\t\t\t\tpassed,\n\t\t\t\tduration,\n\t\t\t\tassertions: assertionResults,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconst duration = Date.now() - startTime;\n\n\t\t\treturn {\n\t\t\t\tname: spec.name,\n\t\t\t\tdescription: spec.description,\n\t\t\t\tpassed: false,\n\t\t\t\tduration,\n\t\t\t\tassertions: [],\n\t\t\t\terror: {\n\t\t\t\t\tmessage: error instanceof Error ? error.message : String(error),\n\t\t\t\t\tstack: error instanceof Error ? error.stack : undefined,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Run multiple test specifications\n\t *\n\t * @param specs - Array of test specifications\n\t * @param serverUrl - Server URL being tested (for reporting)\n\t * @returns Complete test run results\n\t */\n\tasync runTests(specs: TestSpec[], serverUrl?: string): Promise<TestRunResults> {\n\t\tconst startTime = Date.now();\n\t\tconst results: TestResult[] = [];\n\n\t\t// Check for \"only\" tests\n\t\tconst onlyTests = specs.filter((s) => s.only);\n\t\tconst testsToRun = onlyTests.length > 0 ? onlyTests : specs;\n\n\t\t// Run each test\n\t\tfor (const spec of testsToRun) {\n\t\t\tconst result = await this.runTest(spec);\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst totalDuration = Date.now() - startTime;\n\n\t\t// Build summary\n\t\tconst summary: TestSummary = {\n\t\t\ttotal: results.length,\n\t\t\tpassed: results.filter((r) => r.passed).length,\n\t\t\tfailed: results.filter((r) => !r.passed && !r.skipped).length,\n\t\t\tskipped: results.filter((r) => r.skipped).length,\n\t\t\tduration: totalDuration,\n\t\t\tsuccessRate: results.length > 0 ? results.filter((r) => r.passed).length / results.length : 0,\n\t\t};\n\n\t\t// Collect failures\n\t\tconst failures = results\n\t\t\t.filter((r) => !r.passed && !r.skipped)\n\t\t\t.flatMap((r) => {\n\t\t\t\t// If test had an error\n\t\t\t\tif (r.error) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttest: r.name,\n\t\t\t\t\t\t\tassertion: \"execution\",\n\t\t\t\t\t\t\texpected: \"successful execution\",\n\t\t\t\t\t\t\tactual: \"error\",\n\t\t\t\t\t\t\tmessage: r.error.message,\n\t\t\t\t\t\t},\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\t// Failed assertions\n\t\t\t\treturn r.assertions\n\t\t\t\t\t.filter((a) => !a.passed)\n\t\t\t\t\t.map((a) => ({\n\t\t\t\t\t\ttest: r.name,\n\t\t\t\t\t\tassertion: a.type,\n\t\t\t\t\t\texpected: a.expected,\n\t\t\t\t\t\tactual: a.actual,\n\t\t\t\t\t\tmessage: a.message || \"Assertion failed\",\n\t\t\t\t\t}));\n\t\t\t});\n\n\t\treturn {\n\t\t\tsummary,\n\t\t\ttests: results,\n\t\t\tfailures,\n\t\t\ttimestamp: new Date().toISOString(),\n\t\t\tserverUrl,\n\t\t};\n\t}\n\n\t/**\n\t * Connect to the MCP server\n\t *\n\t * Must be called before running tests.\n\t */\n\tasync connect(): Promise<void> {\n\t\tawait this.client.connect();\n\t}\n\n\t/**\n\t * Disconnect from the MCP server\n\t *\n\t * Should be called after tests complete.\n\t */\n\tasync disconnect(): Promise<void> {\n\t\tawait this.client.disconnect();\n\t}\n}\n","/**\n * Zod Validation Schemas\n *\n * Validates test specifications loaded from YAML/JSON files.\n *\n * Design: Fully portable, uses Zod for runtime validation\n */\n\nimport { z } from \"zod\";\n\n/**\n * Assertion schemas\n */\nconst SuccessAssertionSchema = z.object({\n\ttype: z.literal(\"success\"),\n});\n\nconst ErrorAssertionSchema = z.object({\n\ttype: z.literal(\"error\"),\n\tmessageContains: z.string().optional(),\n});\n\nconst ContainsTextAssertionSchema = z.object({\n\ttype: z.literal(\"contains_text\"),\n\ttext: z.string(),\n\tcaseInsensitive: z.boolean().optional(),\n});\n\nconst NotContainsTextAssertionSchema = z.object({\n\ttype: z.literal(\"not_contains_text\"),\n\ttext: z.string(),\n\tcaseInsensitive: z.boolean().optional(),\n});\n\nconst ResponseTimeAssertionSchema = z.object({\n\ttype: z.literal(\"response_time_ms\"),\n\tmax: z.number().positive(),\n});\n\nconst JsonPathAssertionSchema = z.object({\n\ttype: z.literal(\"json_path\"),\n\tpath: z.string(),\n\texpected: z.any().optional(),\n});\n\nconst RegexMatchAssertionSchema = z.object({\n\ttype: z.literal(\"regex_match\"),\n\tpattern: z.string(),\n\tflags: z.string().optional(),\n});\n\nconst SnapshotAssertionSchema = z.object({\n\ttype: z.literal(\"snapshot\"),\n\tfile: z.string(),\n\tignoreFields: z.array(z.string()).optional(),\n});\n\nconst JsonSchemaAssertionSchema = z.object({\n\ttype: z.literal(\"json_schema\"),\n\tschema: z.string(),\n});\n\n/**\n * Union of all assertion types\n */\nexport const AssertionSchema = z.discriminatedUnion(\"type\", [\n\tSuccessAssertionSchema,\n\tErrorAssertionSchema,\n\tContainsTextAssertionSchema,\n\tNotContainsTextAssertionSchema,\n\tResponseTimeAssertionSchema,\n\tJsonPathAssertionSchema,\n\tRegexMatchAssertionSchema,\n\tSnapshotAssertionSchema,\n\tJsonSchemaAssertionSchema,\n]);\n\n/**\n * Base test specification schema (shared fields)\n */\nconst BaseTestSpecSchema = z.object({\n\tname: z.string().min(1, \"Test name is required\"),\n\tdescription: z.string().optional(),\n\tassertions: z.array(AssertionSchema).min(1, \"At least one assertion required\"),\n\ttimeout: z.number().positive().optional(),\n\tskip: z.boolean().optional(),\n\tonly: z.boolean().optional(),\n});\n\n/**\n * Tool test specification schema\n */\nconst ToolTestSpecSchema = BaseTestSpecSchema.extend({\n\ttype: z.literal(\"tool\"),\n\ttool: z.string().min(1, \"Tool name is required\"),\n\targuments: z.record(z.any()),\n});\n\n/**\n * Prompt test specification schema\n */\nconst PromptTestSpecSchema = BaseTestSpecSchema.extend({\n\ttype: z.literal(\"prompt\"),\n\tprompt: z.string().min(1, \"Prompt name is required\"),\n\targuments: z.record(z.any()).optional(),\n});\n\n/**\n * Resource test specification schema\n */\nconst ResourceTestSpecSchema = BaseTestSpecSchema.extend({\n\ttype: z.literal(\"resource\"),\n\turi: z.string().min(1, \"Resource URI is required\"),\n});\n\n/**\n * Test specification schema (discriminated union)\n */\nconst TestSpecUnionSchema = z.discriminatedUnion(\"type\", [\n\tToolTestSpecSchema,\n\tPromptTestSpecSchema,\n\tResourceTestSpecSchema,\n]);\n\n/**\n * Test specification schema with backward compatibility\n *\n * Handles old test specs without a 'type' field by treating them as tool tests.\n */\nexport const TestSpecSchema = z.preprocess(\n\t(data) => {\n\t\t// If data has a 'type' field, use it as-is\n\t\tif (typeof data === \"object\" && data !== null && \"type\" in data) {\n\t\t\treturn data;\n\t\t}\n\n\t\t// If data has a 'tool' field but no 'type', it's a legacy tool test\n\t\tif (typeof data === \"object\" && data !== null && \"tool\" in data) {\n\t\t\treturn { ...data, type: \"tool\" };\n\t\t}\n\n\t\t// Otherwise, pass through and let validation fail with helpful message\n\t\treturn data;\n\t},\n\tTestSpecUnionSchema,\n);\n\n/**\n * Test suite specification schema\n */\nexport const TestSuiteSpecSchema = z.object({\n\tname: z.string().min(1, \"Suite name is required\"),\n\tdescription: z.string().optional(),\n\ttests: z.array(z.union([z.string(), TestSpecSchema])),\n\tsetup: z\n\t\t.object({\n\t\t\tserverUrl: z.string().url().optional(),\n\t\t})\n\t\t.optional(),\n});\n\n/**\n * Validate a test spec object\n *\n * @param data - Raw data to validate\n * @returns Validated TestSpec\n * @throws ZodError if validation fails\n */\nexport function validateTestSpec(data: unknown) {\n\treturn TestSpecSchema.parse(data);\n}\n\n/**\n * Validate a test suite spec object\n *\n * @param data - Raw data to validate\n * @returns Validated TestSuiteSpec\n * @throws ZodError if validation fails\n */\nexport function validateTestSuiteSpec(data: unknown) {\n\treturn TestSuiteSpecSchema.parse(data);\n}\n\n/**\n * Safe validation that returns success/error\n */\nexport function safeValidateTestSpec(data: unknown) {\n\treturn TestSpecSchema.safeParse(data);\n}\n\nexport function safeValidateTestSuiteSpec(data: unknown) {\n\treturn TestSuiteSpecSchema.safeParse(data);\n}\n","/**\n * Test Specification Loader\n *\n * Loads and validates test specifications from YAML or JSON files.\n *\n * Design: Fully portable, no project-specific dependencies\n */\n\nimport { readFile } from \"node:fs/promises\";\nimport { extname } from \"node:path\";\nimport { parse as parseYAML, stringify as stringifyYAML } from \"yaml\";\nimport { validateTestSpec, validateTestSuiteSpec } from \"./validation/schemas.js\";\nimport type { TestSpec, TestSuiteSpec } from \"./types/spec.js\";\n\n/**\n * Load a test specification from a file\n *\n * Supports both YAML (.yaml, .yml) and JSON (.json) formats.\n *\n * @param filePath - Path to test spec file\n * @returns Validated TestSpec\n * @throws Error if file cannot be read or validation fails\n */\nexport async function loadTestSpec(filePath: string): Promise<TestSpec> {\n\tconst content = await readFile(filePath, \"utf-8\");\n\tconst ext = extname(filePath).toLowerCase();\n\n\tlet data: unknown;\n\n\tif (ext === \".yaml\" || ext === \".yml\") {\n\t\tdata = parseYAML(content);\n\t} else if (ext === \".json\") {\n\t\tdata = JSON.parse(content);\n\t} else {\n\t\tthrow new Error(`Unsupported file format: ${ext}. Use .yaml, .yml, or .json`);\n\t}\n\n\ttry {\n\t\treturn validateTestSpec(data);\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\tthrow new Error(`Invalid test spec in ${filePath}: ${error.message}`);\n\t\t}\n\t\tthrow error;\n\t}\n}\n\n/**\n * Load a test suite specification from a file\n *\n * @param filePath - Path to test suite spec file\n * @returns Validated TestSuiteSpec\n * @throws Error if file cannot be read or validation fails\n */\nexport async function loadTestSuiteSpec(filePath: string): Promise<TestSuiteSpec> {\n\tconst content = await readFile(filePath, \"utf-8\");\n\tconst ext = extname(filePath).toLowerCase();\n\n\tlet data: unknown;\n\n\tif (ext === \".yaml\" || ext === \".yml\") {\n\t\tdata = parseYAML(content);\n\t} else if (ext === \".json\") {\n\t\tdata = JSON.parse(content);\n\t} else {\n\t\tthrow new Error(`Unsupported file format: ${ext}. Use .yaml, .yml, or .json`);\n\t}\n\n\ttry {\n\t\treturn validateTestSuiteSpec(data);\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\tthrow new Error(`Invalid test suite spec in ${filePath}: ${error.message}`);\n\t\t}\n\t\tthrow error;\n\t}\n}\n\n/**\n * Parse a test spec from a string\n *\n * Useful for programmatic test generation.\n *\n * @param content - YAML or JSON string\n * @param format - Format of the content ('yaml' or 'json')\n * @returns Validated TestSpec\n */\nexport function parseTestSpec(content: string, format: \"yaml\" | \"json\"): TestSpec {\n\tlet data: unknown;\n\n\tif (format === \"yaml\") {\n\t\tdata = parseYAML(content);\n\t} else {\n\t\tdata = JSON.parse(content);\n\t}\n\n\treturn validateTestSpec(data);\n}\n\n/**\n * Serialize a test spec to YAML string\n *\n * @param spec - TestSpec object\n * @returns YAML string\n */\nexport function serializeTestSpecToYAML(spec: TestSpec): string {\n\treturn stringifyYAML(spec);\n}\n\n/**\n * Serialize a test spec to JSON string\n *\n * @param spec - TestSpec object\n * @param pretty - Pretty print (default: true)\n * @returns JSON string\n */\nexport function serializeTestSpecToJSON(spec: TestSpec, pretty = true): string {\n\treturn pretty ? JSON.stringify(spec, null, 2) : JSON.stringify(spec);\n}\n","/**\n * JSON Reporter\n *\n * Outputs test results in machine-parseable JSON format.\n *\n * Design: Fully portable, optimized for agent consumption\n */\n\nimport type { TestRunResults } from \"../types/results.js\";\n\n/**\n * Format test results as JSON\n *\n * @param results - Test run results\n * @param pretty - Pretty print (default: true)\n * @returns JSON string\n */\nexport function formatAsJSON(results: TestRunResults, pretty = true): string {\n\treturn pretty ? JSON.stringify(results, null, 2) : JSON.stringify(results);\n}\n\n/**\n * Print test results as JSON to console\n *\n * @param results - Test run results\n * @param pretty - Pretty print (default: true)\n */\nexport function printJSON(results: TestRunResults, pretty = true): void {\n\tconsole.log(formatAsJSON(results, pretty));\n}\n\n/**\n * Get a simple pass/fail summary for agents\n *\n * Returns minimal JSON for quick checks.\n *\n * @param results - Test run results\n * @returns Simplified JSON string\n */\nexport function formatSimpleSummary(results: TestRunResults): string {\n\tconst summary = {\n\t\tpassed: results.summary.passed === results.summary.total,\n\t\ttotal: results.summary.total,\n\t\tpassed_count: results.summary.passed,\n\t\tfailed_count: results.summary.failed,\n\t\tduration_ms: results.summary.duration,\n\t\tsuccess_rate: results.summary.successRate,\n\t};\n\n\treturn JSON.stringify(summary, null, 2);\n}\n","/**\n * Console Reporter\n *\n * Outputs human-readable test results to console.\n *\n * Design: Fully portable, colorized console output\n */\n\nimport type { TestRunResults, TestResult } from \"../types/results.js\";\n\n// ANSI color codes\nconst colors = {\n\treset: \"\\x1b[0m\",\n\tgreen: \"\\x1b[32m\",\n\tred: \"\\x1b[31m\",\n\tyellow: \"\\x1b[33m\",\n\tblue: \"\\x1b[34m\",\n\tgray: \"\\x1b[90m\",\n\tbold: \"\\x1b[1m\",\n};\n\n/**\n * Print a single test result\n */\nfunction printTestResult(test: TestResult, index: number): void {\n\tconst status = test.skipped\n\t\t? `${colors.yellow}SKIP${colors.reset}`\n\t\t: test.passed\n\t\t\t? `${colors.green}PASS${colors.reset}`\n\t\t\t: `${colors.red}FAIL${colors.reset}`;\n\n\tconst duration = `${colors.gray}${test.duration}ms${colors.reset}`;\n\n\tconsole.log(`  ${status} ${test.name} ${duration}`);\n\n\t// Show failed assertions\n\tif (!test.passed && !test.skipped) {\n\t\tif (test.error) {\n\t\t\tconsole.log(`    ${colors.red}âœ—${colors.reset} ${test.error.message}`);\n\t\t} else {\n\t\t\tfor (const assertion of test.assertions) {\n\t\t\t\tif (!assertion.passed) {\n\t\t\t\t\tconsole.log(`    ${colors.red}âœ—${colors.reset} ${assertion.type}: ${assertion.message}`);\n\t\t\t\t\tif (assertion.expected !== undefined) {\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`      Expected: ${colors.gray}${JSON.stringify(assertion.expected)}${colors.reset}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`      Actual:   ${colors.gray}${JSON.stringify(assertion.actual)}${colors.reset}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Print test run summary\n */\nfunction printSummary(results: TestRunResults): void {\n\tconsole.log(\"\");\n\tconsole.log(`${colors.bold}Test Summary${colors.reset}`);\n\tconsole.log(`${colors.gray}${\"â”€\".repeat(50)}${colors.reset}`);\n\n\tconst passed = results.summary.passed;\n\tconst failed = results.summary.failed;\n\tconst skipped = results.summary.skipped;\n\tconst total = results.summary.total;\n\n\tconsole.log(`Total:   ${total}`);\n\tconsole.log(`${colors.green}Passed:  ${passed}${colors.reset}`);\n\n\tif (failed > 0) {\n\t\tconsole.log(`${colors.red}Failed:  ${failed}${colors.reset}`);\n\t}\n\n\tif (skipped > 0) {\n\t\tconsole.log(`${colors.yellow}Skipped: ${skipped}${colors.reset}`);\n\t}\n\n\tconsole.log(`Duration: ${results.summary.duration}ms`);\n\tconsole.log(`Success Rate: ${(results.summary.successRate * 100).toFixed(1)}%`);\n\tconsole.log(\"\");\n}\n\n/**\n * Print full test results in human-readable format\n *\n * @param results - Test run results\n */\nexport function printConsole(results: TestRunResults): void {\n\tconsole.log(\"\");\n\tconsole.log(`${colors.bold}Running Integration Tests${colors.reset}`);\n\n\tif (results.serverUrl) {\n\t\tconsole.log(`${colors.gray}Server: ${results.serverUrl}${colors.reset}`);\n\t}\n\n\tconsole.log(`${colors.gray}Timestamp: ${results.timestamp}${colors.reset}`);\n\tconsole.log(\"\");\n\n\t// Print each test result\n\tresults.tests.forEach((test, index) => {\n\t\tprintTestResult(test, index);\n\t});\n\n\t// Print summary\n\tprintSummary(results);\n\n\t// Print failures in detail\n\tif (results.failures.length > 0) {\n\t\tconsole.log(`${colors.bold}${colors.red}Failures:${colors.reset}`);\n\t\tconsole.log(`${colors.gray}${\"â”€\".repeat(50)}${colors.reset}`);\n\n\t\tfor (const failure of results.failures) {\n\t\t\tconsole.log(`${colors.red}âœ—${colors.reset} ${failure.test}`);\n\t\t\tconsole.log(`  Assertion: ${failure.assertion}`);\n\t\t\tconsole.log(`  Message: ${failure.message}`);\n\n\t\t\tif (failure.expected !== undefined) {\n\t\t\t\tconsole.log(`  Expected: ${JSON.stringify(failure.expected)}`);\n\t\t\t\tconsole.log(`  Actual: ${JSON.stringify(failure.actual)}`);\n\t\t\t}\n\n\t\t\tconsole.log(\"\");\n\t\t}\n\t}\n}\n\n/**\n * Print a simple pass/fail message\n *\n * @param results - Test run results\n */\nexport function printSimple(results: TestRunResults): void {\n\tconst allPassed = results.summary.failed === 0;\n\n\tif (allPassed) {\n\t\tconsole.log(\n\t\t\t`${colors.green}${colors.bold}âœ“ All tests passed${colors.reset} (${results.summary.passed}/${results.summary.total})`,\n\t\t);\n\t} else {\n\t\tconsole.log(\n\t\t\t`${colors.red}${colors.bold}âœ— Tests failed${colors.reset} (${results.summary.failed} failed, ${results.summary.passed} passed)`,\n\t\t);\n\t}\n}\n"]}