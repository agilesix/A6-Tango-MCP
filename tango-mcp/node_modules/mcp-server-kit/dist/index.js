import { readFile, readdir, access, mkdir, writeFile, copyFile, stat } from 'fs/promises';
import { extname, join, dirname } from 'path';
import { parse, stringify } from 'yaml';
import { z } from 'zod';
import { fileURLToPath } from 'url';
import Handlebars from 'handlebars';

// src/harness/assertions/success.ts
function checkSuccess(response) {
  const isError = response.isError === true;
  if (isError) {
    return {
      type: "success",
      passed: false,
      message: "Tool call returned an error",
      expected: "success",
      actual: "error"
    };
  }
  return {
    type: "success",
    passed: true,
    message: "Tool call succeeded"
  };
}

// src/harness/assertions/helpers.ts
function getResponseText(response) {
  if ("content" in response && Array.isArray(response.content)) {
    return response.content.filter((item) => item.type === "text").map((item) => item.text).join("\n");
  }
  if ("messages" in response && Array.isArray(response.messages)) {
    return response.messages.map((msg) => {
      if (msg.content.type === "text") {
        return msg.content.text || "";
      }
      return "";
    }).join("\n");
  }
  if ("contents" in response && Array.isArray(response.contents)) {
    return response.contents.filter((item) => item.text).map((item) => item.text).join("\n");
  }
  return "";
}

// src/harness/assertions/error.ts
function checkError(response, messageContains) {
  if (!response.isError) {
    return {
      type: "error",
      passed: false,
      message: "Expected tool call to fail, but it succeeded",
      expected: "error",
      actual: "success"
    };
  }
  if (messageContains) {
    const responseText = getResponseText(response);
    if (!responseText.toLowerCase().includes(messageContains.toLowerCase())) {
      return {
        type: "error",
        passed: false,
        message: `Error message does not contain expected text: "${messageContains}"`,
        expected: `error containing "${messageContains}"`,
        actual: responseText.substring(0, 200)
      };
    }
  }
  return {
    type: "error",
    passed: true,
    message: messageContains ? `Tool call failed as expected with message containing "${messageContains}"` : "Tool call failed as expected"
  };
}

// src/harness/assertions/contains-text.ts
function checkContainsText(response, text, caseInsensitive = false) {
  const responseText = getResponseText(response);
  const searchText = caseInsensitive ? text.toLowerCase() : text;
  const targetText = caseInsensitive ? responseText.toLowerCase() : responseText;
  const contains = targetText.includes(searchText);
  if (!contains) {
    return {
      type: "contains_text",
      passed: false,
      message: `Response does not contain expected text: "${text}"`,
      expected: `text containing "${text}"`,
      actual: responseText.substring(0, 200)
      // First 200 chars
    };
  }
  return {
    type: "contains_text",
    passed: true,
    message: `Response contains expected text: "${text}"`
  };
}
function checkNotContainsText(response, text, caseInsensitive = false) {
  const responseText = getResponseText(response);
  const searchText = caseInsensitive ? text.toLowerCase() : text;
  const targetText = caseInsensitive ? responseText.toLowerCase() : responseText;
  const contains = targetText.includes(searchText);
  if (contains) {
    return {
      type: "not_contains_text",
      passed: false,
      message: `Response should not contain text: "${text}"`,
      expected: `text not containing "${text}"`,
      actual: responseText.substring(0, 200)
      // First 200 chars
    };
  }
  return {
    type: "not_contains_text",
    passed: true,
    message: `Response does not contain unwanted text: "${text}"`
  };
}

// src/harness/assertions/response-time.ts
function checkResponseTime(duration, maxMs) {
  const withinLimit = duration <= maxMs;
  if (!withinLimit) {
    return {
      type: "response_time_ms",
      passed: false,
      message: `Response time ${duration}ms exceeds maximum ${maxMs}ms`,
      expected: `\u2264 ${maxMs}ms`,
      actual: `${duration}ms`
    };
  }
  return {
    type: "response_time_ms",
    passed: true,
    message: `Response time ${duration}ms is within limit (${maxMs}ms)`
  };
}

// src/harness/assertions/json-path.ts
function evaluateJsonPath(obj, path) {
  const normalizedPath = path.replace(/^\$\.?/, "");
  if (!normalizedPath) {
    return obj;
  }
  const segments = normalizedPath.split(/\.|\[/).map((s) => s.replace(/\]/, ""));
  let current = obj;
  for (const segment of segments) {
    if (current === void 0 || current === null) {
      return void 0;
    }
    if (segment === "*") {
      if (!Array.isArray(current)) {
        return void 0;
      }
      return current;
    }
    if (/^\d+$/.test(segment)) {
      const index = Number.parseInt(segment, 10);
      current = current[index];
    } else {
      current = current[segment];
    }
  }
  return current;
}
function deepEqual(a, b) {
  if (a === b) return true;
  if (typeof a !== typeof b) return false;
  if (typeof a !== "object" || a === null || b === null) {
    return a === b;
  }
  if (Array.isArray(a) !== Array.isArray(b)) return false;
  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    return a.every((val, idx) => deepEqual(val, b[idx]));
  }
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  return keysA.every((key) => deepEqual(a[key], b[key]));
}
async function checkJsonPath(response, path, expected) {
  try {
    let responseData;
    if ("messages" in response) {
      responseData = response;
    } else if ("contents" in response && Array.isArray(response.contents)) {
      responseData = response;
    } else if ("content" in response && Array.isArray(response.content)) {
      const responseText = getResponseText(response);
      try {
        responseData = JSON.parse(responseText);
      } catch {
        return {
          type: "json_path",
          passed: false,
          message: "Response is not valid JSON",
          expected: "valid JSON",
          actual: "invalid JSON"
        };
      }
    } else {
      return {
        type: "json_path",
        passed: false,
        message: "Unknown response type",
        expected: "valid MCP response",
        actual: "unknown type"
      };
    }
    const actual = evaluateJsonPath(responseData, path);
    if (expected === void 0) {
      const exists = actual !== void 0;
      return {
        type: "json_path",
        passed: exists,
        message: exists ? `Path "${path}" exists with value: ${JSON.stringify(actual)}` : `Path "${path}" does not exist in response`,
        actual: exists ? actual : void 0
      };
    }
    const matches = deepEqual(actual, expected);
    if (!matches) {
      const actualType = typeof actual;
      const expectedType = typeof expected;
      const typeHint = actualType !== expectedType ? ` (type mismatch: ${actualType} vs ${expectedType})` : "";
      return {
        type: "json_path",
        passed: false,
        message: `Value at path "${path}" does not match expected${typeHint}`,
        expected,
        actual
      };
    }
    return {
      type: "json_path",
      passed: true,
      message: `Value at path "${path}" matches expected value`,
      expected,
      actual
    };
  } catch (error) {
    return {
      type: "json_path",
      passed: false,
      message: error instanceof Error ? error.message : String(error)
    };
  }
}

// src/harness/assertions/regex.ts
function checkRegexMatch(response, pattern, flags) {
  const responseText = getResponseText(response);
  try {
    const regex = new RegExp(pattern, flags);
    const matches = regex.test(responseText);
    if (!matches) {
      return {
        type: "regex_match",
        passed: false,
        message: `Response does not match pattern: ${pattern}`,
        expected: `text matching /${pattern}/${flags || ""}`,
        actual: responseText.substring(0, 200)
        // First 200 chars
      };
    }
    return {
      type: "regex_match",
      passed: true,
      message: `Response matches pattern: ${pattern}`
    };
  } catch (error) {
    return {
      type: "regex_match",
      passed: false,
      message: `Invalid regex pattern: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}

// src/harness/assertions/index.ts
async function runAssertions(assertions, response, duration) {
  const results = [];
  for (const assertion of assertions) {
    let result;
    try {
      switch (assertion.type) {
        case "success":
          result = checkSuccess(response);
          break;
        case "error":
          result = checkError(response, assertion.messageContains);
          break;
        case "contains_text":
          result = checkContainsText(response, assertion.text, assertion.caseInsensitive);
          break;
        case "not_contains_text":
          result = checkNotContainsText(response, assertion.text, assertion.caseInsensitive);
          break;
        case "response_time_ms":
          result = checkResponseTime(duration, assertion.max);
          break;
        case "json_path":
          result = await checkJsonPath(response, assertion.path, assertion.expected);
          break;
        case "regex_match":
          result = checkRegexMatch(response, assertion.pattern, assertion.flags);
          break;
        case "snapshot":
          result = {
            type: "snapshot",
            passed: false,
            message: "Snapshot assertions not yet implemented in this context"
          };
          break;
        case "json_schema":
          result = {
            type: "json_schema",
            passed: false,
            message: "JSON Schema assertions not yet implemented in this context"
          };
          break;
        default:
          result = {
            type: "unknown",
            passed: false,
            message: `Unknown assertion type: ${assertion.type}`
          };
      }
    } catch (error) {
      result = {
        type: assertion.type,
        passed: false,
        message: error instanceof Error ? error.message : String(error)
      };
    }
    results.push(result);
  }
  return results;
}

// src/harness/runner.ts
var TestRunner = class {
  constructor(client) {
    this.client = client;
  }
  /**
   * Run a single test specification
   *
   * @param spec - Test specification to run
   * @returns Test result
   */
  async runTest(spec) {
    if (spec.skip) {
      return {
        name: spec.name,
        description: spec.description,
        passed: false,
        duration: 0,
        assertions: [],
        skipped: true
      };
    }
    const startTime = Date.now();
    try {
      let response;
      switch (spec.type) {
        case "tool":
          response = await this.client.callTool(spec.tool, spec.arguments);
          break;
        case "prompt":
          response = await this.client.getPrompt(spec.prompt, spec.arguments);
          break;
        case "resource":
          response = await this.client.readResource(spec.uri);
          break;
        default:
          throw new Error(`Unknown test type: ${spec.type}`);
      }
      const duration = Date.now() - startTime;
      const assertionResults = await runAssertions(spec.assertions, response, duration);
      const passed = assertionResults.every((a) => a.passed);
      return {
        name: spec.name,
        description: spec.description,
        passed,
        duration,
        assertions: assertionResults
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      return {
        name: spec.name,
        description: spec.description,
        passed: false,
        duration,
        assertions: [],
        error: {
          message: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : void 0
        }
      };
    }
  }
  /**
   * Run multiple test specifications
   *
   * @param specs - Array of test specifications
   * @param serverUrl - Server URL being tested (for reporting)
   * @returns Complete test run results
   */
  async runTests(specs, serverUrl) {
    const startTime = Date.now();
    const results = [];
    const onlyTests = specs.filter((s) => s.only);
    const testsToRun = onlyTests.length > 0 ? onlyTests : specs;
    for (const spec of testsToRun) {
      const result = await this.runTest(spec);
      results.push(result);
    }
    const totalDuration = Date.now() - startTime;
    const summary = {
      total: results.length,
      passed: results.filter((r) => r.passed).length,
      failed: results.filter((r) => !r.passed && !r.skipped).length,
      skipped: results.filter((r) => r.skipped).length,
      duration: totalDuration,
      successRate: results.length > 0 ? results.filter((r) => r.passed).length / results.length : 0
    };
    const failures = results.filter((r) => !r.passed && !r.skipped).flatMap((r) => {
      if (r.error) {
        return [
          {
            test: r.name,
            assertion: "execution",
            expected: "successful execution",
            actual: "error",
            message: r.error.message
          }
        ];
      }
      return r.assertions.filter((a) => !a.passed).map((a) => ({
        test: r.name,
        assertion: a.type,
        expected: a.expected,
        actual: a.actual,
        message: a.message || "Assertion failed"
      }));
    });
    return {
      summary,
      tests: results,
      failures,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      serverUrl
    };
  }
  /**
   * Connect to the MCP server
   *
   * Must be called before running tests.
   */
  async connect() {
    await this.client.connect();
  }
  /**
   * Disconnect from the MCP server
   *
   * Should be called after tests complete.
   */
  async disconnect() {
    await this.client.disconnect();
  }
};
var SuccessAssertionSchema = z.object({
  type: z.literal("success")
});
var ErrorAssertionSchema = z.object({
  type: z.literal("error"),
  messageContains: z.string().optional()
});
var ContainsTextAssertionSchema = z.object({
  type: z.literal("contains_text"),
  text: z.string(),
  caseInsensitive: z.boolean().optional()
});
var NotContainsTextAssertionSchema = z.object({
  type: z.literal("not_contains_text"),
  text: z.string(),
  caseInsensitive: z.boolean().optional()
});
var ResponseTimeAssertionSchema = z.object({
  type: z.literal("response_time_ms"),
  max: z.number().positive()
});
var JsonPathAssertionSchema = z.object({
  type: z.literal("json_path"),
  path: z.string(),
  expected: z.any().optional()
});
var RegexMatchAssertionSchema = z.object({
  type: z.literal("regex_match"),
  pattern: z.string(),
  flags: z.string().optional()
});
var SnapshotAssertionSchema = z.object({
  type: z.literal("snapshot"),
  file: z.string(),
  ignoreFields: z.array(z.string()).optional()
});
var JsonSchemaAssertionSchema = z.object({
  type: z.literal("json_schema"),
  schema: z.string()
});
var AssertionSchema = z.discriminatedUnion("type", [
  SuccessAssertionSchema,
  ErrorAssertionSchema,
  ContainsTextAssertionSchema,
  NotContainsTextAssertionSchema,
  ResponseTimeAssertionSchema,
  JsonPathAssertionSchema,
  RegexMatchAssertionSchema,
  SnapshotAssertionSchema,
  JsonSchemaAssertionSchema
]);
var BaseTestSpecSchema = z.object({
  name: z.string().min(1, "Test name is required"),
  description: z.string().optional(),
  assertions: z.array(AssertionSchema).min(1, "At least one assertion required"),
  timeout: z.number().positive().optional(),
  skip: z.boolean().optional(),
  only: z.boolean().optional()
});
var ToolTestSpecSchema = BaseTestSpecSchema.extend({
  type: z.literal("tool"),
  tool: z.string().min(1, "Tool name is required"),
  arguments: z.record(z.any())
});
var PromptTestSpecSchema = BaseTestSpecSchema.extend({
  type: z.literal("prompt"),
  prompt: z.string().min(1, "Prompt name is required"),
  arguments: z.record(z.any()).optional()
});
var ResourceTestSpecSchema = BaseTestSpecSchema.extend({
  type: z.literal("resource"),
  uri: z.string().min(1, "Resource URI is required")
});
var TestSpecUnionSchema = z.discriminatedUnion("type", [
  ToolTestSpecSchema,
  PromptTestSpecSchema,
  ResourceTestSpecSchema
]);
var TestSpecSchema = z.preprocess(
  (data) => {
    if (typeof data === "object" && data !== null && "type" in data) {
      return data;
    }
    if (typeof data === "object" && data !== null && "tool" in data) {
      return { ...data, type: "tool" };
    }
    return data;
  },
  TestSpecUnionSchema
);
var TestSuiteSpecSchema = z.object({
  name: z.string().min(1, "Suite name is required"),
  description: z.string().optional(),
  tests: z.array(z.union([z.string(), TestSpecSchema])),
  setup: z.object({
    serverUrl: z.string().url().optional()
  }).optional()
});
function validateTestSpec(data) {
  return TestSpecSchema.parse(data);
}
function validateTestSuiteSpec(data) {
  return TestSuiteSpecSchema.parse(data);
}

// src/harness/spec-loader.ts
async function loadTestSpec(filePath) {
  const content = await readFile(filePath, "utf-8");
  const ext = extname(filePath).toLowerCase();
  let data;
  if (ext === ".yaml" || ext === ".yml") {
    data = parse(content);
  } else if (ext === ".json") {
    data = JSON.parse(content);
  } else {
    throw new Error(`Unsupported file format: ${ext}. Use .yaml, .yml, or .json`);
  }
  try {
    return validateTestSpec(data);
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Invalid test spec in ${filePath}: ${error.message}`);
    }
    throw error;
  }
}
async function loadTestSuiteSpec(filePath) {
  const content = await readFile(filePath, "utf-8");
  const ext = extname(filePath).toLowerCase();
  let data;
  if (ext === ".yaml" || ext === ".yml") {
    data = parse(content);
  } else if (ext === ".json") {
    data = JSON.parse(content);
  } else {
    throw new Error(`Unsupported file format: ${ext}. Use .yaml, .yml, or .json`);
  }
  try {
    return validateTestSuiteSpec(data);
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Invalid test suite spec in ${filePath}: ${error.message}`);
    }
    throw error;
  }
}
function parseTestSpec(content, format) {
  let data;
  if (format === "yaml") {
    data = parse(content);
  } else {
    data = JSON.parse(content);
  }
  return validateTestSpec(data);
}
function serializeTestSpecToYAML(spec) {
  return stringify(spec);
}
function serializeTestSpecToJSON(spec, pretty = true) {
  return pretty ? JSON.stringify(spec, null, 2) : JSON.stringify(spec);
}

// src/harness/reporters/json.ts
function formatAsJSON(results, pretty = true) {
  return pretty ? JSON.stringify(results, null, 2) : JSON.stringify(results);
}
function printJSON(results, pretty = true) {
  console.log(formatAsJSON(results, pretty));
}
function formatSimpleSummary(results) {
  const summary = {
    passed: results.summary.passed === results.summary.total,
    total: results.summary.total,
    passed_count: results.summary.passed,
    failed_count: results.summary.failed,
    duration_ms: results.summary.duration,
    success_rate: results.summary.successRate
  };
  return JSON.stringify(summary, null, 2);
}

// src/harness/reporters/console.ts
var colors = {
  reset: "\x1B[0m",
  green: "\x1B[32m",
  red: "\x1B[31m",
  yellow: "\x1B[33m",
  gray: "\x1B[90m",
  bold: "\x1B[1m"
};
function printTestResult(test, index) {
  const status = test.skipped ? `${colors.yellow}SKIP${colors.reset}` : test.passed ? `${colors.green}PASS${colors.reset}` : `${colors.red}FAIL${colors.reset}`;
  const duration = `${colors.gray}${test.duration}ms${colors.reset}`;
  console.log(`  ${status} ${test.name} ${duration}`);
  if (!test.passed && !test.skipped) {
    if (test.error) {
      console.log(`    ${colors.red}\u2717${colors.reset} ${test.error.message}`);
    } else {
      for (const assertion of test.assertions) {
        if (!assertion.passed) {
          console.log(`    ${colors.red}\u2717${colors.reset} ${assertion.type}: ${assertion.message}`);
          if (assertion.expected !== void 0) {
            console.log(
              `      Expected: ${colors.gray}${JSON.stringify(assertion.expected)}${colors.reset}`
            );
            console.log(
              `      Actual:   ${colors.gray}${JSON.stringify(assertion.actual)}${colors.reset}`
            );
          }
        }
      }
    }
  }
}
function printSummary(results) {
  console.log("");
  console.log(`${colors.bold}Test Summary${colors.reset}`);
  console.log(`${colors.gray}${"\u2500".repeat(50)}${colors.reset}`);
  const passed = results.summary.passed;
  const failed = results.summary.failed;
  const skipped = results.summary.skipped;
  const total = results.summary.total;
  console.log(`Total:   ${total}`);
  console.log(`${colors.green}Passed:  ${passed}${colors.reset}`);
  if (failed > 0) {
    console.log(`${colors.red}Failed:  ${failed}${colors.reset}`);
  }
  if (skipped > 0) {
    console.log(`${colors.yellow}Skipped: ${skipped}${colors.reset}`);
  }
  console.log(`Duration: ${results.summary.duration}ms`);
  console.log(`Success Rate: ${(results.summary.successRate * 100).toFixed(1)}%`);
  console.log("");
}
function printConsole(results) {
  console.log("");
  console.log(`${colors.bold}Running Integration Tests${colors.reset}`);
  if (results.serverUrl) {
    console.log(`${colors.gray}Server: ${results.serverUrl}${colors.reset}`);
  }
  console.log(`${colors.gray}Timestamp: ${results.timestamp}${colors.reset}`);
  console.log("");
  results.tests.forEach((test, index) => {
    printTestResult(test);
  });
  printSummary(results);
  if (results.failures.length > 0) {
    console.log(`${colors.bold}${colors.red}Failures:${colors.reset}`);
    console.log(`${colors.gray}${"\u2500".repeat(50)}${colors.reset}`);
    for (const failure of results.failures) {
      console.log(`${colors.red}\u2717${colors.reset} ${failure.test}`);
      console.log(`  Assertion: ${failure.assertion}`);
      console.log(`  Message: ${failure.message}`);
      if (failure.expected !== void 0) {
        console.log(`  Expected: ${JSON.stringify(failure.expected)}`);
        console.log(`  Actual: ${JSON.stringify(failure.actual)}`);
      }
      console.log("");
    }
  }
}
function printSimple(results) {
  const allPassed = results.summary.failed === 0;
  if (allPassed) {
    console.log(
      `${colors.green}${colors.bold}\u2713 All tests passed${colors.reset} (${results.summary.passed}/${results.summary.total})`
    );
  } else {
    console.log(
      `${colors.red}${colors.bold}\u2717 Tests failed${colors.reset} (${results.summary.failed} failed, ${results.summary.passed} passed)`
    );
  }
}
var TemplateVariableSchema = z.object({
  name: z.string().min(1).regex(/^[A-Z][A-Z0-9_]*$/, "Variable name must be uppercase with underscores"),
  required: z.boolean(),
  default: z.string().optional(),
  prompt: z.string().optional(),
  pattern: z.string().optional()
});
var PostScaffoldConfigSchema = z.object({
  install: z.boolean(),
  installCommand: z.string().optional(),
  postInstall: z.array(z.string()).optional(),
  smokeTest: z.string().optional()
});
var TemplateCapabilitiesSchema = z.object({
  runtime: z.string().min(1),
  transport: z.array(z.string().min(1)).min(1),
  deployment: z.enum(["remote", "local"]),
  language: z.enum(["typescript", "javascript"])
});
var TemplateDependenciesSchema = z.object({
  mcp_sdk: z.string().optional(),
  agents: z.string().optional(),
  runtime_specific: z.record(z.string()).optional()
});
var TemplateCLICommandsSchema = z.object({
  dev: z.string().min(1),
  test: z.string().min(1),
  deploy: z.string().optional(),
  typeCheck: z.string().optional()
});
var TemplateFeaturesSchema = z.object({
  unitTesting: z.boolean(),
  integrationTesting: z.boolean(),
  exampleTools: z.array(z.string()),
  documentation: z.boolean()
});
var TemplateCompatibilitySchema = z.object({
  node: z.string().optional(),
  npm: z.string().optional(),
  pnpm: z.string().optional(),
  yarn: z.string().optional()
});
var TemplateConfigSchema = z.object({
  id: z.string().min(1).regex(/^[a-z0-9-]+$/, "Template ID must be lowercase with hyphens"),
  version: z.string().regex(/^\d+\.\d+\.\d+$/, "Version must be semver (e.g., 1.0.0)"),
  name: z.string().min(1),
  description: z.string().min(1),
  capabilities: TemplateCapabilitiesSchema,
  dependencies: TemplateDependenciesSchema,
  scaffolding: z.object({
    variables: z.array(TemplateVariableSchema),
    postScaffold: PostScaffoldConfigSchema.optional()
  }),
  cli: TemplateCLICommandsSchema,
  features: TemplateFeaturesSchema,
  compatibility: TemplateCompatibilitySchema
});
z.object({
  id: z.string(),
  version: z.string(),
  name: z.string(),
  mcp_sdk_version: z.string().optional(),
  agents_version: z.string().optional(),
  scaffolded_at: z.string(),
  variables: z.record(z.string())
});
var ScaffoldOptionsSchema = z.object({
  template: z.string().min(1),
  targetDir: z.string().min(1),
  variables: z.record(z.string()),
  noInstall: z.boolean().optional(),
  packageManager: z.enum(["npm", "pnpm", "yarn", "bun"]).optional(),
  smokeTest: z.boolean().optional()
});
var TemplateFilterSchema = z.object({
  runtime: z.string().optional(),
  transport: z.string().optional(),
  deployment: z.enum(["remote", "local"]).optional(),
  language: z.enum(["typescript", "javascript"]).optional()
});
function validateTemplateConfig(config) {
  const result = TemplateConfigSchema.safeParse(config);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return { success: false, errors: result.error };
}
function validateScaffoldOptions(options) {
  const result = ScaffoldOptionsSchema.safeParse(options);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return { success: false, errors: result.error };
}

// src/core/template-system/registry.ts
function getTemplatesDir() {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);
  if (__dirname.includes("/src/")) {
    return join(__dirname, "../../../templates");
  } else {
    return join(__dirname, "../templates");
  }
}
var TemplateRegistry = class {
  templatesDir;
  templatesCache = /* @__PURE__ */ new Map();
  constructor(templatesDir) {
    this.templatesDir = templatesDir || getTemplatesDir();
  }
  /**
   * Discover all templates in the templates directory
   */
  async discoverTemplates() {
    try {
      const entries = await readdir(this.templatesDir, { withFileTypes: true });
      const templates = [];
      for (const entry of entries) {
        if (!entry.isDirectory()) continue;
        const templatePath = join(this.templatesDir, entry.name);
        const configPath = join(templatePath, "template.config.json");
        try {
          await access(configPath);
        } catch {
          continue;
        }
        try {
          const configContent = await readFile(configPath, "utf-8");
          const config = JSON.parse(configContent);
          const validation = validateTemplateConfig(config);
          if (validation.success && validation.data) {
            templates.push(validation.data);
            this.templatesCache.set(validation.data.id, {
              config: validation.data,
              path: templatePath,
              filesPath: join(templatePath, "files"),
              hooksPath: join(templatePath, "hooks")
            });
          } else {
            console.warn(
              `Skipping template ${entry.name}: Invalid config format`
            );
          }
        } catch (error) {
          console.warn(
            `Skipping template ${entry.name}: ${error instanceof Error ? error.message : String(error)}`
          );
          continue;
        }
      }
      return templates;
    } catch (error) {
      throw new Error(`Failed to discover templates: ${error}`);
    }
  }
  /**
   * Get a specific template by ID
   */
  async getTemplate(id) {
    if (this.templatesCache.has(id)) {
      return this.templatesCache.get(id);
    }
    await this.discoverTemplates();
    if (this.templatesCache.has(id)) {
      return this.templatesCache.get(id);
    }
    throw new Error(`Template not found: ${id}`);
  }
  /**
   * Validate a specific template
   */
  async validateTemplate(id) {
    const errors = [];
    const warnings = [];
    try {
      const template = await this.getTemplate(id);
      try {
        await access(template.filesPath);
      } catch {
        errors.push(`Files directory not found: ${template.filesPath}`);
      }
      const requiredFiles = ["package.json.hbs", "tsconfig.json", "README.md.hbs"];
      for (const file of requiredFiles) {
        try {
          await access(join(template.filesPath, file));
        } catch {
          warnings.push(`Recommended file missing: ${file}`);
        }
      }
      for (const variable of template.config.scaffolding.variables) {
        if (variable.required && variable.default) {
          warnings.push(`Variable ${variable.name} is required but has a default value`);
        }
      }
      if (template.config.capabilities.transport.length === 0) {
        errors.push("Template must support at least one transport");
      }
      return {
        valid: errors.length === 0,
        errors,
        warnings
      };
    } catch (error) {
      return {
        valid: false,
        errors: [`Failed to validate template: ${error}`],
        warnings: []
      };
    }
  }
  /**
   * List all templates with optional filtering
   */
  async listTemplates(filter) {
    const templates = await this.discoverTemplates();
    if (!filter) {
      return templates;
    }
    return templates.filter((template) => {
      if (filter.runtime && template.capabilities.runtime !== filter.runtime) {
        return false;
      }
      if (filter.transport && !template.capabilities.transport.includes(filter.transport)) {
        return false;
      }
      if (filter.deployment && template.capabilities.deployment !== filter.deployment) {
        return false;
      }
      if (filter.language && template.capabilities.language !== filter.language) {
        return false;
      }
      return true;
    });
  }
  /**
   * Check if a template exists
   */
  async templateExists(id) {
    try {
      await this.getTemplate(id);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Get template capabilities (for filtering/discovery)
   */
  async getCapabilities() {
    const templates = await this.discoverTemplates();
    const runtimes = /* @__PURE__ */ new Set();
    const transports = /* @__PURE__ */ new Set();
    const deployments = /* @__PURE__ */ new Set();
    const languages = /* @__PURE__ */ new Set();
    for (const template of templates) {
      runtimes.add(template.capabilities.runtime);
      for (const transport of template.capabilities.transport) {
        transports.add(transport);
      }
      deployments.add(template.capabilities.deployment);
      languages.add(template.capabilities.language);
    }
    return { runtimes, transports, deployments, languages };
  }
  /**
   * Clear templates cache
   */
  clearCache() {
    this.templatesCache.clear();
  }
};
var TemplateProcessor = class {
  registry;
  constructor(registry) {
    this.registry = registry;
  }
  /**
   * Scaffold a project from a template
   */
  async scaffold(options) {
    try {
      const template = await this.registry.getTemplate(options.template);
      const variables = this.validateVariables(
        options.variables,
        template.config.scaffolding.variables
      );
      await mkdir(options.targetDir, { recursive: true });
      await this.runHook(template, "pre-scaffold", {
        template: template.config,
        targetDir: options.targetDir,
        variables,
        packageManager: options.packageManager
      });
      await this.copyTemplateFiles(template, options.targetDir, variables);
      await this.runHook(template, "post-scaffold", {
        template: template.config,
        targetDir: options.targetDir,
        variables,
        packageManager: options.packageManager
      });
      if (!options.noInstall && template.config.scaffolding.postScaffold?.install) {
        await this.installDependencies(
          options.targetDir,
          options.packageManager,
          template.config.scaffolding.postScaffold.installCommand
        );
        if (template.config.scaffolding.postScaffold?.postInstall) {
          await this.runPostInstallCommands(
            options.targetDir,
            template.config.scaffolding.postScaffold.postInstall
          );
        }
      }
      if (options.smokeTest && template.config.scaffolding.postScaffold?.smokeTest) {
        await this.runSmokeTest(
          options.targetDir,
          template.config.scaffolding.postScaffold.smokeTest
        );
      }
      await this.writeMetadata(options.targetDir, template, variables);
      return {
        success: true,
        template: template.config.id,
        path: options.targetDir
      };
    } catch (error) {
      return {
        success: false,
        template: options.template,
        path: options.targetDir,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Validate and merge variables with defaults
   */
  validateVariables(provided, definitions) {
    const variables = {};
    for (const def of definitions) {
      if (def.required && !provided[def.name]) {
        throw new Error(`Required variable missing: ${def.name}`);
      }
      const value = provided[def.name] || def.default || "";
      if (def.pattern && value) {
        const regex = new RegExp(def.pattern);
        if (!regex.test(value)) {
          throw new Error(`Variable ${def.name} does not match pattern: ${def.pattern}`);
        }
      }
      variables[def.name] = value;
    }
    for (const [key, value] of Object.entries(provided)) {
      if (!variables[key]) {
        variables[key] = value;
      }
    }
    return variables;
  }
  /**
   * Copy template files to target directory with variable substitution
   */
  async copyTemplateFiles(template, targetDir, variables) {
    await this.copyDirectoryRecursive(template.filesPath, targetDir, variables);
  }
  /**
   * Recursively copy directory with variable substitution
   */
  async copyDirectoryRecursive(sourceDir, targetDir, variables) {
    const entries = await readdir(sourceDir, { withFileTypes: true });
    for (const entry of entries) {
      const sourcePath = join(sourceDir, entry.name);
      let targetPath = join(targetDir, entry.name);
      if (entry.name.endsWith(".hbs")) {
        targetPath = join(targetDir, entry.name.slice(0, -4));
      }
      if (entry.isDirectory()) {
        await mkdir(targetPath, { recursive: true });
        await this.copyDirectoryRecursive(sourcePath, targetPath, variables);
      } else {
        await this.processFile(sourcePath, targetPath, variables);
      }
    }
  }
  /**
   * Process a single file (with or without Handlebars templating)
   */
  async processFile(sourcePath, targetPath, variables) {
    await mkdir(dirname(targetPath), { recursive: true });
    if (sourcePath.endsWith(".hbs")) {
      const templateContent = await readFile(sourcePath, "utf-8");
      const template = Handlebars.compile(templateContent);
      const processedContent = template(variables);
      await writeFile(targetPath, processedContent, "utf-8");
    } else {
      await copyFile(sourcePath, targetPath);
    }
  }
  /**
   * Run a template hook
   */
  async runHook(template, hookName, context) {
    if (!template.hooksPath) return;
    const hookPath = join(template.hooksPath, `${hookName}.js`);
    try {
      await stat(hookPath);
      const hook = await import(hookPath);
      if (typeof hook.default === "function") {
        await hook.default(context);
      }
    } catch (error) {
      const isNotFound = error instanceof Error && "code" in error && error.code === "ENOENT";
      if (!isNotFound) {
        console.warn(`\u26A0\uFE0F  Hook ${hookName} failed: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }
  /**
   * Install dependencies
   */
  async installDependencies(targetDir, packageManager, customCommand) {
    const { spawn } = await import('child_process');
    const command = customCommand || this.getInstallCommand(packageManager);
    return new Promise((resolve, reject) => {
      const [cmd, ...args] = command.split(" ");
      const proc = spawn(cmd, args, {
        cwd: targetDir,
        stdio: "inherit",
        shell: true
      });
      proc.on("close", (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`Install command failed with code ${code}`));
        }
      });
      proc.on("error", (error) => {
        reject(error);
      });
    });
  }
  /**
   * Run post-install commands
   */
  async runPostInstallCommands(targetDir, commands) {
    const { spawn } = await import('child_process');
    console.log(`
\u{1F4E6} Running ${commands.length} post-install command(s)...
`);
    for (const command of commands) {
      await new Promise((resolve, reject) => {
        const [cmd, ...args] = command.split(" ");
        const proc = spawn(cmd, args, {
          cwd: targetDir,
          stdio: "inherit",
          shell: true
        });
        proc.on("close", (code) => {
          if (code === 0) {
            resolve();
          } else {
            reject(new Error(`Post-install command "${command}" failed with code ${code}`));
          }
        });
        proc.on("error", (error) => {
          reject(error);
        });
      });
    }
  }
  /**
   * Get install command for package manager
   */
  getInstallCommand(packageManager) {
    switch (packageManager) {
      case "pnpm":
        return "pnpm install";
      case "yarn":
        return "yarn install";
      case "bun":
        return "bun install";
      case "npm":
      default:
        return "npm install";
    }
  }
  /**
   * Run smoke test
   */
  async runSmokeTest(targetDir, smokeTestCommand) {
    const { spawn } = await import('child_process');
    return new Promise((resolve, reject) => {
      const [cmd, ...args] = smokeTestCommand.split(" ");
      const proc = spawn(cmd, args, {
        cwd: targetDir,
        stdio: "inherit",
        shell: true
      });
      proc.on("close", (code) => {
        if (code === 0) {
          resolve();
        } else {
          console.warn(`Smoke test failed with code ${code} (continuing anyway)`);
          resolve();
        }
      });
      proc.on("error", (error) => {
        console.warn(`Smoke test error: ${error} (continuing anyway)`);
        resolve();
      });
    });
  }
  /**
   * Write scaffold metadata to .mcp-template.json
   */
  async writeMetadata(targetDir, template, variables) {
    const metadata = {
      id: template.config.id,
      version: template.config.version,
      name: template.config.name,
      mcp_sdk_version: template.config.dependencies.mcp_sdk,
      agents_version: template.config.dependencies.agents,
      scaffolded_at: (/* @__PURE__ */ new Date()).toISOString(),
      variables
    };
    const metadataPath = join(targetDir, ".mcp-template.json");
    await writeFile(metadataPath, JSON.stringify(metadata, null, "	"), "utf-8");
  }
};
var formatValidators = {
  email: (val) => z.string().email().safeParse(val).success,
  uri: (val) => {
    try {
      new URL(val);
      return true;
    } catch {
      return false;
    }
  },
  url: (val) => formatValidators.uri(val),
  uuid: (val) => /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(val),
  date: (val) => /^\d{4}-\d{2}-\d{2}$/.test(val),
  "date-time": (val) => !isNaN(Date.parse(val)),
  time: (val) => /^\d{2}:\d{2}:\d{2}/.test(val),
  ipv4: (val) => /^(\d{1,3}\.){3}\d{1,3}$/.test(val),
  ipv6: (val) => /^([0-9a-f]{1,4}:){7}[0-9a-f]{1,4}$/i.test(val),
  // Custom VA formats
  ssn: (val) => /^\d{3}-\d{2}-\d{4}$/.test(val),
  phone: (val) => /^\d{3}-\d{3}-\d{4}$/.test(val)
};
function jsonSchemaToZod(schema) {
  if (schema.$ref) {
    throw new Error(`Unresolved $ref: ${schema.$ref}. Schema should be dereferenced first.`);
  }
  if (schema.oneOf) {
    const schemas = schema.oneOf.map((s) => jsonSchemaToZod(s));
    return z.union(schemas);
  }
  if (schema.anyOf) {
    const schemas = schema.anyOf.map((s) => jsonSchemaToZod(s));
    return z.union(schemas);
  }
  if (schema.allOf) {
    const merged = schema.allOf.reduce((acc, curr) => {
      return {
        ...acc,
        ...curr,
        properties: { ...acc.properties || {}, ...curr.properties || {} },
        required: [...acc.required || [], ...curr.required || []]
      };
    }, {});
    return jsonSchemaToZod(merged);
  }
  let type = schema.type;
  if (!type && (schema.properties || schema.required)) {
    type = "object";
  }
  switch (type) {
    case "string":
      return createStringSchema(schema);
    case "number":
      return createNumberSchema(schema, false);
    case "integer":
      return createNumberSchema(schema, true);
    case "boolean":
      return z.boolean();
    case "null":
      return z.null();
    case "array":
      return createArraySchema(schema);
    case "object":
      return createObjectSchema(schema);
    default:
      return z.any();
  }
}
function createStringSchema(schema) {
  if (schema.enum) {
    return z.enum(schema.enum);
  }
  let zodSchema = z.string();
  if (schema.minLength !== void 0) {
    zodSchema = zodSchema.min(schema.minLength);
  }
  if (schema.maxLength !== void 0) {
    zodSchema = zodSchema.max(schema.maxLength);
  }
  if (schema.pattern) {
    const regex = new RegExp(schema.pattern);
    zodSchema = zodSchema.regex(regex, {
      message: `Does not match pattern: ${schema.pattern}`
    });
  }
  if (schema.format) {
    const format = schema.format;
    const validator = formatValidators[format];
    if (validator) {
      zodSchema = zodSchema.refine(validator, {
        message: `Invalid ${format} format`
      });
    } else if (format === "email") {
      zodSchema = zodSchema.email();
    } else if (format === "url" || format === "uri") {
      zodSchema = zodSchema.url();
    }
  }
  return zodSchema;
}
function createNumberSchema(schema, isInteger) {
  let zodSchema = z.number();
  if (isInteger) {
    zodSchema = zodSchema.int();
  }
  if (schema.enum) {
    return z.enum(schema.enum.map(String)).transform(Number);
  }
  if (schema.minimum !== void 0) {
    zodSchema = zodSchema.min(schema.minimum);
  }
  if (schema.maximum !== void 0) {
    zodSchema = zodSchema.max(schema.maximum);
  }
  if (schema.exclusiveMinimum !== void 0) {
    zodSchema = zodSchema.gt(schema.exclusiveMinimum);
  }
  if (schema.exclusiveMaximum !== void 0) {
    zodSchema = zodSchema.lt(schema.exclusiveMaximum);
  }
  if (schema.multipleOf !== void 0) {
    zodSchema = zodSchema.multipleOf(schema.multipleOf);
  }
  return zodSchema;
}
function createArraySchema(schema) {
  const items = schema.items || {};
  const itemSchema = jsonSchemaToZod(items);
  let zodSchema = z.array(itemSchema);
  if (schema.minItems !== void 0) {
    zodSchema = zodSchema.min(schema.minItems);
  }
  if (schema.maxItems !== void 0) {
    zodSchema = zodSchema.max(schema.maxItems);
  }
  return zodSchema;
}
function createObjectSchema(schema) {
  const properties = schema.properties || {};
  const required = schema.required || [];
  const additionalProperties = schema.additionalProperties;
  const shape = {};
  for (const key in properties) {
    const propSchema = jsonSchemaToZod(properties[key]);
    if (required.includes(key)) {
      shape[key] = propSchema;
    } else {
      shape[key] = propSchema.optional();
    }
  }
  let zodObject = z.object(shape);
  if (additionalProperties === false) {
    zodObject = zodObject.strict();
  } else {
    zodObject = zodObject.passthrough();
  }
  return zodObject;
}
function getZodErrorMessage(issue, schema) {
  const { code, path, message } = issue;
  switch (code) {
    case "invalid_type":
      return `Invalid type: expected ${issue.expected}`;
    case "invalid_string":
      if (issue.validation === "email") {
        return "Invalid email format";
      }
      if (issue.validation === "url") {
        return "Invalid URL format";
      }
      if (issue.validation === "regex") {
        return message || "Does not match required pattern";
      }
      return message;
    case "too_small":
      if (issue.type === "string") {
        return `Too short: minimum length is ${issue.minimum}`;
      }
      if (issue.type === "number") {
        return `Too small: minimum value is ${issue.minimum}`;
      }
      if (issue.type === "array") {
        return `Too few items: minimum is ${issue.minimum}`;
      }
      return message;
    case "too_big":
      if (issue.type === "string") {
        return `Too long: maximum length is ${issue.maximum}`;
      }
      if (issue.type === "number") {
        return `Too large: maximum value is ${issue.maximum}`;
      }
      if (issue.type === "array") {
        return `Too many items: maximum is ${issue.maximum}`;
      }
      return message;
    case "invalid_enum_value":
      return `Invalid value. Allowed values: ${issue.options.join(", ")}`;
    case "custom":
      return message || "Validation failed";
    default:
      return message || "Validation error";
  }
}

// src/utils/example-generator.ts
var ExampleGenerator = class {
  static MAX_DEPTH = 5;
  /**
   * Generate example payload from JSON schema
   */
  static generate(schema, options) {
    const depth = options?.depth || 0;
    if (depth > this.MAX_DEPTH) {
      return null;
    }
    if (!schema || typeof schema !== "object") {
      return null;
    }
    if (schema.$ref) {
      return `<reference: ${schema.$ref}>`;
    }
    if (schema.example !== void 0) {
      return schema.example;
    }
    if (schema.default !== void 0) {
      return schema.default;
    }
    switch (schema.type) {
      case "object":
        return this.generateObject(schema, { ...options, depth });
      case "array":
        return this.generateArray(schema, { ...options, depth });
      case "string":
        return this.generateString(schema);
      case "number":
      case "integer":
        return this.generateNumber(schema);
      case "boolean":
        return this.generateBoolean(schema);
      case "null":
        return null;
      default:
        if (schema.oneOf && Array.isArray(schema.oneOf) && schema.oneOf.length > 0) {
          return this.generate(schema.oneOf[0], { ...options, depth: depth + 1 });
        }
        if (schema.anyOf && Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {
          return this.generate(schema.anyOf[0], { ...options, depth: depth + 1 });
        }
        if (schema.allOf && Array.isArray(schema.allOf)) {
          const merged = { type: "object", properties: {} };
          for (const subSchema of schema.allOf) {
            if (subSchema.properties) {
              Object.assign(merged.properties, subSchema.properties);
            }
            if (subSchema.required) {
              merged.required = [...merged.required || [], ...subSchema.required];
            }
          }
          return this.generate(merged, { ...options, depth: depth + 1 });
        }
        return null;
    }
  }
  /**
   * Generate example object
   */
  static generateObject(schema, options) {
    const obj = {};
    const properties = schema.properties || {};
    const required = schema.required || [];
    const depth = options?.depth || 0;
    for (const prop in properties) {
      if (options?.requiredOnly && !required.includes(prop)) {
        continue;
      }
      const safeProp = this.sanitizePropertyName(prop);
      if (!safeProp) {
        continue;
      }
      const value = this.generate(properties[prop], { ...options, depth: depth + 1 });
      if (value !== void 0) {
        obj[safeProp] = value;
      }
    }
    return obj;
  }
  /**
   * Sanitize property name to ensure it's valid for JSON
   */
  static sanitizePropertyName(prop) {
    if (!prop || typeof prop !== "string") {
      return null;
    }
    const sanitized = prop.replace(/[^a-zA-Z0-9_$-]/g, "_");
    return sanitized.length > 0 ? sanitized : null;
  }
  /**
   * Generate example array
   */
  static generateArray(schema, options) {
    if (!schema.items) {
      return [];
    }
    const depth = options?.depth || 0;
    const minItems = schema.minItems || 1;
    const itemCount = Math.min(minItems, 10);
    const items = [];
    for (let i = 0; i < itemCount; i++) {
      const item = this.generate(schema.items, { ...options, depth: depth + 1 });
      if (item !== void 0) {
        items.push(item);
      }
    }
    return items;
  }
  /**
   * Generate example string
   */
  static generateString(schema) {
    if (schema.enum && schema.enum.length > 0) {
      return schema.enum[0];
    }
    if (schema.format) {
      return this.generateFormattedString(schema.format);
    }
    if (schema.pattern) {
      return this.generatePatternString(schema.pattern);
    }
    return "string";
  }
  /**
   * Generate formatted string
   */
  static generateFormattedString(format) {
    switch (format) {
      case "email":
        return "user@example.com";
      case "date":
        return "2024-01-15";
      case "date-time":
        return "2024-01-15T10:30:00Z";
      case "uri":
      case "url":
        return "https://example.com";
      case "uuid":
        return "123e4567-e89b-12d3-a456-426614174000";
      case "ipv4":
        return "192.168.1.1";
      case "ipv6":
        return "2001:0db8:85a3:0000:0000:8a2e:0370:7334";
      case "ssn":
        return "123-45-6789";
      case "phone":
        return "555-123-4567";
      default:
        return "string";
    }
  }
  /**
   * Generate string matching a pattern
   */
  static generatePatternString(pattern) {
    if (pattern.includes("\\d{3}-\\d{2}-\\d{4}")) {
      return "123-45-6789";
    }
    if (pattern.includes("\\d{3}-\\d{3}-\\d{4}")) {
      return "555-123-4567";
    }
    if (pattern.includes("^[A-Z]{2}\\d{6}$")) {
      return "AB123456";
    }
    return "string";
  }
  /**
   * Generate example number
   */
  static generateNumber(schema) {
    if (schema.enum && schema.enum.length > 0) {
      return schema.enum[0];
    }
    if (schema.minimum !== void 0) {
      return schema.minimum;
    }
    if (schema.maximum !== void 0) {
      return schema.maximum;
    }
    return schema.type === "integer" ? 0 : 0;
  }
  /**
   * Generate example boolean
   */
  static generateBoolean(schema) {
    return true;
  }
};

// src/utils/error-formatter.ts
var ErrorFormatter = class {
  /**
   * Format validation errors into a readable text summary
   */
  static formatErrors(errors) {
    if (errors.length === 0) {
      return "No errors";
    }
    const lines = [`Found ${errors.length} validation error${errors.length === 1 ? "" : "s"}:
`];
    for (let i = 0; i < errors.length; i++) {
      const error = errors[i];
      lines.push(`${i + 1}. Field: ${error.field}`);
      lines.push(`   Error: ${error.message}`);
      if (error.expected) {
        lines.push(`   Expected: ${JSON.stringify(error.expected)}`);
      }
      if (error.received) {
        lines.push(`   Received: ${JSON.stringify(error.received)}`);
      }
      if (error.fixSuggestion) {
        lines.push(`   Fix: ${error.fixSuggestion}`);
      }
      lines.push("");
    }
    return lines.join("\n");
  }
  /**
   * Format validation warnings into a readable text summary
   */
  static formatWarnings(warnings) {
    if (warnings.length === 0) {
      return "";
    }
    const lines = [`
Found ${warnings.length} warning${warnings.length === 1 ? "" : "s"}:
`];
    for (let i = 0; i < warnings.length; i++) {
      const warning = warnings[i];
      lines.push(`${i + 1}. Field: ${warning.field}`);
      lines.push(`   Warning: ${warning.message}`);
      if (warning.suggestion) {
        lines.push(`   Suggestion: ${warning.suggestion}`);
      }
      lines.push("");
    }
    return lines.join("\n");
  }
  /**
   * Format complete validation result
   */
  static formatValidationResult(result) {
    if (result.valid) {
      let output = "\u2713 Payload is valid";
      if (result.warnings && result.warnings.length > 0) {
        output += "\n\n" + this.formatWarnings(result.warnings);
      }
      return output;
    }
    return "\u2717 Payload validation failed\n\n" + this.formatErrors(result.errors);
  }
};

// src/services/cache.ts
var LRUCache = class {
  cache;
  maxSize;
  ttlMs;
  constructor(maxSize = 50, ttlMinutes = 60) {
    this.cache = /* @__PURE__ */ new Map();
    this.maxSize = maxSize;
    this.ttlMs = ttlMinutes * 60 * 1e3;
  }
  get(key) {
    const entry = this.cache.get(key);
    if (!entry) {
      return null;
    }
    if (Date.now() - entry.timestamp > this.ttlMs) {
      this.cache.delete(key);
      return null;
    }
    this.cache.delete(key);
    this.cache.set(key, entry);
    return entry.value;
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== void 0) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, {
      value,
      timestamp: Date.now()
    });
  }
  has(key) {
    const entry = this.cache.get(key);
    if (!entry) {
      return false;
    }
    if (Date.now() - entry.timestamp > this.ttlMs) {
      this.cache.delete(key);
      return false;
    }
    return true;
  }
  delete(key) {
    this.cache.delete(key);
  }
  clear() {
    this.cache.clear();
  }
  size() {
    return this.cache.size;
  }
  keys() {
    return Array.from(this.cache.keys());
  }
  // Clean up expired entries
  cleanup() {
    const now = Date.now();
    let cleaned = 0;
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.ttlMs) {
        this.cache.delete(key);
        cleaned++;
      }
    }
    return cleaned;
  }
};

// src/index.ts
var VERSION = "1.0.0";
var NAME = "mcp-server-kit";

export { AssertionSchema, ErrorFormatter, ExampleGenerator, LRUCache, NAME, ScaffoldOptionsSchema, TemplateConfigSchema, TemplateFilterSchema, TemplateProcessor, TemplateRegistry, TestRunner, TestSpecSchema, TestSuiteSpecSchema, VERSION, formatAsJSON, formatSimpleSummary, getZodErrorMessage, jsonSchemaToZod, loadTestSpec, loadTestSuiteSpec, parseTestSpec, printConsole, printJSON, printSimple, runAssertions, serializeTestSpecToJSON, serializeTestSpecToYAML, validateScaffoldOptions, validateTemplateConfig };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map