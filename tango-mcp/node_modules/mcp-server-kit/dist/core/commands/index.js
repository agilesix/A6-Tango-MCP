import { Command } from 'commander';
import fs, { readdir, access, readFile, mkdir, writeFile, copyFile, stat, cp, rm } from 'fs/promises';
import * as path2 from 'path';
import path2__default, { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { z } from 'zod';
import Handlebars from 'handlebars';
import { existsSync, statSync, readFileSync } from 'fs';
import stripJsonComments from 'strip-json-comments';
import TOML from '@iarna/toml';
import { exec } from 'child_process';
import { promisify } from 'util';
import yaml from 'yaml';

// src/core/commands/new-server.ts
var TemplateVariableSchema = z.object({
  name: z.string().min(1).regex(/^[A-Z][A-Z0-9_]*$/, "Variable name must be uppercase with underscores"),
  required: z.boolean(),
  default: z.string().optional(),
  prompt: z.string().optional(),
  pattern: z.string().optional()
});
var PostScaffoldConfigSchema = z.object({
  install: z.boolean(),
  installCommand: z.string().optional(),
  postInstall: z.array(z.string()).optional(),
  smokeTest: z.string().optional()
});
var TemplateCapabilitiesSchema = z.object({
  runtime: z.string().min(1),
  transport: z.array(z.string().min(1)).min(1),
  deployment: z.enum(["remote", "local"]),
  language: z.enum(["typescript", "javascript"])
});
var TemplateDependenciesSchema = z.object({
  mcp_sdk: z.string().optional(),
  agents: z.string().optional(),
  runtime_specific: z.record(z.string()).optional()
});
var TemplateCLICommandsSchema = z.object({
  dev: z.string().min(1),
  test: z.string().min(1),
  deploy: z.string().optional(),
  typeCheck: z.string().optional()
});
var TemplateFeaturesSchema = z.object({
  unitTesting: z.boolean(),
  integrationTesting: z.boolean(),
  exampleTools: z.array(z.string()),
  documentation: z.boolean()
});
var TemplateCompatibilitySchema = z.object({
  node: z.string().optional(),
  npm: z.string().optional(),
  pnpm: z.string().optional(),
  yarn: z.string().optional()
});
var TemplateConfigSchema = z.object({
  id: z.string().min(1).regex(/^[a-z0-9-]+$/, "Template ID must be lowercase with hyphens"),
  version: z.string().regex(/^\d+\.\d+\.\d+$/, "Version must be semver (e.g., 1.0.0)"),
  name: z.string().min(1),
  description: z.string().min(1),
  capabilities: TemplateCapabilitiesSchema,
  dependencies: TemplateDependenciesSchema,
  scaffolding: z.object({
    variables: z.array(TemplateVariableSchema),
    postScaffold: PostScaffoldConfigSchema.optional()
  }),
  cli: TemplateCLICommandsSchema,
  features: TemplateFeaturesSchema,
  compatibility: TemplateCompatibilitySchema
});
z.object({
  id: z.string(),
  version: z.string(),
  name: z.string(),
  mcp_sdk_version: z.string().optional(),
  agents_version: z.string().optional(),
  scaffolded_at: z.string(),
  variables: z.record(z.string())
});
z.object({
  template: z.string().min(1),
  targetDir: z.string().min(1),
  variables: z.record(z.string()),
  noInstall: z.boolean().optional(),
  packageManager: z.enum(["npm", "pnpm", "yarn", "bun"]).optional(),
  smokeTest: z.boolean().optional()
});
z.object({
  runtime: z.string().optional(),
  transport: z.string().optional(),
  deployment: z.enum(["remote", "local"]).optional(),
  language: z.enum(["typescript", "javascript"]).optional()
});
function validateTemplateConfig(config) {
  const result = TemplateConfigSchema.safeParse(config);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return { success: false, errors: result.error };
}

// src/core/template-system/registry.ts
function getTemplatesDir() {
  const __filename2 = fileURLToPath(import.meta.url);
  const __dirname2 = dirname(__filename2);
  if (__dirname2.includes("/src/")) {
    return join(__dirname2, "../../../templates");
  } else {
    return join(__dirname2, "../templates");
  }
}
var TemplateRegistry = class {
  templatesDir;
  templatesCache = /* @__PURE__ */ new Map();
  constructor(templatesDir) {
    this.templatesDir = templatesDir || getTemplatesDir();
  }
  /**
   * Discover all templates in the templates directory
   */
  async discoverTemplates() {
    try {
      const entries = await readdir(this.templatesDir, { withFileTypes: true });
      const templates = [];
      for (const entry of entries) {
        if (!entry.isDirectory()) continue;
        const templatePath = join(this.templatesDir, entry.name);
        const configPath = join(templatePath, "template.config.json");
        try {
          await access(configPath);
        } catch {
          continue;
        }
        try {
          const configContent = await readFile(configPath, "utf-8");
          const config = JSON.parse(configContent);
          const validation = validateTemplateConfig(config);
          if (validation.success && validation.data) {
            templates.push(validation.data);
            this.templatesCache.set(validation.data.id, {
              config: validation.data,
              path: templatePath,
              filesPath: join(templatePath, "files"),
              hooksPath: join(templatePath, "hooks")
            });
          } else {
            console.warn(
              `Skipping template ${entry.name}: Invalid config format`
            );
          }
        } catch (error) {
          console.warn(
            `Skipping template ${entry.name}: ${error instanceof Error ? error.message : String(error)}`
          );
          continue;
        }
      }
      return templates;
    } catch (error) {
      throw new Error(`Failed to discover templates: ${error}`);
    }
  }
  /**
   * Get a specific template by ID
   */
  async getTemplate(id) {
    if (this.templatesCache.has(id)) {
      return this.templatesCache.get(id);
    }
    await this.discoverTemplates();
    if (this.templatesCache.has(id)) {
      return this.templatesCache.get(id);
    }
    throw new Error(`Template not found: ${id}`);
  }
  /**
   * Validate a specific template
   */
  async validateTemplate(id) {
    const errors = [];
    const warnings = [];
    try {
      const template = await this.getTemplate(id);
      try {
        await access(template.filesPath);
      } catch {
        errors.push(`Files directory not found: ${template.filesPath}`);
      }
      const requiredFiles = ["package.json.hbs", "tsconfig.json", "README.md.hbs"];
      for (const file of requiredFiles) {
        try {
          await access(join(template.filesPath, file));
        } catch {
          warnings.push(`Recommended file missing: ${file}`);
        }
      }
      for (const variable of template.config.scaffolding.variables) {
        if (variable.required && variable.default) {
          warnings.push(`Variable ${variable.name} is required but has a default value`);
        }
      }
      if (template.config.capabilities.transport.length === 0) {
        errors.push("Template must support at least one transport");
      }
      return {
        valid: errors.length === 0,
        errors,
        warnings
      };
    } catch (error) {
      return {
        valid: false,
        errors: [`Failed to validate template: ${error}`],
        warnings: []
      };
    }
  }
  /**
   * List all templates with optional filtering
   */
  async listTemplates(filter) {
    const templates = await this.discoverTemplates();
    if (!filter) {
      return templates;
    }
    return templates.filter((template) => {
      if (filter.runtime && template.capabilities.runtime !== filter.runtime) {
        return false;
      }
      if (filter.transport && !template.capabilities.transport.includes(filter.transport)) {
        return false;
      }
      if (filter.deployment && template.capabilities.deployment !== filter.deployment) {
        return false;
      }
      if (filter.language && template.capabilities.language !== filter.language) {
        return false;
      }
      return true;
    });
  }
  /**
   * Check if a template exists
   */
  async templateExists(id) {
    try {
      await this.getTemplate(id);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Get template capabilities (for filtering/discovery)
   */
  async getCapabilities() {
    const templates = await this.discoverTemplates();
    const runtimes = /* @__PURE__ */ new Set();
    const transports = /* @__PURE__ */ new Set();
    const deployments = /* @__PURE__ */ new Set();
    const languages = /* @__PURE__ */ new Set();
    for (const template of templates) {
      runtimes.add(template.capabilities.runtime);
      for (const transport of template.capabilities.transport) {
        transports.add(transport);
      }
      deployments.add(template.capabilities.deployment);
      languages.add(template.capabilities.language);
    }
    return { runtimes, transports, deployments, languages };
  }
  /**
   * Clear templates cache
   */
  clearCache() {
    this.templatesCache.clear();
  }
};
var TemplateProcessor = class {
  registry;
  constructor(registry) {
    this.registry = registry;
  }
  /**
   * Scaffold a project from a template
   */
  async scaffold(options) {
    try {
      const template = await this.registry.getTemplate(options.template);
      const variables = this.validateVariables(
        options.variables,
        template.config.scaffolding.variables
      );
      await mkdir(options.targetDir, { recursive: true });
      await this.runHook(template, "pre-scaffold", {
        template: template.config,
        targetDir: options.targetDir,
        variables,
        packageManager: options.packageManager
      });
      await this.copyTemplateFiles(template, options.targetDir, variables);
      await this.runHook(template, "post-scaffold", {
        template: template.config,
        targetDir: options.targetDir,
        variables,
        packageManager: options.packageManager
      });
      if (!options.noInstall && template.config.scaffolding.postScaffold?.install) {
        await this.installDependencies(
          options.targetDir,
          options.packageManager,
          template.config.scaffolding.postScaffold.installCommand
        );
        if (template.config.scaffolding.postScaffold?.postInstall) {
          await this.runPostInstallCommands(
            options.targetDir,
            template.config.scaffolding.postScaffold.postInstall
          );
        }
      }
      if (options.smokeTest && template.config.scaffolding.postScaffold?.smokeTest) {
        await this.runSmokeTest(
          options.targetDir,
          template.config.scaffolding.postScaffold.smokeTest
        );
      }
      await this.writeMetadata(options.targetDir, template, variables);
      return {
        success: true,
        template: template.config.id,
        path: options.targetDir
      };
    } catch (error) {
      return {
        success: false,
        template: options.template,
        path: options.targetDir,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Validate and merge variables with defaults
   */
  validateVariables(provided, definitions) {
    const variables = {};
    for (const def of definitions) {
      if (def.required && !provided[def.name]) {
        throw new Error(`Required variable missing: ${def.name}`);
      }
      const value = provided[def.name] || def.default || "";
      if (def.pattern && value) {
        const regex = new RegExp(def.pattern);
        if (!regex.test(value)) {
          throw new Error(`Variable ${def.name} does not match pattern: ${def.pattern}`);
        }
      }
      variables[def.name] = value;
    }
    for (const [key, value] of Object.entries(provided)) {
      if (!variables[key]) {
        variables[key] = value;
      }
    }
    return variables;
  }
  /**
   * Copy template files to target directory with variable substitution
   */
  async copyTemplateFiles(template, targetDir, variables) {
    await this.copyDirectoryRecursive(template.filesPath, targetDir, variables);
  }
  /**
   * Recursively copy directory with variable substitution
   */
  async copyDirectoryRecursive(sourceDir, targetDir, variables) {
    const entries = await readdir(sourceDir, { withFileTypes: true });
    for (const entry of entries) {
      const sourcePath = join(sourceDir, entry.name);
      let targetPath = join(targetDir, entry.name);
      if (entry.name.endsWith(".hbs")) {
        targetPath = join(targetDir, entry.name.slice(0, -4));
      }
      if (entry.isDirectory()) {
        await mkdir(targetPath, { recursive: true });
        await this.copyDirectoryRecursive(sourcePath, targetPath, variables);
      } else {
        await this.processFile(sourcePath, targetPath, variables);
      }
    }
  }
  /**
   * Process a single file (with or without Handlebars templating)
   */
  async processFile(sourcePath, targetPath, variables) {
    await mkdir(dirname(targetPath), { recursive: true });
    if (sourcePath.endsWith(".hbs")) {
      const templateContent = await readFile(sourcePath, "utf-8");
      const template = Handlebars.compile(templateContent);
      const processedContent = template(variables);
      await writeFile(targetPath, processedContent, "utf-8");
    } else {
      await copyFile(sourcePath, targetPath);
    }
  }
  /**
   * Run a template hook
   */
  async runHook(template, hookName, context) {
    if (!template.hooksPath) return;
    const hookPath = join(template.hooksPath, `${hookName}.js`);
    try {
      await stat(hookPath);
      const hook = await import(hookPath);
      if (typeof hook.default === "function") {
        await hook.default(context);
      }
    } catch (error) {
      const isNotFound = error instanceof Error && "code" in error && error.code === "ENOENT";
      if (!isNotFound) {
        console.warn(`\u26A0\uFE0F  Hook ${hookName} failed: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }
  /**
   * Install dependencies
   */
  async installDependencies(targetDir, packageManager, customCommand) {
    const { spawn } = await import('child_process');
    const command = customCommand || this.getInstallCommand(packageManager);
    return new Promise((resolve2, reject) => {
      const [cmd, ...args] = command.split(" ");
      const proc = spawn(cmd, args, {
        cwd: targetDir,
        stdio: "inherit",
        shell: true
      });
      proc.on("close", (code) => {
        if (code === 0) {
          resolve2();
        } else {
          reject(new Error(`Install command failed with code ${code}`));
        }
      });
      proc.on("error", (error) => {
        reject(error);
      });
    });
  }
  /**
   * Run post-install commands
   */
  async runPostInstallCommands(targetDir, commands) {
    const { spawn } = await import('child_process');
    console.log(`
\u{1F4E6} Running ${commands.length} post-install command(s)...
`);
    for (const command of commands) {
      await new Promise((resolve2, reject) => {
        const [cmd, ...args] = command.split(" ");
        const proc = spawn(cmd, args, {
          cwd: targetDir,
          stdio: "inherit",
          shell: true
        });
        proc.on("close", (code) => {
          if (code === 0) {
            resolve2();
          } else {
            reject(new Error(`Post-install command "${command}" failed with code ${code}`));
          }
        });
        proc.on("error", (error) => {
          reject(error);
        });
      });
    }
  }
  /**
   * Get install command for package manager
   */
  getInstallCommand(packageManager) {
    switch (packageManager) {
      case "pnpm":
        return "pnpm install";
      case "yarn":
        return "yarn install";
      case "bun":
        return "bun install";
      case "npm":
      default:
        return "npm install";
    }
  }
  /**
   * Run smoke test
   */
  async runSmokeTest(targetDir, smokeTestCommand) {
    const { spawn } = await import('child_process');
    return new Promise((resolve2, reject) => {
      const [cmd, ...args] = smokeTestCommand.split(" ");
      const proc = spawn(cmd, args, {
        cwd: targetDir,
        stdio: "inherit",
        shell: true
      });
      proc.on("close", (code) => {
        if (code === 0) {
          resolve2();
        } else {
          console.warn(`Smoke test failed with code ${code} (continuing anyway)`);
          resolve2();
        }
      });
      proc.on("error", (error) => {
        console.warn(`Smoke test error: ${error} (continuing anyway)`);
        resolve2();
      });
    });
  }
  /**
   * Write scaffold metadata to .mcp-template.json
   */
  async writeMetadata(targetDir, template, variables) {
    const metadata = {
      id: template.config.id,
      version: template.config.version,
      name: template.config.name,
      mcp_sdk_version: template.config.dependencies.mcp_sdk,
      agents_version: template.config.dependencies.agents,
      scaffolded_at: (/* @__PURE__ */ new Date()).toISOString(),
      variables
    };
    const metadataPath = join(targetDir, ".mcp-template.json");
    await writeFile(metadataPath, JSON.stringify(metadata, null, "	"), "utf-8");
  }
};

// src/core/commands/shared/json-output.ts
function outputResult(result, jsonMode, fallbackFormatter) {
  if (jsonMode) {
    console.log(JSON.stringify(result, null, 2));
  } else if (fallbackFormatter) {
    fallbackFormatter(result);
  }
}

// src/services/progress-reporter.ts
var ProgressReporter = class {
  constructor(jsonMode = false) {
    this.jsonMode = jsonMode;
  }
  steps = /* @__PURE__ */ new Map();
  startTime = 0;
  /**
   * Start progress tracking with a list of steps
   */
  start(stepDescriptions) {
    this.startTime = Date.now();
    this.steps.clear();
    stepDescriptions.forEach((description, index) => {
      const id = `step-${index + 1}`;
      this.steps.set(id, {
        id,
        description,
        status: "pending"
      });
    });
    this.emitEvent({
      type: "start",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      totalSteps: this.steps.size,
      completedSteps: 0
    });
    if (!this.jsonMode) {
      console.log("\n\u{1F4CB} Starting operation...\n");
    }
  }
  /**
   * Update the status of a specific step
   */
  updateStep(stepId, status, error) {
    const step = this.steps.get(stepId);
    if (!step) {
      throw new Error(`Unknown step: ${stepId}`);
    }
    step.status = status;
    if (error) {
      step.error = error;
    }
    this.emitEvent({
      type: "step_update",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      step: { ...step },
      totalSteps: this.steps.size,
      completedSteps: this.getCompletedCount()
    });
    if (!this.jsonMode) {
      this.renderTextStep(step);
    }
  }
  /**
   * Mark operation as complete
   */
  complete() {
    const duration = Date.now() - this.startTime;
    this.emitEvent({
      type: "complete",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      totalSteps: this.steps.size,
      completedSteps: this.getCompletedCount()
    });
    if (!this.jsonMode) {
      const failed = Array.from(this.steps.values()).filter(
        (s) => s.status === "failed"
      );
      if (failed.length === 0) {
        console.log(`
\u2705 Operation completed in ${duration}ms
`);
      } else {
        console.log(
          `
\u26A0\uFE0F  Operation completed with ${failed.length} failed step(s) in ${duration}ms
`
        );
      }
    }
  }
  /**
   * Get current progress summary
   */
  getProgress() {
    const steps = Array.from(this.steps.values());
    return {
      total: steps.length,
      completed: steps.filter((s) => s.status === "completed").length,
      failed: steps.filter((s) => s.status === "failed").length,
      inProgress: steps.filter((s) => s.status === "in_progress").length
    };
  }
  /**
   * Get all steps
   */
  getSteps() {
    return Array.from(this.steps.values());
  }
  /**
   * Emit a progress event (NDJSON in JSON mode)
   */
  emitEvent(event) {
    if (this.jsonMode) {
      console.log(JSON.stringify(event));
    }
  }
  /**
   * Render a step in text mode
   */
  renderTextStep(step) {
    let icon;
    let color;
    switch (step.status) {
      case "pending":
        icon = "\u23F8\uFE0F";
        color = "\x1B[90m";
        break;
      case "in_progress":
        icon = "\u23F3";
        color = "\x1B[36m";
        break;
      case "completed":
        icon = "\u2705";
        color = "\x1B[32m";
        break;
      case "failed":
        icon = "\u274C";
        color = "\x1B[31m";
        break;
    }
    const reset = "\x1B[0m";
    console.log(`${color}${icon} ${step.description}${reset}`);
    if (step.error) {
      console.log(`   ${color}\u21B3 ${step.error}${reset}`);
    }
  }
  /**
   * Get count of completed steps
   */
  getCompletedCount() {
    return Array.from(this.steps.values()).filter(
      (s) => s.status === "completed"
    ).length;
  }
};
function createNewServerCommand() {
  const command = new Command("server").description("Scaffold a new MCP server project").showHelpAfterError("\n\u{1F4A1} Tip: Run with --help to see all available options").requiredOption("--name <name>", "Project name (lowercase with hyphens)").option("--template <id>", "Template ID to use", "cloudflare-remote").option("--description <desc>", "Project description").option("--port <port>", "Development server port", "8788").option("--output <path>", "Output directory (defaults to current directory). Tip: Use $(git rev-parse --show-toplevel) for git root").option("--no-install", "Skip dependency installation").option("--pm <manager>", "Package manager (npm, pnpm, yarn, bun)", "npm").option("--dev", "Development mode: use local mcp-server-kit paths instead of published package").option("--json", "Output result as JSON").action(async (options) => {
    let progress;
    try {
      progress = new ProgressReporter(!!options.json);
      const steps = [
        "Validating configuration",
        "Loading template",
        "Creating project structure"
      ];
      if (options.install) {
        steps.push("Installing dependencies");
        steps.push("Running post-install commands");
      }
      steps.push("Finalizing project");
      progress.start(steps);
      progress.updateStep("step-1", "in_progress");
      const validPMs = ["npm", "pnpm", "yarn", "bun"];
      if (!validPMs.includes(options.pm)) {
        const errorMessage = `Invalid package manager '${options.pm}'. Valid options: ${validPMs.join(", ")}`;
        progress.updateStep("step-1", "failed", errorMessage);
        progress.complete();
        if (options.json) {
          const result = {
            success: false,
            projectName: options.name,
            templateId: options.template,
            path: "",
            nextSteps: [],
            error: errorMessage
          };
          console.log(JSON.stringify(result, null, 2));
        } else {
          console.error(`\u274C Error: ${errorMessage}`);
        }
        process.exit(1);
      }
      const registry = new TemplateRegistry();
      const processor = new TemplateProcessor(registry);
      progress.updateStep("step-1", "completed");
      progress.updateStep("step-2", "in_progress");
      const templateExists = await registry.templateExists(options.template);
      if (!templateExists) {
        const templates = await registry.listTemplates();
        const availableTemplates = templates.map((t) => `${t.id}: ${t.name}`).join(", ");
        const errorMessage = `Template '${options.template}' not found. Available: ${availableTemplates}`;
        progress.updateStep("step-2", "failed", errorMessage);
        progress.complete();
        if (options.json) {
          const result = {
            success: false,
            projectName: options.name,
            templateId: options.template,
            path: "",
            nextSteps: [],
            error: errorMessage
          };
          console.log(JSON.stringify(result, null, 2));
        } else {
          console.error(`\u274C Error: Template '${options.template}' not found`);
          console.error("\nAvailable templates:");
          for (const t of templates) {
            console.error(`  - ${t.id}: ${t.name}`);
          }
        }
        process.exit(1);
      }
      const variables = {
        PROJECT_NAME: options.name,
        MCP_SERVER_NAME: options.description || options.name,
        PORT: options.port
      };
      if (options.description) {
        variables.DESCRIPTION = options.description;
      }
      if (options.dev) {
        const __filename2 = fileURLToPath(import.meta.url);
        const __dirname2 = path2.dirname(__filename2);
        const mcpKitRoot = path2.resolve(__dirname2, "../");
        variables.DEV_MODE = "true";
        variables.MCP_KIT_PATH = mcpKitRoot;
        if (!options.json) {
          console.log(
            `\u{1F4E6} Development mode: Using local mcp-server-kit at ${mcpKitRoot}
`
          );
        }
      }
      const targetDir = options.output ? path2.join(options.output, options.name) : `./${options.name}`;
      progress.updateStep("step-2", "completed");
      progress.updateStep("step-3", "in_progress");
      const scaffoldResult = await processor.scaffold({
        template: options.template,
        targetDir,
        variables,
        noInstall: !options.install,
        packageManager: options.pm
      });
      progress.updateStep("step-3", "completed");
      if (options.install) {
        progress.updateStep("step-4", "completed");
        progress.updateStep("step-5", "completed");
        progress.updateStep("step-6", "in_progress");
      } else {
        progress.updateStep("step-4", "in_progress");
      }
      if (scaffoldResult.success) {
        const finalStepId = options.install ? "step-6" : "step-4";
        progress.updateStep(finalStepId, "completed");
        progress.complete();
        const nextSteps = [];
        nextSteps.push(`cd ${targetDir}`);
        if (!options.install) {
          nextSteps.push(`${options.pm} install`);
        }
        nextSteps.push(`${options.pm} run dev`);
        const result = {
          success: true,
          projectName: options.name,
          templateId: options.template,
          path: path2.resolve(targetDir),
          nextSteps,
          devMode: options.dev
        };
        outputResult(result, !!options.json, (r) => {
          console.log(`
\u{1F680} Creating MCP server: ${options.name}
`);
          console.log(`
\u2705 Successfully created ${options.name}!
`);
          if (options.dev) {
            console.log(
              "\u{1F4E6} Development mode enabled - using local mcp-server-kit\n"
            );
          }
          console.log("Next steps:");
          for (const step of r.nextSteps) {
            console.log(`  ${step}`);
          }
          console.log("\nHappy coding! \u{1F389}\n");
        });
      } else {
        const currentStepId = "step-3";
        progress.updateStep(currentStepId, "failed", scaffoldResult.error);
        progress.complete();
        const result = {
          success: false,
          projectName: options.name,
          templateId: options.template,
          path: targetDir,
          nextSteps: [],
          error: scaffoldResult.error
        };
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
        } else {
          console.error(`
\u274C Error: ${scaffoldResult.error}
`);
        }
        process.exit(1);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (options.json) {
        const result = {
          success: false,
          projectName: options.name,
          templateId: options.template,
          path: "",
          nextSteps: [],
          error: errorMessage
        };
        console.log(JSON.stringify(result, null, 2));
      } else {
        console.error(`
\u274C Error: ${errorMessage}
`);
      }
      process.exit(1);
    }
  });
  return command;
}
function createNewCommand() {
  const newCmd = new Command("new").description("Create a new MCP server or component");
  newCmd.addCommand(createNewServerCommand());
  return newCmd;
}
function createListCommand() {
  return new Command("list").description("List available templates").option("--json", "Output as JSON").option("--runtime <runtime>", "Filter by runtime").option("--transport <transport>", "Filter by transport").option("--deployment <deployment>", "Filter by deployment (remote/local)").option("--language <language>", "Filter by language (typescript/javascript)").action(async (options) => {
    try {
      const registry = new TemplateRegistry();
      const filter = {};
      if (options.runtime) filter.runtime = options.runtime;
      if (options.transport) filter.transport = options.transport;
      if (options.deployment) filter.deployment = options.deployment;
      if (options.language) filter.language = options.language;
      const templates = await registry.listTemplates(filter);
      if (options.json) {
        console.log(JSON.stringify(templates, null, 2));
      } else {
        if (templates.length === 0) {
          console.log("No templates found matching the filter criteria.\n");
          return;
        }
        console.log(`
Available Templates (${templates.length}):
`);
        for (const template of templates) {
          console.log(`  ${template.id}`);
          console.log(`    Name: ${template.name}`);
          console.log(`    Description: ${template.description}`);
          console.log(`    Runtime: ${template.capabilities.runtime}`);
          console.log(`    Transport: ${template.capabilities.transport.join(", ")}`);
          console.log(`    Deployment: ${template.capabilities.deployment}`);
          console.log(`    Language: ${template.capabilities.language}`);
          console.log();
        }
      }
    } catch (error) {
      console.error(`Error: ${error instanceof Error ? error.message : String(error)}`);
      process.exit(1);
    }
  });
}
function createInfoCommand() {
  return new Command("info").description("Show detailed information about a template").argument("<template-id>", "Template ID").option("--json", "Output as JSON").action(async (templateId, options) => {
    try {
      const registry = new TemplateRegistry();
      const template = await registry.getTemplate(templateId);
      if (options.json) {
        console.log(JSON.stringify(template.config, null, 2));
      } else {
        console.log(`
Template: ${template.config.name}
`);
        console.log(`ID: ${template.config.id}`);
        console.log(`Version: ${template.config.version}`);
        console.log(`Description: ${template.config.description}`);
        console.log();
        console.log("Capabilities:");
        console.log(`  Runtime: ${template.config.capabilities.runtime}`);
        console.log(`  Transport: ${template.config.capabilities.transport.join(", ")}`);
        console.log(`  Deployment: ${template.config.capabilities.deployment}`);
        console.log(`  Language: ${template.config.capabilities.language}`);
        console.log();
        console.log("Features:");
        console.log(`  Unit Testing: ${template.config.features.unitTesting ? "\u2713" : "\u2717"}`);
        console.log(
          `  Integration Testing: ${template.config.features.integrationTesting ? "\u2713" : "\u2717"}`
        );
        console.log(`  Documentation: ${template.config.features.documentation ? "\u2713" : "\u2717"}`);
        if (template.config.features.exampleTools.length > 0) {
          console.log(
            `  Example Tools: ${template.config.features.exampleTools.join(", ")}`
          );
        }
        console.log();
        if (template.config.scaffolding.variables.length > 0) {
          console.log("Variables:");
          for (const v of template.config.scaffolding.variables) {
            const req = v.required ? "(required)" : "(optional)";
            const def = v.default ? ` [default: ${v.default}]` : "";
            console.log(`  ${v.name} ${req}${def}`);
            if (v.prompt) {
              console.log(`    ${v.prompt}`);
            }
          }
          console.log();
        }
      }
    } catch (error) {
      console.error(`Error: ${error instanceof Error ? error.message : String(error)}`);
      process.exit(1);
    }
  });
}
function createValidateCommand() {
  return new Command("validate").description("Validate a template configuration").argument("<template-id>", "Template ID").option("--json", "Output as JSON").action(async (templateId, options) => {
    try {
      const registry = new TemplateRegistry();
      const result = await registry.validateTemplate(templateId);
      if (options.json) {
        console.log(JSON.stringify(result, null, 2));
      } else {
        if (result.valid) {
          console.log(`
\u2705 Template '${templateId}' is valid
`);
        } else {
          console.log(`
\u274C Template '${templateId}' has validation errors:
`);
          for (const error of result.errors) {
            console.log(`  - ${error}`);
          }
          console.log();
        }
        if (result.warnings.length > 0) {
          console.log("Warnings:");
          for (const warning of result.warnings) {
            console.log(`  \u26A0\uFE0F  ${warning}`);
          }
          console.log();
        }
      }
      if (!result.valid) {
        process.exit(1);
      }
    } catch (error) {
      console.error(`Error: ${error instanceof Error ? error.message : String(error)}`);
      process.exit(1);
    }
  });
}
function createCapabilitiesCommand() {
  return new Command("capabilities").description("Show all available capabilities across templates").option("--json", "Output as JSON").action(async (options) => {
    try {
      const registry = new TemplateRegistry();
      const capabilities = await registry.getCapabilities();
      const output = {
        runtimes: Array.from(capabilities.runtimes),
        transports: Array.from(capabilities.transports),
        deployments: Array.from(capabilities.deployments),
        languages: Array.from(capabilities.languages)
      };
      if (options.json) {
        console.log(JSON.stringify(output, null, 2));
      } else {
        console.log("\nAvailable Capabilities:\n");
        console.log("Runtimes:");
        for (const runtime of output.runtimes) {
          console.log(`  - ${runtime}`);
        }
        console.log();
        console.log("Transports:");
        for (const transport of output.transports) {
          console.log(`  - ${transport}`);
        }
        console.log();
        console.log("Deployments:");
        for (const deployment of output.deployments) {
          console.log(`  - ${deployment}`);
        }
        console.log();
        console.log("Languages:");
        for (const language of output.languages) {
          console.log(`  - ${language}`);
        }
        console.log();
      }
    } catch (error) {
      console.error(`Error: ${error instanceof Error ? error.message : String(error)}`);
      process.exit(1);
    }
  });
}
function createTemplateCommand() {
  const templateCmd = new Command("template").description("Manage and discover templates");
  templateCmd.addCommand(createListCommand());
  templateCmd.addCommand(createInfoCommand());
  templateCmd.addCommand(createValidateCommand());
  templateCmd.addCommand(createCapabilitiesCommand());
  return templateCmd;
}
async function createBackup(cwd) {
  const timestamp = Date.now();
  const backupDir = join(cwd, `.backup-auth-${timestamp}`);
  const srcDir = join(cwd, "src");
  if (existsSync(srcDir)) {
    await cp(srcDir, join(backupDir, "src"), { recursive: true });
  }
  const filesToBackup = [
    "package.json",
    "wrangler.toml",
    "wrangler.jsonc",
    "wrangler.json",
    "vercel.json",
    "next.config.js",
    "next.config.mjs",
    "next.config.ts",
    "README.md",
    ".gitignore",
    ".env",
    ".env.local"
  ];
  for (const file of filesToBackup) {
    const filePath = join(cwd, file);
    if (existsSync(filePath)) {
      await cp(filePath, join(backupDir, file));
    }
  }
  return backupDir;
}
async function restoreFromBackup(backupDir, cwd) {
  if (!existsSync(backupDir)) {
    throw new Error(`Backup directory not found: ${backupDir}`);
  }
  const backupSrcDir = join(backupDir, "src");
  if (existsSync(backupSrcDir)) {
    const targetSrcDir = join(cwd, "src");
    if (existsSync(targetSrcDir)) {
      await rm(targetSrcDir, { recursive: true, force: true });
    }
    await cp(backupSrcDir, targetSrcDir, { recursive: true });
  }
  const backupFiles = await readdir(backupDir);
  for (const file of backupFiles) {
    if (file === "src") {
      continue;
    }
    const backupFilePath = join(backupDir, file);
    const targetFilePath = join(cwd, file);
    const stats = await stat(backupFilePath);
    if (stats.isFile()) {
      await cp(backupFilePath, targetFilePath);
    }
  }
}
async function removeBackup(backupDir) {
  if (existsSync(backupDir)) {
    await rm(backupDir, { recursive: true, force: true });
  }
}

// src/core/commands/shared/orchestration/scaffold-orchestrator.ts
var ScaffoldOrchestrator = class {
  /**
   * Execute scaffolding with given strategy
   *
   * Template Method that defines the scaffolding algorithm:
   * 1. Create context
   * 2. Validate
   * 3. Backup (if needed)
   * 4. Execute strategy
   * 5. Cleanup backup on success
   * 6. Rollback on failure
   *
   * @param cwd - Current working directory
   * @param config - Configuration for scaffolding
   * @param strategy - Strategy to execute
   * @param options - Optional orchestration options
   * @returns Result from strategy
   */
  async scaffold(cwd, config, strategy, options = {}) {
    const context = this.createContext(cwd, config, strategy);
    if (options.dryRun) {
      await strategy.validate(cwd, config);
      return context.result;
    }
    try {
      await strategy.validate(cwd, config);
      if (strategy.needsBackup() && !options.skipBackup) {
        context.backupDir = await createBackup(cwd);
      }
      await strategy.execute(context);
      if (context.backupDir) {
        await removeBackup(context.backupDir);
        context.backupDir = void 0;
      }
      return context.result;
    } catch (error) {
      if (context.backupDir) {
        try {
          await restoreFromBackup(context.backupDir, cwd);
          await removeBackup(context.backupDir);
        } catch (rollbackError) {
          const rollbackMsg = rollbackError instanceof Error ? rollbackError.message : String(rollbackError);
          throw new Error(
            `Original error: ${error instanceof Error ? error.message : String(error)}
Rollback also failed: ${rollbackMsg}`
          );
        }
      }
      throw error;
    }
  }
  /**
   * Create scaffolding context
   *
   * @param cwd - Current working directory
   * @param config - Configuration
   * @param strategy - Strategy (used to create initial result)
   * @returns Initial context
   */
  createContext(cwd, config, strategy) {
    return {
      cwd,
      config,
      result: strategy.createResult(),
      metadata: {}
    };
  }
};
var RegistrationService = class _RegistrationService {
  static ENTITY_ORDER = ["tool", "prompt", "resource"];
  /**
   * Register an entity in src/index.ts
   */
  async registerEntity(cwd, name, capitalizedName, config) {
    const indexPath = join(cwd, "src", "index.ts");
    if (!existsSync(indexPath)) {
      throw new Error("src/index.ts not found");
    }
    const content = await readFile(indexPath, "utf-8");
    const functionName = `register${capitalizedName}${config.functionSuffix}`;
    if (content.includes(functionName)) {
      console.warn(
        `  \u26A0\uFE0F  ${config.entityType.charAt(0).toUpperCase() + config.entityType.slice(1)} already registered in src/index.ts`
      );
      return;
    }
    const needsEnv = await this.functionNeedsEnv(
      cwd,
      name,
      functionName,
      config
    );
    const importStatement = `import { ${functionName} } from "${config.directory}${name}.js";`;
    const registrationCall = needsEnv ? `		${functionName}(this.server, this.env);` : `		${functionName}(this.server);`;
    let updatedContent = this.addImport(content, importStatement, config);
    updatedContent = this.addRegistrationCall(
      updatedContent,
      registrationCall,
      config
    );
    await writeFile(indexPath, updatedContent, "utf-8");
  }
  /**
   * Check if an entity is already registered
   */
  async isRegistered(cwd, capitalizedName, config) {
    const indexPath = join(cwd, "src", "index.ts");
    if (!existsSync(indexPath)) {
      return false;
    }
    const content = await readFile(indexPath, "utf-8");
    const functionName = `register${capitalizedName}${config.functionSuffix}`;
    return content.includes(functionName);
  }
  /**
   * Add import statement to the file
   */
  addImport(content, importStatement, config) {
    let updatedContent = content;
    const currentTypeRegex = this.getImportRegex(config.directory);
    const currentTypeMatches = Array.from(content.matchAll(currentTypeRegex));
    if (currentTypeMatches.length > 0) {
      const lastMatch = currentTypeMatches[currentTypeMatches.length - 1];
      const insertPos = lastMatch.index + lastMatch[0].length;
      return content.slice(0, insertPos) + `
${importStatement}` + content.slice(insertPos);
    }
    const currentIndex = _RegistrationService.ENTITY_ORDER.indexOf(
      config.entityType
    );
    for (let i = currentIndex - 1; i >= 0; i--) {
      const fallbackType = _RegistrationService.ENTITY_ORDER[i];
      const fallbackDir = `./${fallbackType}s/`;
      const fallbackRegex = this.getImportRegex(fallbackDir);
      const fallbackMatches = Array.from(content.matchAll(fallbackRegex));
      if (fallbackMatches.length > 0) {
        const lastMatch = fallbackMatches[fallbackMatches.length - 1];
        const insertPos = lastMatch.index + lastMatch[0].length;
        const comment = `

// ${config.entityTypePlural.charAt(0).toUpperCase() + config.entityTypePlural.slice(1)}
`;
        return content.slice(0, insertPos) + comment + importStatement + content.slice(insertPos);
      }
    }
    const lastImportMatch = content.match(
      /import\s+[^;]+;(?=\s*\n\s*(?:\/\*|\/\/|\n|export|class))/g
    );
    if (lastImportMatch) {
      const lastImport = lastImportMatch[lastImportMatch.length - 1];
      const insertPos = content.indexOf(lastImport) + lastImport.length;
      const comment = `

// ${config.entityTypePlural.charAt(0).toUpperCase() + config.entityTypePlural.slice(1)}
`;
      return content.slice(0, insertPos) + comment + importStatement + content.slice(insertPos);
    }
    return updatedContent;
  }
  /**
   * Add registration call to init() method
   */
  addRegistrationCall(content, registrationCall, config) {
    const initMethodRegex = /async\s+init\(\)\s*\{([^}]*)\}/;
    const initMatch = content.match(initMethodRegex);
    if (!initMatch) {
      return content;
    }
    const initBody = initMatch[1];
    const currentTypePattern = `register\\w+${config.functionSuffix}\\(this\\.server\\);`;
    const currentTypeRegex = new RegExp(`\\s+${currentTypePattern}`, "g");
    const currentTypeMatches = initBody.match(currentTypeRegex);
    if (currentTypeMatches) {
      const lastCall = currentTypeMatches[currentTypeMatches.length - 1];
      const insertPos2 = initMatch.index + initMatch[0].lastIndexOf(lastCall) + lastCall.length;
      return content.slice(0, insertPos2) + `
${registrationCall}` + content.slice(insertPos2);
    }
    const currentIndex = _RegistrationService.ENTITY_ORDER.indexOf(
      config.entityType
    );
    for (let i = currentIndex - 1; i >= 0; i--) {
      const fallbackType = _RegistrationService.ENTITY_ORDER[i];
      const fallbackSuffix = fallbackType.charAt(0).toUpperCase() + fallbackType.slice(1);
      const fallbackPattern = `register\\w+${fallbackSuffix}\\(this\\.server\\);`;
      const fallbackRegex = new RegExp(`\\s+${fallbackPattern}`, "g");
      const fallbackMatches = initBody.match(fallbackRegex);
      if (fallbackMatches) {
        const lastCall = fallbackMatches[fallbackMatches.length - 1];
        const insertPos2 = initMatch.index + initMatch[0].lastIndexOf(lastCall) + lastCall.length;
        const comment2 = `

		// Register all ${config.entityTypePlural}
`;
        return content.slice(0, insertPos2) + comment2 + registrationCall + content.slice(insertPos2);
      }
    }
    const insertPos = initMatch.index + initMatch[0].indexOf("{") + 1;
    const comment = `
		// Register all ${config.entityTypePlural}
`;
    return content.slice(0, insertPos) + comment + registrationCall + content.slice(insertPos);
  }
  /**
   * Get import regex pattern for a directory
   */
  getImportRegex(directory) {
    const escapedDir = directory.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return new RegExp(
      `import\\s+\\{[^}]+\\}\\s+from\\s+["']${escapedDir}[^"']+["'];`,
      "g"
    );
  }
  /**
   * Detect if a registration function needs the env parameter
   * Reads the entity file and checks the function signature
   */
  async functionNeedsEnv(cwd, name, functionName, config) {
    try {
      const entityPath = join(
        cwd,
        "src",
        config.entityTypePlural,
        `${name}.ts`
      );
      if (!existsSync(entityPath)) {
        return false;
      }
      const entityContent = await readFile(entityPath, "utf-8");
      const functionPattern = new RegExp(
        `export\\s+function\\s+${functionName}\\s*\\([^)]*env[^)]*\\)`,
        "i"
      );
      return functionPattern.test(entityContent);
    } catch (error) {
      return false;
    }
  }
};
var ValidationService = class {
  /**
   * Validate entity name format
   *
   * Names must:
   * - Start with a lowercase letter
   * - Contain only lowercase letters, numbers, and hyphens
   * - Follow kebab-case convention
   *
   * @throws Error if name is invalid
   */
  validateName(name, config) {
    const nameRegex = /^[a-z][a-z0-9-]*$/;
    if (!nameRegex.test(name)) {
      const entityName = config.entityType.charAt(0).toUpperCase() + config.entityType.slice(1);
      throw new Error(
        `${entityName} name must be lowercase with hyphens (e.g., my-${config.entityType})`
      );
    }
  }
  /**
   * Validate we're in a valid MCP project
   *
   * @throws Error if not in a valid project
   */
  validateProject(cwd) {
    const packageJsonPath = join(cwd, "package.json");
    if (!existsSync(packageJsonPath)) {
      throw new Error(
        "Not in a valid project directory (no package.json found)"
      );
    }
  }
  /**
   * Check if entity file already exists
   *
   * @throws Error if entity file already exists
   */
  validateFileNotExists(cwd, name, config) {
    const filePath = join(cwd, config.sourceDir, `${name}.ts`);
    if (existsSync(filePath)) {
      const entityName = config.entityType.charAt(0).toUpperCase() + config.entityType.slice(1);
      throw new Error(`${entityName} already exists: ${filePath}`);
    }
  }
  /**
   * Validate all basic requirements for entity creation
   *
   * @throws Error if any validation fails
   */
  validateEntity(cwd, name, config) {
    this.validateName(name, config);
    this.validateProject(cwd);
    this.validateFileNotExists(cwd, name, config);
  }
  /**
   * Validate resource-specific options
   *
   * @throws Error if options are invalid
   */
  validateResourceOptions(options) {
    if (options.static && options.dynamic) {
      throw new Error("Cannot use both --static and --dynamic flags");
    }
  }
  /**
   * Determine URI pattern for a resource
   *
   * - If uriPattern is explicitly provided, use it
   * - If --dynamic flag is set, use dynamic pattern (resource://{id})
   * - Otherwise, default to static pattern (config://name)
   */
  determineUriPattern(name, options) {
    if (options.uriPattern) {
      return options.uriPattern;
    }
    if (options.dynamic) {
      return "resource://{id}";
    }
    return `config://${name}`;
  }
};
var TemplateService = class {
  templateCache = /* @__PURE__ */ new Map();
  templatesDir;
  constructor() {
    const __filename2 = fileURLToPath(import.meta.url);
    const __dirname2 = dirname(__filename2);
    let currentDir = __dirname2;
    let templatesPath = "";
    for (let i = 0; i < 5; i++) {
      const candidatePath = join(currentDir, "templates/scaffolding");
      try {
        if (statSync(candidatePath).isDirectory()) {
          templatesPath = candidatePath;
          break;
        }
      } catch {
      }
      currentDir = dirname(currentDir);
    }
    if (!templatesPath) {
      throw new Error(
        `Could not locate templates/scaffolding directory. Searched from: ${__dirname2}`
      );
    }
    this.templatesDir = templatesPath;
  }
  /**
   * Load and compile a Handlebars template
   */
  loadTemplate(templatePath) {
    if (this.templateCache.has(templatePath)) {
      return this.templateCache.get(templatePath);
    }
    const fullPath = join(this.templatesDir, templatePath);
    const templateContent = readFileSync(fullPath, "utf-8");
    const compiled = Handlebars.compile(templateContent, { noEscape: true });
    this.templateCache.set(templatePath, compiled);
    return compiled;
  }
  /**
   * Generate tool file content
   */
  generateToolFile(config) {
    const template = this.loadTemplate("entities/tool.hbs");
    return template(config);
  }
  /**
   * Generate prompt file content
   */
  generatePromptFile(config) {
    const template = this.loadTemplate("entities/prompt.hbs");
    return template(config);
  }
  /**
   * Generate resource file content
   */
  generateResourceFile(config) {
    const { uriPattern } = config;
    const hasVariables = uriPattern.includes("{") && uriPattern.includes("}");
    const variables = hasVariables ? Array.from(uriPattern.matchAll(/\{(\w+)\}/g)).map((m) => m[1]) : [];
    const context = {
      ...config,
      hasVariables,
      variables,
      variablesJoined: variables.join(", ")
    };
    const template = this.loadTemplate("entities/resource.hbs");
    return template(context);
  }
  /**
   * Generate entity file content based on entity type
   */
  generateEntityFile(config) {
    switch (config.entityType) {
      case "tool":
        return this.generateToolFile(config);
      case "prompt":
        return this.generatePromptFile(config);
      case "resource":
        if (!("uriPattern" in config)) {
          throw new Error("Resource template config must include uriPattern");
        }
        return this.generateResourceFile(config);
      default:
        throw new Error(`Unknown entity type: ${config.entityType}`);
    }
  }
  /**
   * Generate unit test file content
   */
  generateUnitTestFile(config) {
    const { entityType, name, capitalizedName } = config;
    const entityTypePlural = `${entityType}s`;
    const functionSuffix = entityType.charAt(0).toUpperCase() + entityType.slice(1);
    const context = {
      ...config,
      entityTypePlural,
      functionSuffix,
      isToolType: entityType === "tool",
      isPromptType: entityType === "prompt",
      isResourceType: entityType === "resource"
    };
    const template = this.loadTemplate("unit-tests/main.hbs");
    return template(context);
  }
  /**
   * Generate integration test YAML content
   */
  generateIntegrationTestYaml(config) {
    const { entityType, name, description } = config;
    if (entityType === "tool") {
      return this.generateToolIntegrationYaml(name, description);
    } else if (entityType === "prompt") {
      return this.generatePromptIntegrationYaml(name, description);
    } else if (entityType === "resource") {
      const uriPattern = config.uriPattern;
      return this.generateResourceIntegrationYaml(name, description, uriPattern);
    }
    throw new Error(`Unknown entity type: ${entityType}`);
  }
  /**
   * Generate tool integration test YAML
   */
  generateToolIntegrationYaml(name, description) {
    const context = {
      name,
      nameWithSpaces: name.replace(/_/g, " "),
      description: description || `Verify that ${name} tool works correctly`
    };
    const template = this.loadTemplate("integration-tests/tool.yaml.hbs");
    return template(context);
  }
  /**
   * Generate prompt integration test YAML
   */
  generatePromptIntegrationYaml(name, description) {
    const context = {
      name,
      nameWithSpaces: name.replace(/_/g, " "),
      description: description || `Verify that ${name} prompt works correctly`
    };
    const template = this.loadTemplate("integration-tests/prompt.yaml.hbs");
    return template(context);
  }
  /**
   * Generate resource integration test YAML
   */
  generateResourceIntegrationYaml(name, description, uriPattern) {
    const context = {
      name,
      nameWithSpaces: name.replace(/_/g, " "),
      description: description || "Test resource",
      uriPattern,
      uriPatternNoVars: uriPattern.replace(/\{[^}]+\}/g, "")
    };
    const template = this.loadTemplate("integration-tests/resource.yaml.hbs");
    return template(context);
  }
};
function getWranglerConfigPath(cwd) {
  const configFiles = ["wrangler.jsonc", "wrangler.json", "wrangler.toml"];
  for (const file of configFiles) {
    const path4 = join(cwd, file);
    if (existsSync(path4)) {
      return path4;
    }
  }
  return null;
}
function parseJSONC(content) {
  const stripped = stripJsonComments(content);
  return JSON.parse(stripped);
}
function formatJSON(obj) {
  return JSON.stringify(obj, null, "	");
}
function toPascalCase(str) {
  return str.split("-").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join("");
}
function toKebabCase(str) {
  return str.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
}
async function fileExists(filePath) {
  try {
    await access(filePath);
    return true;
  } catch {
    return false;
  }
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// src/core/commands/shared/binding-detection-service.ts
var BindingDetectionService = class {
  /**
   * Detect all bindings configured in wrangler.jsonc
   *
   * @param cwd - Project root directory
   * @returns Detected bindings organized by type
   */
  async detectBindings(cwd) {
    const bindings = {
      kv: [],
      d1: [],
      r2: []
    };
    const wranglerPath = getWranglerConfigPath(cwd);
    if (!wranglerPath || !existsSync(wranglerPath)) {
      return bindings;
    }
    try {
      const content = await readFile(wranglerPath, "utf-8");
      const config = parseJSONC(content);
      if (Array.isArray(config.kv_namespaces)) {
        bindings.kv = config.kv_namespaces.map((ns) => ns.binding).filter((b) => typeof b === "string" && b.length > 0);
      }
      if (Array.isArray(config.d1_databases)) {
        bindings.d1 = config.d1_databases.map((db) => db.binding).filter((b) => typeof b === "string" && b.length > 0);
      }
      if (Array.isArray(config.r2_buckets)) {
        bindings.r2 = config.r2_buckets.map((bucket) => bucket.binding).filter((b) => typeof b === "string" && b.length > 0);
      }
      if (config.ai && typeof config.ai.binding === "string" && config.ai.binding.length > 0) {
        bindings.ai = config.ai.binding;
      }
    } catch (error) {
      console.warn(
        `Warning: Could not parse wrangler config: ${error instanceof Error ? error.message : String(error)}`
      );
    }
    return bindings;
  }
  /**
   * Check if project has any bindings configured
   *
   * @param cwd - Project root directory
   * @returns True if at least one binding is configured
   */
  async hasAnyBindings(cwd) {
    const bindings = await this.detectBindings(cwd);
    return bindings.kv.length > 0 || bindings.d1.length > 0 || bindings.r2.length > 0 || !!bindings.ai;
  }
  /**
   * Generate binding usage examples for template comments
   *
   * @param bindings - Detected bindings
   * @returns Array of binding examples with imports and usage
   */
  generateBindingExamples(bindings) {
    const examples = [];
    for (const bindingName of bindings.kv) {
      const helperClass = this.getHelperClassName(bindingName, "kv");
      const helperFile = this.getHelperFileName(bindingName, "kv");
      examples.push({
        type: "kv",
        bindingName,
        helperClass,
        importStatement: `import { ${helperClass} } from "../utils/bindings/${helperFile}.js";`,
        usageExample: [
          `const cache = new ${helperClass}(env.${bindingName});`,
          `const data = await cache.get<MyType>('key');`,
          `await cache.set('key', { value: 'data' }, { expirationTtl: 3600 });`
        ].join("\n// ")
      });
    }
    for (const bindingName of bindings.d1) {
      const helperClass = this.getHelperClassName(bindingName, "d1");
      const helperFile = this.getHelperFileName(bindingName, "d1");
      examples.push({
        type: "d1",
        bindingName,
        helperClass,
        importStatement: `import { ${helperClass} } from "../utils/bindings/${helperFile}.js";`,
        usageExample: [
          `const db = new ${helperClass}(env.${bindingName});`,
          `const users = await db.query<User>('SELECT * FROM users WHERE active = ?', [true]);`,
          `await db.execute('INSERT INTO logs (message) VALUES (?)', ['User logged in']);`
        ].join("\n// ")
      });
    }
    for (const bindingName of bindings.r2) {
      const helperClass = this.getHelperClassName(bindingName, "r2");
      const helperFile = this.getHelperFileName(bindingName, "r2");
      examples.push({
        type: "r2",
        bindingName,
        helperClass,
        importStatement: `import { ${helperClass} } from "../utils/bindings/${helperFile}.js";`,
        usageExample: [
          `const bucket = new ${helperClass}(env.${bindingName});`,
          `await bucket.putText('files/readme.txt', 'Hello World');`,
          `const content = await bucket.getText('files/readme.txt');`
        ].join("\n// ")
      });
    }
    if (bindings.ai) {
      examples.push({
        type: "ai",
        bindingName: bindings.ai,
        usageExample: [
          `// RAG with LLM:`,
          `const ragResult = await env.${bindings.ai}.aiSearch('my-instance', 'query text');`,
          ``,
          `// Vector-only search:`,
          `const searchResult = await env.${bindings.ai}.search('my-instance', 'query text');`
        ].join("\n// ")
      });
    }
    return examples;
  }
  /**
   * Generate compact binding summary for template comments
   * Format: "KV: MY_CACHE, SESSION_STORE | D1: USER_DB | R2: UPLOADS | AI: AI"
   *
   * @param bindings - Detected bindings
   * @returns Compact summary string
   */
  generateBindingSummary(bindings) {
    const parts = [];
    if (bindings.kv.length > 0) {
      parts.push(`KV: ${bindings.kv.join(", ")}`);
    }
    if (bindings.d1.length > 0) {
      parts.push(`D1: ${bindings.d1.join(", ")}`);
    }
    if (bindings.r2.length > 0) {
      parts.push(`R2: ${bindings.r2.join(", ")}`);
    }
    if (bindings.ai) {
      parts.push(`AI: ${bindings.ai}`);
    }
    return parts.join(" | ");
  }
  /**
   * Get helper class name for a binding
   * Example: MY_CACHE (kv) -> MyCacheKV
   */
  getHelperClassName(bindingName, bindingType) {
    const baseName = toPascalCase(bindingName.toLowerCase().replace(/_/g, "-"));
    const suffix = bindingType.toUpperCase();
    return `${baseName}${suffix}`;
  }
  /**
   * Get helper file name for a binding
   * Example: MY_CACHE (kv) -> kv-my-cache
   */
  getHelperFileName(bindingName, bindingType) {
    const fileName = bindingName.toLowerCase().replace(/_/g, "-");
    return `${bindingType}-${fileName}`;
  }
};
async function updateTemplateMetadata(cwd, entityType, name, fileSubpath, hasTests) {
  const metadataPath = join(cwd, ".mcp-template.json");
  if (!existsSync(metadataPath)) {
    return;
  }
  try {
    const content = await readFile(metadataPath, "utf-8");
    const metadata = JSON.parse(content);
    if (!metadata[entityType]) {
      metadata[entityType] = [];
    }
    const entityMetadata = {
      name,
      file: fileSubpath,
      registered: true,
      hasUnitTest: hasTests,
      hasIntegrationTest: hasTests
    };
    metadata[entityType].push(entityMetadata);
    await writeFile(metadataPath, JSON.stringify(metadata, null, "	"), "utf-8");
  } catch (error) {
    console.warn(`  \u26A0\uFE0F  Could not update .mcp-template.json: ${error}`);
  }
}
var ResourceOptionsSchema = z.object({
  /** URI pattern for the resource */
  uriPattern: z.string().optional(),
  /** Whether this is a static resource */
  static: z.boolean().optional(),
  /** Whether this is a dynamic resource with variables */
  dynamic: z.boolean().optional()
});
var ScaffoldConfigSchema = z.object({
  /** Entity type (tool, prompt, resource) */
  entityType: z.enum(["tool", "prompt", "resource"]),
  /** Entity name in kebab-case */
  name: z.string().regex(/^[a-z][a-z0-9-]*$/, {
    message: "Entity name must be lowercase with hyphens (e.g., my-entity)"
  }),
  /** Description of the entity */
  description: z.string().optional(),
  /** Whether to generate test files (default: true) */
  generateTests: z.boolean().optional().default(true),
  /** Whether to auto-register in index.ts (default: true) */
  autoRegister: z.boolean().optional().default(true),
  /** Resource-specific options (required for resources) */
  resourceOptions: ResourceOptionsSchema.optional()
}).refine(
  (data) => {
    if (data.entityType === "resource" && !data.resourceOptions) {
      return false;
    }
    return true;
  },
  {
    message: "Resource options are required when entityType is 'resource'",
    path: ["resourceOptions"]
  }
).refine(
  (data) => {
    if (data.resourceOptions?.static && data.resourceOptions?.dynamic) {
      return false;
    }
    return true;
  },
  {
    message: "Cannot use both --static and --dynamic flags",
    path: ["resourceOptions"]
  }
);
z.object({
  /** Entity type */
  entityType: z.enum(["tool", "prompt", "resource"]),
  /** Entity type plural form */
  entityTypePlural: z.enum(["tools", "prompts", "resources"]),
  /** Import directory path */
  directory: z.string(),
  /** Function name suffix */
  functionSuffix: z.string()
});
z.object({
  /** Entity type */
  entityType: z.enum(["tool", "prompt", "resource"]),
  /** Directory where entity file will be created */
  sourceDir: z.string()
});
var TemplateConfigSchema2 = z.object({
  /** Entity type */
  entityType: z.enum(["tool", "prompt", "resource"]),
  /** Entity name in kebab-case */
  name: z.string(),
  /** Capitalized name (PascalCase) */
  capitalizedName: z.string(),
  /** Entity description */
  description: z.string().optional()
});
TemplateConfigSchema2.extend({
  /** Entity type must be resource */
  entityType: z.literal("resource"),
  /** URI pattern for the resource */
  uriPattern: z.string()
});
z.object({
  /** Entity type */
  entityType: z.enum(["tool", "prompt", "resource"]),
  /** Entity type plural form */
  entityTypePlural: z.enum(["tools", "prompts", "resources"]),
  /** Directory where entities are stored */
  directory: z.string(),
  /** Function name suffix */
  functionSuffix: z.string(),
  /** Regex pattern to extract description from file */
  descriptionPattern: z.instanceof(RegExp),
  /** Command name for CLI */
  commandName: z.string(),
  /** Command description for CLI */
  commandDescription: z.string()
});

// src/core/commands/shared/strategies/entity-scaffold-strategy.ts
var EntityScaffoldStrategy = class {
  registrationService;
  validationService;
  templateService;
  bindingDetectionService;
  constructor() {
    this.registrationService = new RegistrationService();
    this.validationService = new ValidationService();
    this.templateService = new TemplateService();
    this.bindingDetectionService = new BindingDetectionService();
  }
  /**
   * Validate entity configuration
   */
  async validate(cwd, config) {
    const parseResult = ScaffoldConfigSchema.safeParse(config);
    if (!parseResult.success) {
      const firstError = parseResult.error.errors[0];
      throw new Error(firstError.message);
    }
    const { entityType, name } = parseResult.data;
    const validationConfig = {
      entityType,
      sourceDir: `src/${entityType}s`
    };
    this.validationService.validateEntity(cwd, name, validationConfig);
    if (entityType === "resource" && config.resourceOptions) {
      this.validationService.validateResourceOptions(config.resourceOptions);
    }
  }
  /**
   * Execute entity scaffolding
   *
   * 1. Generate entity file
   * 2. Generate test files (if enabled)
   * 3. Register entity (if enabled)
   * 4. Update metadata
   */
  async execute(context) {
    const { cwd, config, result } = context;
    const { entityType, name } = config;
    const capitalizedName = toPascalCase(name);
    const description = config.description || "TODO: Add description";
    const generateTests = config.generateTests !== false;
    const autoRegister = config.autoRegister !== false;
    const entityFilePath = await this.generateEntityFile(
      cwd,
      name,
      capitalizedName,
      description,
      config
    );
    result.filesCreated.push(entityFilePath);
    if (generateTests) {
      const testFiles = await this.generateTestFiles(
        cwd,
        name,
        capitalizedName,
        description,
        config
      );
      result.filesCreated.push(...testFiles);
    }
    if (autoRegister) {
      const registrationConfig = {
        entityType,
        entityTypePlural: `${entityType}s`,
        directory: `./${entityType}s/`,
        functionSuffix: entityType.charAt(0).toUpperCase() + entityType.slice(1)
      };
      await this.registrationService.registerEntity(
        cwd,
        name,
        capitalizedName,
        registrationConfig
      );
      result.registered = true;
    }
    await updateTemplateMetadata(
      cwd,
      `${entityType}s`,
      name,
      `src/${entityType}s/${name}.ts`,
      generateTests
    );
    result.success = true;
  }
  /**
   * Entities don't need backup (low risk)
   */
  needsBackup() {
    return false;
  }
  /**
   * Create initial result object
   */
  createResult() {
    return {
      success: false,
      filesCreated: [],
      registered: false,
      messages: []
    };
  }
  /**
   * Generate the main entity file
   */
  async generateEntityFile(cwd, name, capitalizedName, description, config) {
    const { entityType, resourceOptions } = config;
    const dirPath = join(cwd, "src", `${entityType}s`);
    const filePath = join(dirPath, `${name}.ts`);
    await mkdir(dirPath, { recursive: true });
    let bindingContext;
    if (entityType === "tool") {
      const bindings = await this.bindingDetectionService.detectBindings(cwd);
      const hasBindings = bindings.kv.length > 0 || bindings.d1.length > 0 || bindings.r2.length > 0 || !!bindings.ai;
      if (hasBindings) {
        const examples = this.bindingDetectionService.generateBindingExamples(bindings);
        const summary = this.bindingDetectionService.generateBindingSummary(bindings);
        bindingContext = {
          hasBindings: true,
          bindingSummary: summary,
          bindingExamples: examples
        };
      } else {
        bindingContext = {
          hasBindings: false
        };
      }
    }
    let content;
    if (entityType === "resource" && resourceOptions) {
      const uriPattern = this.validationService.determineUriPattern(
        name,
        resourceOptions
      );
      const resourceConfig = {
        entityType,
        name,
        capitalizedName,
        description,
        uriPattern
      };
      content = this.templateService.generateEntityFile(resourceConfig);
    } else {
      content = this.templateService.generateEntityFile({
        entityType,
        name,
        capitalizedName,
        description,
        bindingContext
      });
    }
    await writeFile(filePath, content, "utf-8");
    return filePath;
  }
  /**
   * Generate unit and integration test files
   */
  async generateTestFiles(cwd, name, capitalizedName, description, config) {
    const { entityType, resourceOptions } = config;
    const testFiles = [];
    const unitTestPath = await this.generateUnitTest(
      cwd,
      name,
      capitalizedName,
      description,
      entityType
    );
    testFiles.push(unitTestPath);
    const integrationTestPath = await this.generateIntegrationTest(
      cwd,
      name,
      capitalizedName,
      description,
      entityType,
      resourceOptions
    );
    testFiles.push(integrationTestPath);
    return testFiles;
  }
  /**
   * Generate unit test file
   */
  async generateUnitTest(cwd, name, capitalizedName, description, entityType) {
    const dirPath = join(cwd, "test", "unit", `${entityType}s`);
    const filePath = join(dirPath, `${name}.test.ts`);
    await mkdir(dirPath, { recursive: true });
    const content = this.templateService.generateUnitTestFile({
      entityType,
      name,
      capitalizedName,
      description
    });
    await writeFile(filePath, content, "utf-8");
    return filePath;
  }
  /**
   * Generate integration test file (YAML)
   */
  async generateIntegrationTest(cwd, name, capitalizedName, description, entityType, resourceOptions) {
    const dirPath = join(
      cwd,
      "test",
      "integration",
      "specs",
      entityType === "tool" ? "" : `${entityType}s`
    );
    const filePath = join(dirPath, `${name}.yaml`);
    await mkdir(dirPath, { recursive: true });
    let content;
    if (entityType === "resource" && resourceOptions) {
      const uriPattern = this.validationService.determineUriPattern(
        name,
        resourceOptions
      );
      content = this.templateService.generateIntegrationTestYaml({
        entityType,
        name,
        capitalizedName,
        description,
        uriPattern
      });
    } else {
      content = this.templateService.generateIntegrationTestYaml({
        entityType,
        name,
        capitalizedName,
        description
      });
    }
    await writeFile(filePath, content, "utf-8");
    return filePath;
  }
};

// src/core/commands/shared/entity-scaffolder.ts
var EntityScaffolder = class {
  orchestrator;
  strategy;
  constructor() {
    this.orchestrator = new ScaffoldOrchestrator();
    this.strategy = new EntityScaffoldStrategy();
  }
  /**
   * Scaffold a new entity
   *
   * @param cwd Current working directory (project root)
   * @param config Scaffolding configuration
   * @returns Result with created files and registration status
   */
  async scaffold(cwd, config) {
    return this.orchestrator.scaffold(cwd, config, this.strategy);
  }
  /**
   * Get emoji for entity type (for console output)
   */
  static getEntityEmoji(entityType) {
    switch (entityType) {
      case "tool":
        return "\u{1F527}";
      case "prompt":
        return "\u{1F4DD}";
      case "resource":
        return "\u{1F4E6}";
    }
  }
  /**
   * Get entity type display name
   */
  static getEntityDisplayName(entityType) {
    return entityType.charAt(0).toUpperCase() + entityType.slice(1);
  }
};
function createAddPromptCommand() {
  const command = new Command("prompt").description("Add a new MCP prompt to the project").argument("<name>", "Prompt name (lowercase with hyphens)").option(
    "--description <desc>",
    "Prompt description",
    "TODO: Add description"
  ).option("--no-tests", "Skip test file generation").option("--no-register", "Don't auto-register in index.ts").option("--json", "Output result as JSON").action(async (name, options) => {
    try {
      const cwd = process.cwd();
      const scaffolder = new EntityScaffolder();
      const config = {
        entityType: "prompt",
        name,
        description: options.description,
        generateTests: options.tests,
        autoRegister: options.register
      };
      const scaffoldResult = await scaffolder.scaffold(cwd, config);
      const result = {
        success: scaffoldResult.success,
        entityType: "prompt",
        entityName: name,
        filesCreated: scaffoldResult.filesCreated,
        registered: scaffoldResult.registered,
        message: `Prompt '${name}' created successfully`
      };
      outputResult(result, !!options.json, (r) => {
        console.log(`
\u{1F4DD} Adding prompt: ${name}
`);
        for (const file of r.filesCreated) {
          console.log(`\u2713 Created ${file}`);
        }
        if (r.registered) {
          console.log(`\u2713 Registered in src/index.ts`);
        }
        console.log(`
\u2705 Prompt '${name}' created successfully!
`);
        console.log("Next steps:");
        console.log(`  1. Edit src/prompts/${name}.ts and implement your logic`);
        console.log(`  2. Run 'npm test' to verify tests pass`);
        console.log(`  3. Run 'npm run validate' to check project health
`);
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (options.json) {
        const result = {
          success: false,
          entityType: "prompt",
          entityName: name,
          filesCreated: [],
          registered: false,
          error: errorMessage
        };
        console.log(JSON.stringify(result, null, 2));
      } else {
        console.error(`
\u274C Error: ${errorMessage}
`);
      }
      process.exit(1);
    }
  });
  return command;
}
function createAddResourceCommand() {
  const command = new Command("resource").description("Add a new MCP resource to the project").argument("<name>", "Resource name (lowercase with hyphens)").option(
    "--description <desc>",
    "Resource description",
    "TODO: Add description"
  ).option(
    "--uri-pattern <pattern>",
    "URI pattern (e.g., 'user://{id}' for dynamic, 'config://app' for static)"
  ).option(
    "--static",
    "Explicitly create a static resource (fixed URI, no variables)"
  ).option(
    "--dynamic",
    "Create a dynamic resource (URI with template variables like {id})"
  ).option("--no-tests", "Skip test file generation").option("--no-register", "Don't auto-register in index.ts").option("--json", "Output result as JSON").action(async (name, options) => {
    if (options.static && options.dynamic) {
      throw new Error("Cannot use both --static and --dynamic flags");
    }
    if (!options.uriPattern) {
      if (options.dynamic) {
        options.uriPattern = "resource://{id}";
      } else {
        options.uriPattern = `config://${name}`;
      }
    }
    try {
      const cwd = process.cwd();
      const scaffolder = new EntityScaffolder();
      const config = {
        entityType: "resource",
        name,
        description: options.description,
        generateTests: options.tests,
        autoRegister: options.register,
        resourceOptions: {
          uriPattern: options.uriPattern,
          static: options.static,
          dynamic: options.dynamic
        }
      };
      const scaffoldResult = await scaffolder.scaffold(cwd, config);
      const result = {
        success: scaffoldResult.success,
        entityType: "resource",
        entityName: name,
        filesCreated: scaffoldResult.filesCreated,
        registered: scaffoldResult.registered,
        message: `Resource '${name}' created successfully`
      };
      outputResult(result, !!options.json, (r) => {
        console.log(`
\u{1F4E6} Adding resource: ${name}
`);
        for (const file of r.filesCreated) {
          console.log(`\u2713 Created ${file}`);
        }
        if (r.registered) {
          console.log(`\u2713 Registered in src/index.ts`);
        }
        console.log(`
\u2705 Resource '${name}' created successfully!
`);
        console.log("Next steps:");
        console.log(`  1. Edit src/resources/${name}.ts and implement your logic`);
        console.log(`  2. Run 'npm test' to verify tests pass`);
        console.log(`  3. Run 'npm run validate' to check project health
`);
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (options.json) {
        const result = {
          success: false,
          entityType: "resource",
          entityName: name,
          filesCreated: [],
          registered: false,
          error: errorMessage
        };
        console.log(JSON.stringify(result, null, 2));
      } else {
        console.error(`
\u274C Error: ${errorMessage}
`);
      }
      process.exit(1);
    }
  });
  return command;
}
async function detectPlatform(cwd) {
  if (await isCloudflareProject(cwd)) {
    return "cloudflare";
  }
  if (await isVercelProject(cwd)) {
    return "vercel";
  }
  return "unknown";
}
async function isCloudflareProject(cwd) {
  const wranglerFiles = ["wrangler.jsonc", "wrangler.json", "wrangler.toml"];
  for (const file of wranglerFiles) {
    if (existsSync(join(cwd, file))) {
      return true;
    }
  }
  const pkgPath = join(cwd, "package.json");
  if (existsSync(pkgPath)) {
    try {
      const pkg = JSON.parse(await readFile(pkgPath, "utf-8"));
      if (pkg.dependencies?.["agents"] || pkg.devDependencies?.["wrangler"]) {
        return true;
      }
    } catch {
    }
  }
  return false;
}
async function isVercelProject(cwd) {
  const vercelFiles = [
    "vercel.json",
    "next.config.js",
    "next.config.mjs",
    "next.config.ts"
  ];
  for (const file of vercelFiles) {
    if (existsSync(join(cwd, file))) {
      return true;
    }
  }
  const pkgPath = join(cwd, "package.json");
  if (existsSync(pkgPath)) {
    try {
      const pkg = JSON.parse(await readFile(pkgPath, "utf-8"));
      if (pkg.dependencies?.["next"] || pkg.dependencies?.["@vercel/mcp-adapter"] || pkg.devDependencies?.["next"]) {
        return true;
      }
    } catch {
    }
  }
  return false;
}
function getEntryPointPath(cwd, platform) {
  switch (platform) {
    case "cloudflare":
      return join(cwd, "src/index.ts");
    case "vercel":
      return join(cwd, "app/api/mcp/route.ts");
    default:
      throw new Error(`Unknown platform: ${platform}`);
  }
}

// src/core/commands/shared/auth-templates.ts
function generateAuthTypesTemplate() {
  return `/**
 * Authentication Types
 *
 * Common interfaces for all auth providers.
 */

export interface AuthProvider {
	name: string;
	validateToken(token: string, env: Env): Promise<UserContext>;
	getMetadata(env: Env): AuthServerMetadata;
	getRequiredEnvVars(): string[];
}

export interface UserContext {
	userId: string;
	email?: string;
	name?: string;
	scopes?: string[];
	metadata?: Record<string, unknown>;
}

export interface AuthServerMetadata {
	issuer: string;
	authorization_endpoint: string;
	token_endpoint: string;
	registration_endpoint?: string;
	scopes_supported?: string[];
}

export class AuthenticationError extends Error {
	constructor(message: string, public code: string) {
		super(message);
		this.name = "AuthenticationError";
	}
}
`;
}
function generateAuthConfigTemplate(provider) {
  const capitalizedProvider = capitalizeFirst(provider);
  return `/**
 * Authentication Configuration
 *
 * Provides the appropriate auth provider based on environment.
 */

import type { AuthProvider } from "./types.js";
import { ${capitalizedProvider}Provider } from "./providers/${provider}.js";

export function getAuthProvider(env: Env): AuthProvider {
	return new ${capitalizedProvider}Provider();
}

export function validateAuthEnv(env: Env): void {
	const provider = getAuthProvider(env);
	const required = provider.getRequiredEnvVars();

	for (const key of required) {
		if (!env[key]) {
			throw new Error(
				\`Missing required environment variable: \${key}\\n\` +
					\`Please set this in your .env file or wrangler.toml\`,
			);
		}
	}
}
`;
}
function generateStytchProviderTemplate() {
  return `/**
 * Stytch Authentication Provider
 *
 * Uses Stytch Connected Apps for MCP server authentication.
 * Docs: https://stytch.com/docs/guides/connected-apps/mcp-servers
 */

import type {
	AuthProvider,
	UserContext,
	AuthServerMetadata,
} from "../types.js";
import { AuthenticationError } from "../types.js";

export class StytchProvider implements AuthProvider {
	name = "stytch";

	async validateToken(token: string, env: Env): Promise<UserContext> {
		try {
			// Stytch session authentication
			const response = await fetch(
				"https://api.stytch.com/v1/sessions/authenticate",
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: \`Basic \${btoa(\`\${env.STYTCH_PROJECT_ID}:\${env.STYTCH_SECRET}\`)}\`,
					},
					body: JSON.stringify({
						session_token: token,
					}),
				},
			);

			if (!response.ok) {
				throw new AuthenticationError(
					"Invalid or expired token",
					"invalid_token",
				);
			}

			const data = await response.json();

			return {
				userId: data.session.user_id,
				email: data.session.attributes?.email,
				name: data.session.attributes?.name,
				metadata: {
					sessionId: data.session.session_id,
					authenticatedAt: data.session.authenticated_at,
				},
			};
		} catch (error) {
			if (error instanceof AuthenticationError) {
				throw error;
			}
			throw new AuthenticationError(
				"Failed to validate token",
				"validation_failed",
			);
		}
	}

	getMetadata(env: Env): AuthServerMetadata {
		const baseUrl =
			env.STYTCH_ENV === "live"
				? "https://api.stytch.com"
				: "https://test.stytch.com";

		return {
			issuer: \`\${baseUrl}/v1/projects/\${env.STYTCH_PROJECT_ID}\`,
			authorization_endpoint: \`\${baseUrl}/v1/oauth/authorize\`,
			token_endpoint: \`\${baseUrl}/v1/oauth/token\`,
			registration_endpoint: \`\${baseUrl}/v1/oauth/register\`,
			scopes_supported: ["openid", "profile", "email"],
		};
	}

	getRequiredEnvVars(): string[] {
		return ["STYTCH_PROJECT_ID", "STYTCH_SECRET"];
	}
}
`;
}
function generateAuth0ProviderTemplate() {
  return `/**
 * Auth0 Authentication Provider
 *
 * Uses Auth0 for enterprise-grade authentication.
 * Docs: https://auth0.com/docs
 */

import type {
	AuthProvider,
	UserContext,
	AuthServerMetadata,
} from "../types.js";
import { AuthenticationError } from "../types.js";

export class Auth0Provider implements AuthProvider {
	name = "auth0";

	async validateToken(token: string, env: Env): Promise<UserContext> {
		try {
			// Verify JWT with Auth0
			const response = await fetch(\`https://\${env.AUTH0_DOMAIN}/userinfo\`, {
				headers: {
					Authorization: \`Bearer \${token}\`,
				},
			});

			if (!response.ok) {
				throw new AuthenticationError(
					"Invalid or expired token",
					"invalid_token",
				);
			}

			const data = await response.json();

			return {
				userId: data.sub,
				email: data.email,
				name: data.name,
				metadata: {
					emailVerified: data.email_verified,
					picture: data.picture,
				},
			};
		} catch (error) {
			if (error instanceof AuthenticationError) {
				throw error;
			}
			throw new AuthenticationError(
				"Failed to validate token",
				"validation_failed",
			);
		}
	}

	getMetadata(env: Env): AuthServerMetadata {
		const domain = env.AUTH0_DOMAIN;

		return {
			issuer: \`https://\${domain}/\`,
			authorization_endpoint: \`https://\${domain}/authorize\`,
			token_endpoint: \`https://\${domain}/oauth/token\`,
			registration_endpoint: \`https://\${domain}/oidc/register\`,
			scopes_supported: ["openid", "profile", "email", "offline_access"],
		};
	}

	getRequiredEnvVars(): string[] {
		return ["AUTH0_DOMAIN", "AUTH0_CLIENT_ID", "AUTH0_CLIENT_SECRET", "AUTH0_AUDIENCE"];
	}
}
`;
}
function generateWorkOSProviderTemplate() {
  return `/**
 * WorkOS Authentication Provider
 *
 * Uses WorkOS for B2B/enterprise authentication with SSO support.
 * Docs: https://workos.com/docs
 */

import type {
	AuthProvider,
	UserContext,
	AuthServerMetadata,
} from "../types.js";
import { AuthenticationError } from "../types.js";

export class WorkosProvider implements AuthProvider {
	name = "workos";

	async validateToken(token: string, env: Env): Promise<UserContext> {
		try {
			// Get user profile from WorkOS
			const response = await fetch(
				"https://api.workos.com/user_management/users/me",
				{
					headers: {
						Authorization: \`Bearer \${token}\`,
					},
				},
			);

			if (!response.ok) {
				throw new AuthenticationError(
					"Invalid or expired token",
					"invalid_token",
				);
			}

			const data = await response.json();

			return {
				userId: data.id,
				email: data.email,
				name: \`\${data.first_name} \${data.last_name}\`.trim(),
				metadata: {
					organizationId: data.organization_id,
					emailVerified: data.email_verified,
				},
			};
		} catch (error) {
			if (error instanceof AuthenticationError) {
				throw error;
			}
			throw new AuthenticationError(
				"Failed to validate token",
				"validation_failed",
			);
		}
	}

	getMetadata(env: Env): AuthServerMetadata {
		return {
			issuer: "https://api.workos.com/",
			authorization_endpoint:
				"https://api.workos.com/user_management/authorize",
			token_endpoint: "https://api.workos.com/user_management/token",
			scopes_supported: ["openid", "profile", "email", "organizations"],
		};
	}

	getRequiredEnvVars(): string[] {
		return ["WORKOS_API_KEY", "WORKOS_CLIENT_ID"];
	}
}
`;
}
function generateEnvExampleTemplate(provider) {
  const templates = {
    stytch: `# Stytch Configuration
# Get these from: https://stytch.com/dashboard/api-keys
STYTCH_PROJECT_ID=project-test-00000000-0000-0000-0000-000000000000
STYTCH_SECRET=secret-test-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
STYTCH_ENV=test  # Use "live" for production

# Stytch Setup Instructions:
# 1. Create a Stytch account at https://stytch.com
# 2. Create a new "Consumer Authentication" project
# 3. Go to API Keys and copy your Project ID and Secret
# 4. In Connected Apps settings:
#    - Enable "Allow dynamic client registration"
#    - Add your Worker URL (after deployment)
# 5. Update this file with your credentials
`,
    auth0: `# Auth0 Configuration
# Get these from: https://manage.auth0.com/dashboard
AUTH0_DOMAIN=your-tenant.auth0.com
AUTH0_CLIENT_ID=xxxxxxxxxxxxxxxxxxxx
AUTH0_CLIENT_SECRET=yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
AUTH0_AUDIENCE=https://your-api.example.com

# Auth0 Setup Instructions:
# 1. Create an Auth0 account at https://auth0.com
# 2. Create a new application (Machine to Machine or Regular Web App)
# 3. Copy your Domain, Client ID, and Client Secret
# 4. Set your API Audience (API identifier)
# 5. Update this file with your credentials
`,
    workos: `# WorkOS Configuration
# Get these from: https://dashboard.workos.com/
WORKOS_API_KEY=sk_test_xxxxxxxxxxxxxxxxxxxx
WORKOS_CLIENT_ID=client_xxxxxxxxxxxxxxxxxxxx

# WorkOS Setup Instructions:
# 1. Create a WorkOS account at https://workos.com
# 2. Go to API Keys in the dashboard
# 3. Create a new API key
# 4. Copy your Client ID from the application settings
# 5. Update this file with your credentials
`
  };
  return templates[provider];
}
function capitalizeFirst(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function getAuthDependencies(provider, platform) {
  const deps = {
    dependencies: {},
    devDependencies: {}
  };
  if (platform === "cloudflare") {
    deps.dependencies["@cloudflare/workers-oauth-provider"] = "^0.0.12";
  }
  switch (provider) {
    case "stytch":
      break;
    case "auth0":
      deps.dependencies["auth0"] = "^4.0.0";
      break;
    case "workos":
      deps.dependencies["@workos-inc/node"] = "^7.0.0";
      break;
  }
  return deps;
}
async function addDependenciesToPackageJson(cwd, update) {
  const packageJsonPath = join(cwd, "package.json");
  if (!existsSync(packageJsonPath)) {
    throw new Error(`package.json not found at ${packageJsonPath}`);
  }
  const content = await readFile(packageJsonPath, "utf-8");
  const pkg = JSON.parse(content);
  let modified = false;
  if (Object.keys(update.dependencies).length > 0) {
    pkg.dependencies = pkg.dependencies || {};
    for (const [name, version] of Object.entries(update.dependencies)) {
      if (!pkg.dependencies[name]) {
        pkg.dependencies[name] = version;
        modified = true;
      }
    }
    pkg.dependencies = sortObject(pkg.dependencies);
  }
  if (Object.keys(update.devDependencies).length > 0) {
    pkg.devDependencies = pkg.devDependencies || {};
    for (const [name, version] of Object.entries(update.devDependencies)) {
      if (!pkg.devDependencies[name]) {
        pkg.devDependencies[name] = version;
        modified = true;
      }
    }
    pkg.devDependencies = sortObject(pkg.devDependencies);
  }
  if (modified) {
    await writeFile(
      packageJsonPath,
      JSON.stringify(pkg, null, 2) + "\n",
      "utf-8"
    );
  }
  return modified;
}
function sortObject(obj) {
  return Object.keys(obj).sort().reduce(
    (sorted, key) => {
      sorted[key] = obj[key];
      return sorted;
    },
    {}
  );
}
var AUTH_ANCHORS = {
  IMPORTS: {
    type: "auth:imports",
    startMarker: "// <mcp-auth:imports>",
    endMarker: "// </mcp-auth:imports>",
    description: "Auth imports will be added here by add-auth command"
  },
  MIDDLEWARE: {
    type: "auth:middleware",
    startMarker: "// <mcp-auth:middleware>",
    endMarker: "// </mcp-auth:middleware>",
    description: "Auth middleware will be added here by add-auth command"
  },
  CONFIG_VARS: {
    type: "auth:vars",
    startMarker: "// <mcp-auth:vars>",
    endMarker: "// </mcp-auth:vars>",
    description: "Auth environment variables managed by mcp-server-kit"
  }
};
var BINDING_ANCHORS = {
  // Phase 1: KV and D1
  KV: {
    type: "bindings:kv",
    startMarker: "// <mcp-bindings:kv>",
    endMarker: "// </mcp-bindings:kv>",
    description: "KV namespace bindings managed by mcp-server-kit"
  },
  D1: {
    type: "bindings:d1",
    startMarker: "// <mcp-bindings:d1>",
    endMarker: "// </mcp-bindings:d1>",
    description: "D1 database bindings managed by mcp-server-kit"
  },
  IMPORTS: {
    type: "bindings:imports",
    startMarker: "// <mcp-bindings:imports>",
    endMarker: "// </mcp-bindings:imports>",
    description: "Binding helper imports will be added here by add binding command"
  },
  // Phase 2: R2 and Queues (coming soon)
  R2: {
    type: "bindings:r2",
    startMarker: "// <mcp-bindings:r2>",
    endMarker: "// </mcp-bindings:r2>",
    description: "R2 bucket bindings managed by mcp-server-kit"
  },
  QUEUES_PRODUCERS: {
    type: "bindings:queues:producers",
    startMarker: "// <mcp-bindings:queues:producers>",
    endMarker: "// </mcp-bindings:queues:producers>",
    description: "Queue producer bindings managed by mcp-server-kit"
  },
  // Phase 3: Workers AI and Vectorize (coming soon)
  AI: {
    type: "bindings:ai",
    startMarker: "// <mcp-bindings:ai>",
    endMarker: "// </mcp-bindings:ai>",
    description: "Workers AI binding managed by mcp-server-kit"
  },
  VECTORIZE: {
    type: "bindings:vectorize",
    startMarker: "// <mcp-bindings:vectorize>",
    endMarker: "// </mcp-bindings:vectorize>",
    description: "Vectorize index bindings managed by mcp-server-kit"
  },
  // Phase 4: Hyperdrive (coming soon)
  HYPERDRIVE: {
    type: "bindings:hyperdrive",
    startMarker: "// <mcp-bindings:hyperdrive>",
    endMarker: "// </mcp-bindings:hyperdrive>",
    description: "Hyperdrive config bindings managed by mcp-server-kit"
  }
};
var AnchorService = class {
  /**
   * Check if a file contains the specified anchor block
   */
  async hasAnchor(filePath, anchor) {
    if (!existsSync(filePath)) {
      return false;
    }
    const content = await readFile(filePath, "utf-8");
    return content.includes(anchor.startMarker) && content.includes(anchor.endMarker);
  }
  /**
   * Check if an anchor block is empty (ready for content insertion)
   */
  async isAnchorEmpty(filePath, anchor) {
    const content = await readFile(filePath, "utf-8");
    const startIdx = content.indexOf(anchor.startMarker);
    const endIdx = content.indexOf(anchor.endMarker);
    if (startIdx === -1 || endIdx === -1) {
      return false;
    }
    const blockContent = content.slice(
      startIdx + anchor.startMarker.length,
      endIdx
    );
    const trimmed = blockContent.trim();
    return trimmed === "" || trimmed.startsWith("//") || trimmed.startsWith("#");
  }
  /**
   * Insert content at the specified anchor block
   *
   * @param filePath - Path to file to modify
   * @param anchor - Anchor block to insert at
   * @param content - Content to insert
   * @param options - Insertion options
   * @returns Result of the operation
   */
  async insertAtAnchor(filePath, anchor, content, options = {}) {
    if (!existsSync(filePath)) {
      return {
        success: false,
        modified: false,
        error: `File not found: ${filePath}`
      };
    }
    const fileContent = await readFile(filePath, "utf-8");
    const startIdx = fileContent.indexOf(anchor.startMarker);
    const endIdx = fileContent.indexOf(anchor.endMarker);
    if (startIdx === -1 || endIdx === -1) {
      return {
        success: false,
        modified: false,
        error: `Missing anchor block: ${anchor.type}. Expected to find ${anchor.startMarker} and ${anchor.endMarker}`
      };
    }
    const blockContent = fileContent.slice(
      startIdx + anchor.startMarker.length,
      endIdx
    );
    const isEmpty = blockContent.trim() === "" || blockContent.trim().startsWith("//") || blockContent.trim().startsWith("#");
    if (!isEmpty && !options.force) {
      return {
        success: true,
        modified: false,
        warning: `Anchor block ${anchor.type} already has content. Use force=true to overwrite.`
      };
    }
    let insertContent = content;
    if (options.indent) {
      insertContent = content.split("\n").map((line) => line.trim() ? options.indent + line : line).join("\n");
    }
    const before = fileContent.slice(0, startIdx + anchor.startMarker.length);
    const after = fileContent.slice(endIdx);
    const newContent = before + "\n" + insertContent + "\n" + after;
    await writeFile(filePath, newContent, "utf-8");
    return {
      success: true,
      modified: true
    };
  }
  /**
   * Remove content from an anchor block (leave anchors intact)
   */
  async clearAnchor(filePath, anchor) {
    if (!existsSync(filePath)) {
      return {
        success: false,
        modified: false,
        error: `File not found: ${filePath}`
      };
    }
    const fileContent = await readFile(filePath, "utf-8");
    const startIdx = fileContent.indexOf(anchor.startMarker);
    const endIdx = fileContent.indexOf(anchor.endMarker);
    if (startIdx === -1 || endIdx === -1) {
      return {
        success: false,
        modified: false,
        error: `Missing anchor block: ${anchor.type}`
      };
    }
    const before = fileContent.slice(0, startIdx + anchor.startMarker.length);
    const after = fileContent.slice(endIdx);
    const newContent = before + "\n// " + anchor.description + "\n" + after;
    await writeFile(filePath, newContent, "utf-8");
    return {
      success: true,
      modified: true
    };
  }
  /**
   * Insert an anchor block at a specific position in a file
   * (Used when scaffolding new templates)
   */
  async insertAnchorBlock(filePath, anchor, position) {
    if (!existsSync(filePath)) {
      return {
        success: false,
        modified: false,
        error: `File not found: ${filePath}`
      };
    }
    const content = await readFile(filePath, "utf-8");
    if (content.includes(anchor.startMarker)) {
      return {
        success: true,
        modified: false,
        warning: `Anchor block ${anchor.type} already exists`
      };
    }
    const anchorBlock = `
${anchor.startMarker}
// ${anchor.description}
${anchor.endMarker}
`;
    const newContent = content.slice(0, position) + anchorBlock + content.slice(position);
    await writeFile(filePath, newContent, "utf-8");
    return {
      success: true,
      modified: true
    };
  }
  /**
   * Validate that all required anchors are present in a file
   */
  async validateAnchors(filePath, requiredAnchors) {
    if (!existsSync(filePath)) {
      return {
        valid: false,
        missing: requiredAnchors.map((a) => a.type)
      };
    }
    const content = await readFile(filePath, "utf-8");
    const missing = [];
    for (const anchor of requiredAnchors) {
      if (!content.includes(anchor.startMarker) || !content.includes(anchor.endMarker)) {
        missing.push(anchor.type);
      }
    }
    return {
      valid: missing.length === 0,
      missing
    };
  }
};

// src/core/commands/shared/entry-point-transformer.ts
async function addAuthToEntryPoint(filePath, platform) {
  if (!existsSync(filePath)) {
    throw new Error(`Entry point not found: ${filePath}`);
  }
  const content = await readFile(filePath, "utf-8");
  let transformed;
  if (platform === "cloudflare") {
    transformed = await addCloudflareAuth(filePath, content);
  } else if (platform === "vercel") {
    transformed = addVercelAuth(content);
  } else {
    throw new Error(`Unsupported platform: ${platform}`);
  }
  if (transformed !== content) {
    await writeFile(filePath, transformed, "utf-8");
    return true;
  }
  return false;
}
async function addCloudflareAuth(filePath, content) {
  if (content.includes("getAuthProvider") || content.includes("Authorization")) {
    return content;
  }
  const anchorService = new AnchorService();
  const hasImportsAnchor = await anchorService.hasAnchor(
    filePath,
    AUTH_ANCHORS.IMPORTS
  );
  const hasMiddlewareAnchor = await anchorService.hasAnchor(
    filePath,
    AUTH_ANCHORS.MIDDLEWARE
  );
  const authImports = `import { getAuthProvider } from "./auth/config.js";
import { AuthenticationError } from "./auth/types.js";`;
  const authMiddleware = `	// Validate authentication
	const authHeader = request.headers.get("Authorization");
	if (!authHeader) {
		return new Response("Unauthorized: Missing Authorization header", {
			status: 401,
			headers: { "Content-Type": "text/plain" },
		});
	}

	const token = authHeader.replace(/^Bearer\\s+/i, "");
	try {
		const provider = getAuthProvider(env);
		const user = await provider.validateToken(token, env);

		// Attach user context to env for tools to use
		(env as any).user = user;
	} catch (error) {
		if (error instanceof AuthenticationError) {
			return new Response(\`Unauthorized: \${error.message}\`, {
				status: 401,
				headers: { "Content-Type": "text/plain" },
			});
		}
		console.error("Authentication error:", error);
		return new Response("Internal Server Error", {
			status: 500,
			headers: { "Content-Type": "text/plain" },
		});
	}`;
  if (hasImportsAnchor && hasMiddlewareAnchor) {
    const importsResult = await anchorService.insertAtAnchor(
      filePath,
      AUTH_ANCHORS.IMPORTS,
      authImports
    );
    const middlewareResult = await anchorService.insertAtAnchor(
      filePath,
      AUTH_ANCHORS.MIDDLEWARE,
      authMiddleware
    );
    if (importsResult.success && middlewareResult.success) {
      return await readFile(filePath, "utf-8");
    }
    console.warn(
      "Anchor insertion failed, falling back to regex transformation"
    );
  }
  return addCloudflareAuthRegex(content);
}
function addCloudflareAuthRegex(content) {
  const authImports = `import { getAuthProvider } from "./auth/config.js";
import { AuthenticationError } from "./auth/types.js";
`;
  const importRegex = /^import\s+.*?;$/gm;
  let lastImportIndex = 0;
  let match;
  while ((match = importRegex.exec(content)) !== null) {
    lastImportIndex = match.index + match[0].length;
  }
  let result = content;
  if (lastImportIndex > 0) {
    result = content.slice(0, lastImportIndex) + "\n" + authImports + content.slice(lastImportIndex);
  } else {
    result = authImports + "\n" + content;
  }
  const fetchHandlerRegex = /async\s+fetch\s*\(\s*request:\s*Request,\s*env:\s*Env(?:,\s*ctx:\s*ExecutionContext)?\s*\):\s*Promise<Response>\s*\{/;
  const fetchMatch = fetchHandlerRegex.exec(result);
  if (fetchMatch) {
    const insertPosition = fetchMatch.index + fetchMatch[0].length;
    const authMiddleware = `
		// Validate authentication
		const authHeader = request.headers.get("Authorization");
		if (!authHeader) {
			return new Response("Unauthorized: Missing Authorization header", {
				status: 401,
				headers: { "Content-Type": "text/plain" },
			});
		}

		const token = authHeader.replace(/^Bearer\\s+/i, "");
		try {
			const provider = getAuthProvider(env);
			const user = await provider.validateToken(token, env);

			// Attach user context to env for tools to use
			(env as any).user = user;
		} catch (error) {
			if (error instanceof AuthenticationError) {
				return new Response(\`Unauthorized: \${error.message}\`, {
					status: 401,
					headers: { "Content-Type": "text/plain" },
				});
			}
			console.error("Authentication error:", error);
			return new Response("Internal Server Error", {
				status: 500,
				headers: { "Content-Type": "text/plain" },
			});
		}
`;
    result = result.slice(0, insertPosition) + authMiddleware + result.slice(insertPosition);
  }
  return result;
}
function addVercelAuth(content) {
  if (content.includes("getAuthProvider") || content.includes("Authorization")) {
    return content;
  }
  const authImports = `import { getAuthProvider } from "@/auth/config";
import { AuthenticationError } from "@/auth/types";
`;
  const importRegex = /^import\s+.*?;$/gm;
  let lastImportIndex = 0;
  let match;
  while ((match = importRegex.exec(content)) !== null) {
    lastImportIndex = match.index + match[0].length;
  }
  let result = content;
  if (lastImportIndex > 0) {
    result = content.slice(0, lastImportIndex) + "\n" + authImports + content.slice(lastImportIndex);
  } else {
    result = authImports + "\n" + content;
  }
  const postHandlerRegex = /export\s+async\s+function\s+POST\s*\(\s*request:\s*Request\s*\)/;
  const postMatch = postHandlerRegex.exec(result);
  if (postMatch) {
    const insertPosition = postMatch.index + postMatch[0].length;
    const braceMatch = result.slice(insertPosition).match(/\{/);
    if (braceMatch) {
      const bracePosition = insertPosition + braceMatch.index + 1;
      const authMiddleware = `
	// Validate authentication
	const authHeader = request.headers.get("Authorization");
	if (!authHeader) {
		return new Response("Unauthorized: Missing Authorization header", {
			status: 401,
			headers: { "Content-Type": "text/plain" },
		});
	}

	const token = authHeader.replace(/^Bearer\\s+/i, "");
	try {
		const provider = getAuthProvider(process.env as any);
		const user = await provider.validateToken(token, process.env as any);

		// User context available for tools (would need to pass through adapter)
		// For now, validation is the primary goal
	} catch (error) {
		if (error instanceof AuthenticationError) {
			return new Response(\`Unauthorized: \${error.message}\`, {
				status: 401,
				headers: { "Content-Type": "text/plain" },
			});
		}
		console.error("Authentication error:", error);
		return new Response("Internal Server Error", {
			status: 500,
			headers: { "Content-Type": "text/plain" },
		});
	}
`;
      result = result.slice(0, bracePosition) + authMiddleware + result.slice(bracePosition);
    }
  }
  return result;
}
async function hasAuthentication(filePath) {
  if (!existsSync(filePath)) {
    return false;
  }
  const anchorService = new AnchorService();
  const hasAnchors = await anchorService.hasAnchor(filePath, AUTH_ANCHORS.IMPORTS) && await anchorService.hasAnchor(filePath, AUTH_ANCHORS.MIDDLEWARE);
  if (hasAnchors) {
    const importsEmpty = await anchorService.isAnchorEmpty(
      filePath,
      AUTH_ANCHORS.IMPORTS
    );
    const middlewareEmpty = await anchorService.isAnchorEmpty(
      filePath,
      AUTH_ANCHORS.MIDDLEWARE
    );
    return !importsEmpty && !middlewareEmpty;
  }
  const content = await readFile(filePath, "utf-8");
  return content.includes("getAuthProvider") && (content.includes("Validate authentication") || content.includes("Authorization"));
}
var TomlMerger = class {
  /**
   * Merge values into a TOML section
   *
   * @param filePath - Path to TOML file
   * @param section - Section name (e.g., "vars", "env")
   * @param updates - Key-value pairs to merge
   * @param options - Merge options
   * @returns Result of the merge operation
   */
  async mergeSection(filePath, section, updates, options = {}) {
    if (!existsSync(filePath)) {
      return {
        success: false,
        modified: false,
        error: `File not found: ${filePath}`
      };
    }
    try {
      const content = await readFile(filePath, "utf-8");
      const config = TOML.parse(content);
      if (!config[section]) {
        config[section] = {};
      }
      let modified = false;
      for (const [key, value] of Object.entries(updates)) {
        if (!(key in config[section]) || options.overwrite) {
          config[section][key] = value;
          modified = true;
        }
      }
      if (modified) {
        const newContent = TOML.stringify(config);
        await writeFile(filePath, newContent, "utf-8");
      }
      return {
        success: true,
        modified
      };
    } catch (error) {
      return {
        success: false,
        modified: false,
        error: `TOML parse error: ${error}`
      };
    }
  }
  /**
   * Remove specific keys from a TOML section
   *
   * @param filePath - Path to TOML file
   * @param section - Section name
   * @param keys - Keys to remove
   * @returns Result of the operation
   */
  async removeKeys(filePath, section, keys) {
    if (!existsSync(filePath)) {
      return {
        success: false,
        modified: false,
        error: `File not found: ${filePath}`
      };
    }
    try {
      const content = await readFile(filePath, "utf-8");
      const config = TOML.parse(content);
      if (!config[section]) {
        return {
          success: true,
          modified: false
        };
      }
      let modified = false;
      for (const key of keys) {
        if (key in config[section]) {
          delete config[section][key];
          modified = true;
        }
      }
      if (modified) {
        if (Object.keys(config[section]).length === 0) {
          delete config[section];
        }
        const newContent = TOML.stringify(config);
        await writeFile(filePath, newContent, "utf-8");
      }
      return {
        success: true,
        modified
      };
    } catch (error) {
      return {
        success: false,
        modified: false,
        error: `TOML parse error: ${error}`
      };
    }
  }
  /**
   * Check if specific keys exist in a TOML section
   *
   * @param filePath - Path to TOML file
   * @param section - Section name
   * @param keys - Keys to check
   * @returns Map of key existence
   */
  async hasKeys(filePath, section, keys) {
    if (!existsSync(filePath)) {
      return Object.fromEntries(keys.map((k) => [k, false]));
    }
    try {
      const content = await readFile(filePath, "utf-8");
      const config = TOML.parse(content);
      if (!config[section]) {
        return Object.fromEntries(keys.map((k) => [k, false]));
      }
      return Object.fromEntries(keys.map((k) => [k, k in config[section]]));
    } catch (error) {
      return Object.fromEntries(keys.map((k) => [k, false]));
    }
  }
  /**
   * Get value from TOML section
   *
   * @param filePath - Path to TOML file
   * @param section - Section name
   * @param key - Key to retrieve
   * @returns Value or undefined if not found
   */
  async getValue(filePath, section, key) {
    if (!existsSync(filePath)) {
      return void 0;
    }
    try {
      const content = await readFile(filePath, "utf-8");
      const config = TOML.parse(content);
      return config[section]?.[key];
    } catch (error) {
      return void 0;
    }
  }
};

// src/core/commands/shared/config/auth-config-updater.ts
function getRequiredEnvVars(provider) {
  switch (provider) {
    case "stytch":
      return ["STYTCH_PROJECT_ID", "STYTCH_SECRET", "STYTCH_ENV"];
    case "auth0":
      return [
        "AUTH0_DOMAIN",
        "AUTH0_CLIENT_ID",
        "AUTH0_CLIENT_SECRET",
        "AUTH0_AUDIENCE"
      ];
    case "workos":
      return ["WORKOS_API_KEY", "WORKOS_CLIENT_ID"];
  }
}
async function updateWranglerToml(wranglerPath, provider) {
  if (!existsSync(wranglerPath)) {
    return false;
  }
  const tomlMerger = new TomlMerger();
  const requiredVars = getRequiredEnvVars(provider);
  const existingKeys = await tomlMerger.hasKeys(
    wranglerPath,
    "vars",
    requiredVars
  );
  if (Object.values(existingKeys).some((exists) => exists)) {
    return false;
  }
  const updates = {};
  for (const varName of requiredVars) {
    updates[varName] = "";
  }
  const result = await tomlMerger.mergeSection(wranglerPath, "vars", updates);
  return result.modified;
}
async function updateWranglerJsonc(wranglerPath, provider) {
  if (!existsSync(wranglerPath)) {
    return false;
  }
  const content = await readFile(wranglerPath, "utf-8");
  const config = parseJSONC(content);
  const requiredVars = getRequiredEnvVars(provider);
  if (config.vars && requiredVars.some((v) => config.vars[v] !== void 0)) {
    return false;
  }
  const anchorService = new AnchorService();
  const hasAnchor = await anchorService.hasAnchor(
    wranglerPath,
    AUTH_ANCHORS.CONFIG_VARS
  );
  if (!hasAnchor) {
    if (!config.vars) {
      config.vars = {};
    }
    for (const varName of requiredVars) {
      config.vars[varName] = "";
    }
    await writeFile(wranglerPath, formatJSON(config) + "\n", "utf-8");
    return true;
  }
  const varsEntries = requiredVars.map((varName) => `		"${varName}": ""`).join(",\n");
  const varsJson = `"vars": {
${varsEntries}
	},`;
  const result = await anchorService.insertAtAnchor(
    wranglerPath,
    AUTH_ANCHORS.CONFIG_VARS,
    varsJson,
    { indent: "	" }
  );
  return result.modified;
}
async function updateWranglerConfig(cwd, provider) {
  const wranglerPath = getWranglerConfigPath(cwd);
  if (!wranglerPath) {
    return false;
  }
  if (wranglerPath.endsWith(".toml")) {
    return updateWranglerToml(wranglerPath, provider);
  } else {
    return updateWranglerJsonc(wranglerPath, provider);
  }
}
async function updateVercelConfig(cwd, provider) {
  const vercelPath = join(cwd, "vercel.json");
  const requiredVars = getRequiredEnvVars(provider);
  let config = {};
  if (existsSync(vercelPath)) {
    const content = await readFile(vercelPath, "utf-8");
    config = JSON.parse(content);
    if (config.env && requiredVars.some((v) => config.env[v] !== void 0)) {
      return false;
    }
  }
  config.env = config.env || {};
  for (const varName of requiredVars) {
    config.env[varName] = `@${varName.toLowerCase()}`;
  }
  await writeFile(vercelPath, JSON.stringify(config, null, 2) + "\n", "utf-8");
  return true;
}
async function updateEnvExample(cwd, provider, content) {
  const envPath = join(cwd, ".env.example");
  if (existsSync(envPath)) {
    const existing = await readFile(envPath, "utf-8");
    const requiredVars = getRequiredEnvVars(provider);
    if (requiredVars.some((v) => existing.includes(v))) {
      return false;
    }
    await writeFile(envPath, existing + "\n" + content, "utf-8");
  } else {
    await writeFile(envPath, content, "utf-8");
  }
  return true;
}
var execAsync = promisify(exec);
var ValidationGate = class {
  anchorService;
  constructor() {
    this.anchorService = new AnchorService();
  }
  /**
   * Run full validation gate after auth transformation
   */
  async validate(options) {
    const checks = await this.buildChecks(options);
    const result = {
      passed: true,
      passedChecks: [],
      failedChecks: [],
      rolledBack: false,
      errors: []
    };
    for (const check of checks) {
      try {
        const passed = await check.validate();
        if (passed) {
          result.passedChecks.push(check.name);
        } else {
          result.failedChecks.push(check.name);
          result.errors.push(`${check.name}: ${check.errorMessage}`);
          if (check.critical) {
            result.passed = false;
          }
        }
      } catch (error) {
        result.failedChecks.push(check.name);
        result.errors.push(`${check.name}: ${error}`);
        if (check.critical) {
          result.passed = false;
        }
      }
    }
    if (!result.passed && options.rollbackOnFailure && options.backupDir) {
      try {
        await restoreFromBackup(options.backupDir, options.cwd);
        result.rolledBack = true;
      } catch (error) {
        result.errors.push(`Rollback failed: ${error}`);
      }
    }
    return result;
  }
  /**
   * Build list of validation checks
   */
  async buildChecks(options) {
    const checks = [];
    if (!options.skipTypeCheck) {
      checks.push({
        name: "type-check",
        description: "TypeScript compilation",
        validate: async () => {
          try {
            await execAsync("npx tsc --noEmit", { cwd: options.cwd });
            return true;
          } catch (error) {
            return false;
          }
        },
        errorMessage: "TypeScript compilation failed. Auth transformation may have introduced type errors.",
        critical: true
      });
    }
    checks.push({
      name: "export-invariants",
      description: "Export handler integrity",
      validate: async () => {
        const indexPath = join(options.cwd, "src/index.ts");
        if (!existsSync(indexPath)) return false;
        const content = await readFile(indexPath, "utf-8");
        return content.includes("export default") && content.includes("async fetch");
      },
      errorMessage: "Export handler missing or malformed after transformation",
      critical: true
    });
    checks.push({
      name: "anchors-present",
      description: "Anchor blocks exist",
      validate: async () => {
        const indexPath = join(options.cwd, "src/index.ts");
        const validation = await this.anchorService.validateAnchors(indexPath, [
          AUTH_ANCHORS.IMPORTS,
          AUTH_ANCHORS.MIDDLEWARE
        ]);
        return validation.valid;
      },
      errorMessage: "Required anchor blocks missing. Template may not be compatible with add-auth command.",
      critical: false
      // Warning only
    });
    checks.push({
      name: "auth-imports",
      description: "Auth imports added",
      validate: async () => {
        const indexPath = join(options.cwd, "src/index.ts");
        if (!existsSync(indexPath)) return false;
        const content = await readFile(indexPath, "utf-8");
        return content.includes("getAuthProvider") && content.includes("AuthenticationError");
      },
      errorMessage: "Auth imports not properly added to index.ts",
      critical: true
    });
    checks.push({
      name: "auth-middleware",
      description: "Auth middleware added",
      validate: async () => {
        const indexPath = join(options.cwd, "src/index.ts");
        if (!existsSync(indexPath)) return false;
        const content = await readFile(indexPath, "utf-8");
        return content.includes("Authorization") && content.includes("validateToken");
      },
      errorMessage: "Auth middleware not properly added to fetch handler",
      critical: true
    });
    if (options.provider) {
      checks.push({
        name: "config-vars",
        description: "Auth config variables",
        validate: async () => {
          const wranglerPath = getWranglerConfigPath(options.cwd);
          if (!wranglerPath) return false;
          const content = await readFile(wranglerPath, "utf-8");
          if (options.provider === "stytch") {
            return content.includes("STYTCH_PROJECT_ID") && content.includes("STYTCH_SECRET");
          } else if (options.provider === "auth0") {
            return content.includes("AUTH0_DOMAIN") && content.includes("AUTH0_CLIENT_ID");
          } else if (options.provider === "workos") {
            return content.includes("WORKOS_API_KEY") && content.includes("WORKOS_CLIENT_ID");
          }
          return true;
        },
        errorMessage: "Auth environment variables not added to config",
        critical: true
      });
    }
    checks.push({
      name: "auth-files-exist",
      description: "Auth files created",
      validate: async () => {
        const authDir = join(options.cwd, "src/auth");
        const requiredFiles = ["config.ts", "types.ts"];
        if (options.provider) {
          requiredFiles.push(`providers/${options.provider}.ts`);
        }
        return requiredFiles.every((f) => existsSync(join(authDir, f)));
      },
      errorMessage: "Required auth files missing",
      critical: true
    });
    checks.push({
      name: "no-duplicate-imports",
      description: "No duplicate imports",
      validate: async () => {
        const indexPath = join(options.cwd, "src/index.ts");
        if (!existsSync(indexPath)) return false;
        const content = await readFile(indexPath, "utf-8");
        const importLines = content.split("\n").filter((l) => l.trim().startsWith("import"));
        const authImports = importLines.filter(
          (l) => l.includes("getAuthProvider") || l.includes("AuthenticationError")
        );
        return authImports.length <= 2;
      },
      errorMessage: "Duplicate imports detected (transformation may have run twice)",
      critical: false
    });
    return checks;
  }
  /**
   * Run a quick validation (skips type check)
   */
  async quickValidate(options) {
    return this.validate({
      ...options,
      skipTypeCheck: true,
      rollbackOnFailure: false
    });
  }
  /**
   * Run only critical checks
   */
  async validateCritical(options) {
    const allChecks = await this.buildChecks(options);
    const criticalChecks = allChecks.filter((c) => c.critical);
    const result = {
      passed: true,
      passedChecks: [],
      failedChecks: [],
      rolledBack: false,
      errors: []
    };
    for (const check of criticalChecks) {
      try {
        const passed = await check.validate();
        if (passed) {
          result.passedChecks.push(check.name);
        } else {
          result.failedChecks.push(check.name);
          result.errors.push(`${check.name}: ${check.errorMessage}`);
          result.passed = false;
        }
      } catch (error) {
        result.failedChecks.push(check.name);
        result.errors.push(`${check.name}: ${error}`);
        result.passed = false;
      }
    }
    return result;
  }
};

// src/core/commands/shared/strategies/auth-scaffold-strategy.ts
var AuthScaffoldStrategy = class {
  /**
   * Validate project structure and auth configuration
   */
  async validate(cwd, config) {
    if (!existsSync(join(cwd, "package.json"))) {
      throw new Error("No package.json found. Is this an MCP project?");
    }
    if (!existsSync(join(cwd, "src"))) {
      throw new Error("No src directory found. Is this an MCP project?");
    }
    const detectedPlatform = config.platform || await detectPlatform(cwd);
    if (detectedPlatform === "unknown") {
      throw new Error(
        "Could not detect platform. Please specify --platform cloudflare or --platform vercel"
      );
    }
    config.platform = detectedPlatform;
    const entryPoint = getEntryPointPath(cwd, config.platform);
    if (existsSync(entryPoint) && await hasAuthentication(entryPoint)) {
      if (!config.force) {
        throw new Error(
          "Authentication is already configured. Use --force to overwrite."
        );
      }
    }
  }
  /**
   * Execute auth scaffolding
   *
   * 1. Create auth directory structure
   * 2. Generate auth files
   * 3. Add dependencies
   * 4. Transform entry point
   * 5. Update config files
   * 6. Validate transformations
   */
  async execute(context) {
    const { cwd, config, result } = context;
    const { provider, platform } = config;
    const confirmedPlatform = platform;
    result.platform = confirmedPlatform;
    if (config.force) {
      result.warnings?.push("Overwriting existing authentication configuration");
    }
    const authDir = join(cwd, "src/auth");
    await mkdir(authDir, { recursive: true });
    await mkdir(join(authDir, "providers"), { recursive: true });
    await this.generateAuthFiles(cwd, provider, result);
    await this.addDependencies(cwd, provider, confirmedPlatform, result);
    await this.transformEntryPoint(cwd, confirmedPlatform, result);
    await this.updateConfigFiles(cwd, provider, confirmedPlatform, result);
    await this.validateTransformations(cwd, provider, context.backupDir, result);
    result.success = true;
  }
  /**
   * Auth needs backup (modifies config files)
   */
  needsBackup() {
    return true;
  }
  /**
   * Create initial result object
   */
  createResult() {
    return {
      success: false,
      provider: "",
      // Will be set by config
      platform: "unknown",
      filesCreated: [],
      filesModified: [],
      warnings: []
    };
  }
  /**
   * Generate authentication files
   */
  async generateAuthFiles(cwd, provider, result) {
    const authDir = join(cwd, "src/auth");
    const typesPath = join(authDir, "types.ts");
    await writeFile(typesPath, generateAuthTypesTemplate());
    result.filesCreated.push(typesPath);
    const configPath = join(authDir, "config.ts");
    await writeFile(configPath, generateAuthConfigTemplate(provider));
    result.filesCreated.push(configPath);
    const providerPath = join(authDir, `providers/${provider}.ts`);
    let providerTemplate;
    switch (provider) {
      case "stytch":
        providerTemplate = generateStytchProviderTemplate();
        break;
      case "auth0":
        providerTemplate = generateAuth0ProviderTemplate();
        break;
      case "workos":
        providerTemplate = generateWorkOSProviderTemplate();
        break;
    }
    await writeFile(providerPath, providerTemplate);
    result.filesCreated.push(providerPath);
    result.provider = provider;
  }
  /**
   * Add authentication dependencies
   */
  async addDependencies(cwd, provider, platform, result) {
    const deps = getAuthDependencies(provider, platform);
    const modified = await addDependenciesToPackageJson(cwd, deps);
    if (modified) {
      result.filesModified.push(join(cwd, "package.json"));
    }
  }
  /**
   * Transform entry point to add authentication
   */
  async transformEntryPoint(cwd, platform, result) {
    const entryPoint = getEntryPointPath(cwd, platform);
    if (!existsSync(entryPoint)) {
      throw new Error(`Entry point not found: ${entryPoint}`);
    }
    const modified = await addAuthToEntryPoint(entryPoint, platform);
    if (modified) {
      result.filesModified.push(entryPoint);
    }
  }
  /**
   * Update platform-specific config files
   */
  async updateConfigFiles(cwd, provider, platform, result) {
    if (platform === "cloudflare") {
      const modified2 = await updateWranglerConfig(cwd, provider);
      if (modified2) {
        const wranglerPath = getWranglerConfigPath(cwd);
        if (wranglerPath) {
          result.filesModified.push(wranglerPath);
        }
      }
    } else if (platform === "vercel") {
      const modified2 = await updateVercelConfig(cwd, provider);
      if (modified2) {
        const vercelPath = join(cwd, "vercel.json");
        if (result.filesCreated.includes(vercelPath)) ; else if (existsSync(vercelPath)) {
          result.filesModified.push(vercelPath);
        } else {
          result.filesCreated.push(vercelPath);
        }
      }
    }
    const envContent = generateEnvExampleTemplate(provider);
    const modified = await updateEnvExample(cwd, provider, envContent);
    if (modified) {
      const envPath = join(cwd, ".env.example");
      if (existsSync(envPath)) {
        result.filesModified.push(envPath);
      } else {
        result.filesCreated.push(envPath);
      }
    }
  }
  /**
   * Validate all transformations were successful
   */
  async validateTransformations(cwd, provider, backupDir, result) {
    const validationGate = new ValidationGate();
    const validationResult = await validationGate.quickValidate({
      cwd,
      backupDir,
      provider,
      rollbackOnFailure: false
      // Orchestrator handles rollback
    });
    if (!validationResult.passed) {
      const errorMessage = [
        "Auth transformation validation failed:",
        ...validationResult.errors
      ].join("\n  - ");
      throw new Error(errorMessage);
    }
    if (validationResult.passedChecks.length > 0) {
      result.warnings?.push(
        `\u2713 Validation passed: ${validationResult.passedChecks.join(", ")}`
      );
    }
  }
};

// src/core/commands/shared/auth-scaffolder.ts
var AuthScaffolder = class {
  orchestrator;
  strategy;
  constructor() {
    this.orchestrator = new ScaffoldOrchestrator();
    this.strategy = new AuthScaffoldStrategy();
  }
  /**
   * Add authentication to an MCP server project
   */
  async addAuth(options) {
    const cwd = options.cwd || process.cwd();
    const dryRun = options.dryRun || false;
    const skipBackup = options.backup === false;
    const config = {
      provider: options.provider,
      platform: options.platform,
      cwd,
      force: options.force
    };
    if (dryRun) {
      const result = this.strategy.createResult();
      result.provider = options.provider;
      result.warnings?.push("DRY RUN: No changes will be made");
      try {
        await this.strategy.validate(cwd, config);
        result.platform = config.platform || "unknown";
        result.success = true;
      } catch (error) {
        result.error = error instanceof Error ? error.message : String(error);
      }
      return result;
    }
    try {
      return await this.orchestrator.scaffold(cwd, config, this.strategy, {
        skipBackup,
        dryRun: false
      });
    } catch (error) {
      const result = this.strategy.createResult();
      result.provider = options.provider;
      result.platform = config.platform || "unknown";
      result.error = error instanceof Error ? error.message : String(error);
      return result;
    }
  }
};

// src/core/commands/add-auth.ts
async function addAuth(options) {
  const scaffolder = new AuthScaffolder();
  const scaffoldOptions = {
    provider: options.provider,
    platform: options.platform,
    force: options.force,
    dryRun: options.dryRun,
    backup: options.backup,
    cwd: options.cwd
  };
  const result = await scaffolder.addAuth(scaffoldOptions);
  if (options.json) {
    console.log(JSON.stringify(result, null, 2));
  } else {
    printHumanReadableResult(result);
  }
  return result;
}
function printHumanReadableResult(result) {
  if (result.success) {
    console.log("\n\u2705 Authentication added successfully!\n");
    console.log(`Provider: ${result.provider}`);
    console.log(`Platform: ${result.platform}
`);
    if (result.filesCreated.length > 0) {
      console.log("Files created:");
      for (const file of result.filesCreated) {
        console.log(`  + ${file}`);
      }
      console.log();
    }
    if (result.filesModified.length > 0) {
      console.log("Files modified:");
      for (const file of result.filesModified) {
        console.log(`  ~ ${file}`);
      }
      console.log();
    }
    if (result.warnings && result.warnings.length > 0) {
      console.log("\u26A0\uFE0F  Warnings:");
      for (const warning of result.warnings) {
        console.log(`  ${warning}`);
      }
      console.log();
    }
    console.log("Next steps:");
    console.log("  1. Run 'npm install' to install auth dependencies");
    console.log("  2. Update .env with your auth provider credentials");
    if (result.platform === "cloudflare") {
      console.log("  3. Run 'npm run cf-typegen' to update types");
      console.log("  4. Test locally with 'npm run dev'");
    } else {
      console.log("  3. Configure Vercel environment variables");
      console.log("  4. Test locally with 'npm run dev'");
    }
    console.log();
  } else {
    console.error("\n\u274C Failed to add authentication\n");
    console.error(`Error: ${result.error}
`);
    if (result.warnings && result.warnings.length > 0) {
      console.error("Warnings:");
      for (const warning of result.warnings) {
        console.error(`  ${warning}`);
      }
      console.error();
    }
    if (result.backupDir) {
      console.error(`Backup preserved at: ${result.backupDir}`);
      console.error("You can manually restore from this backup if needed.\n");
    }
    process.exit(1);
  }
}
function validateAddAuthOptions(options) {
  if (!options.provider) {
    throw new Error(
      "Provider is required. Use --provider stytch, --provider auth0, or --provider workos"
    );
  }
  const validProviders = ["stytch", "auth0", "workos"];
  if (!validProviders.includes(options.provider)) {
    throw new Error(
      `Invalid provider: ${options.provider}. Must be one of: ${validProviders.join(", ")}`
    );
  }
  if (options.platform && !["cloudflare", "vercel"].includes(options.platform)) {
    throw new Error(
      `Invalid platform: ${options.platform}. Must be cloudflare or vercel`
    );
  }
}
function createAddAuthCommand() {
  const command = new Command("auth").description("Add authentication to your MCP server").requiredOption(
    "--provider <provider>",
    "Auth provider: stytch, auth0, or workos"
  ).option(
    "--platform <platform>",
    "Platform: cloudflare or vercel (auto-detected if not specified)"
  ).option("--force", "Overwrite existing authentication configuration").option("--dry-run", "Show what would be done without making changes").option("--no-backup", "Skip creating backup before modifications").option("--json", "Output result as JSON").action(async (options) => {
    try {
      validateAddAuthOptions(options);
      await addAuth(options);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (options.json) {
        const result = {
          success: false,
          provider: options.provider || "unknown",
          platform: "unknown",
          filesCreated: [],
          filesModified: [],
          error: errorMessage
        };
        console.log(JSON.stringify(result, null, 2));
      } else {
        console.error(`
\u274C Error: ${errorMessage}
`);
      }
      process.exit(1);
    }
  });
  return command;
}

// src/types/binding-types.ts
function isPhase1Binding(type) {
  return type === "kv" || type === "d1" || type === "r2";
}
function getWranglerKey(type) {
  const keys = {
    kv: "kv_namespaces",
    d1: "d1_databases",
    r2: "r2_buckets",
    queues: "queues",
    ai: "ai",
    vectorize: "vectorize",
    hyperdrive: "hyperdrive"
  };
  return keys[type];
}
var BindingValidator = class {
  anchorService = new AnchorService();
  /**
   * Validate binding configuration before scaffolding
   *
   * @throws {Error} If validation fails
   */
  async validateBindingConfig(cwd, config, options = {}) {
    const {
      checkDuplicates = true,
      checkAnchors = true,
      checkProjectStructure = true
    } = options;
    const errors = [];
    if (checkProjectStructure) {
      const structureErrors = await this.validateProjectStructure(cwd);
      errors.push(...structureErrors);
    }
    const nameError = this.validateBindingName(config.bindingName);
    if (nameError) {
      errors.push(nameError);
    }
    const typeError = this.validateBindingType(config.bindingType);
    if (typeError) {
      errors.push(typeError);
    }
    const specificErrors = this.validateBindingSpecific(config);
    errors.push(...specificErrors);
    if (checkDuplicates) {
      const duplicateError = await this.validateNoDuplicateBinding(cwd, config);
      if (duplicateError) {
        errors.push(duplicateError);
      }
    }
    if (checkAnchors) {
      const anchorErrors = await this.validateAnchorsExist(cwd, config);
      errors.push(...anchorErrors);
    }
    if (errors.length > 0) {
      const errorMessages = errors.map((e) => {
        let msg = e.message;
        if (e.field) msg = `${e.field}: ${msg}`;
        if (e.suggestion) msg += ` (${e.suggestion})`;
        return msg;
      });
      throw new Error(
        `Binding validation failed:
${errorMessages.map((m) => `  - ${m}`).join("\n")}`
      );
    }
  }
  /**
   * Validate project has required structure
   */
  async validateProjectStructure(cwd) {
    const errors = [];
    const wranglerPath = join(cwd, "wrangler.jsonc");
    if (!existsSync(wranglerPath)) {
      errors.push({
        message: "wrangler.jsonc not found",
        field: "project",
        suggestion: "This command must be run from a Cloudflare Workers MCP server project"
      });
    }
    const packagePath = join(cwd, "package.json");
    if (!existsSync(packagePath)) {
      errors.push({
        message: "package.json not found",
        field: "project",
        suggestion: "This command must be run from an MCP server project"
      });
    }
    const srcPath = join(cwd, "src");
    if (!existsSync(srcPath)) {
      errors.push({
        message: "src directory not found",
        field: "project",
        suggestion: "This command must be run from an MCP server project"
      });
    }
    return errors;
  }
  /**
   * Validate binding name format
   *
   * Binding names must be uppercase with underscores (UPPER_SNAKE_CASE)
   * Examples: MY_CACHE, USER_DATA, PRODUCT_DB
   */
  validateBindingName(name) {
    if (!/^[A-Z]/.test(name)) {
      return {
        message: "Binding name must start with an uppercase letter",
        field: "bindingName",
        suggestion: `Use UPPER_SNAKE_CASE format (e.g., ${name.toUpperCase()})`
      };
    }
    if (!/^[A-Z][A-Z0-9_]*$/.test(name)) {
      return {
        message: "Binding name must only contain uppercase letters, numbers, and underscores",
        field: "bindingName",
        suggestion: "Use UPPER_SNAKE_CASE format (e.g., MY_CACHE, USER_DATA)"
      };
    }
    if (name.endsWith("_")) {
      return {
        message: "Binding name cannot end with an underscore",
        field: "bindingName",
        suggestion: `Remove trailing underscore: ${name.slice(0, -1)}`
      };
    }
    if (name.includes("__")) {
      return {
        message: "Binding name cannot have consecutive underscores",
        field: "bindingName",
        suggestion: "Use single underscores to separate words"
      };
    }
    return null;
  }
  /**
   * Validate binding type is supported
   */
  validateBindingType(type) {
    const supportedTypes = [
      "kv",
      "d1",
      "r2",
      "queues",
      "ai",
      "vectorize",
      "hyperdrive"
    ];
    if (!supportedTypes.includes(type)) {
      return {
        message: `Unsupported binding type: ${type}`,
        field: "bindingType",
        suggestion: `Supported types: ${supportedTypes.join(", ")}`
      };
    }
    if (!isPhase1Binding(type)) {
      return {
        message: `Binding type '${type}' is not yet implemented`,
        field: "bindingType",
        suggestion: "Phase 1 supports: kv, d1"
      };
    }
    return null;
  }
  /**
   * Validate binding-specific requirements
   */
  validateBindingSpecific(config) {
    const errors = [];
    if (config.bindingType === "d1") {
      if (config.databaseName && !/^[a-z0-9-]+$/.test(config.databaseName)) {
        errors.push({
          message: "D1 database name must be lowercase with hyphens only",
          field: "databaseName",
          suggestion: "Use lowercase letters, numbers, and hyphens (e.g., my-database)"
        });
      }
    }
    if (config.bindingType === "r2") {
      if (config.bucketName && !/^[a-z0-9-]+$/.test(config.bucketName)) {
        errors.push({
          message: "R2 bucket name must be lowercase with hyphens only",
          field: "bucketName",
          suggestion: "Use lowercase letters, numbers, and hyphens (e.g., my-bucket)"
        });
      }
    }
    return errors;
  }
  /**
   * Check if binding already exists in wrangler.jsonc
   */
  async validateNoDuplicateBinding(cwd, config) {
    const wranglerPath = join(cwd, "wrangler.jsonc");
    try {
      const content = await readFile(wranglerPath, "utf-8");
      const jsonContent = content.replace(/\/\/.*$/gm, "");
      const wranglerConfig = JSON.parse(jsonContent);
      const key = getWranglerKey(config.bindingType);
      let bindingExists = false;
      if (config.bindingType === "kv") {
        const kvBindings = wranglerConfig.kv_namespaces || [];
        bindingExists = kvBindings.some(
          (b) => b.binding === config.bindingName
        );
      } else if (config.bindingType === "d1") {
        const d1Bindings = wranglerConfig.d1_databases || [];
        bindingExists = d1Bindings.some(
          (b) => b.binding === config.bindingName
        );
      } else if (config.bindingType === "r2") {
        const r2Bindings = wranglerConfig.r2_buckets || [];
        bindingExists = r2Bindings.some(
          (b) => b.binding === config.bindingName
        );
      } else if (config.bindingType === "ai") {
        bindingExists = wranglerConfig.ai?.binding === config.bindingName;
      } else if (config.bindingType === "vectorize") {
        const vectorizeBindings = wranglerConfig.vectorize || [];
        bindingExists = vectorizeBindings.some(
          (b) => b.binding === config.bindingName
        );
      } else if (config.bindingType === "hyperdrive") {
        const hyperdriveBindings = wranglerConfig.hyperdrive || [];
        bindingExists = hyperdriveBindings.some(
          (b) => b.binding === config.bindingName
        );
      }
      if (bindingExists) {
        return {
          message: `Binding '${config.bindingName}' already exists in wrangler.jsonc`,
          field: "bindingName",
          suggestion: "Choose a different binding name or remove the existing one"
        };
      }
    } catch (error) {
      if (error.message?.includes("JSON")) {
        return {
          message: "Failed to parse wrangler.jsonc",
          field: "wrangler",
          suggestion: "Ensure wrangler.jsonc is valid JSONC format before adding bindings"
        };
      }
    }
    return null;
  }
  /**
   * Validate required anchor blocks exist
   */
  async validateAnchorsExist(cwd, config) {
    const errors = [];
    const wranglerPath = join(cwd, "wrangler.jsonc");
    const bindingAnchor = this.getBindingAnchor(config.bindingType);
    if (bindingAnchor) {
      const hasWranglerAnchor = await this.anchorService.hasAnchor(wranglerPath, bindingAnchor);
      if (!hasWranglerAnchor) {
        errors.push({
          message: `Missing anchor block in wrangler.jsonc: ${bindingAnchor.type}`,
          field: "anchors",
          suggestion: "Your project may be outdated. Re-scaffold with latest template or add anchor manually"
        });
      }
    }
    const indexPath = join(cwd, "src", "index.ts");
    const hasImportsAnchor = await this.anchorService.hasAnchor(
      indexPath,
      BINDING_ANCHORS.IMPORTS
    );
    if (!hasImportsAnchor) {
      errors.push({
        message: `Missing anchor block in src/index.ts: ${BINDING_ANCHORS.IMPORTS.type}`,
        field: "anchors",
        suggestion: "Your project may be outdated. Re-scaffold with latest template or add anchor manually"
      });
    }
    return errors;
  }
  /**
   * Get the anchor block for a binding type
   */
  getBindingAnchor(type) {
    switch (type) {
      case "kv":
        return BINDING_ANCHORS.KV;
      case "d1":
        return BINDING_ANCHORS.D1;
      case "r2":
        return BINDING_ANCHORS.R2;
      case "queues":
        return BINDING_ANCHORS.QUEUES_PRODUCERS;
      case "ai":
        return BINDING_ANCHORS.AI;
      case "vectorize":
        return BINDING_ANCHORS.VECTORIZE;
      case "hyperdrive":
        return BINDING_ANCHORS.HYPERDRIVE;
      default:
        return null;
    }
  }
};
var BindingTemplateService = class {
  templateCache = /* @__PURE__ */ new Map();
  templatesDir;
  constructor() {
    const __filename2 = fileURLToPath(import.meta.url);
    const __dirname2 = dirname(__filename2);
    let currentDir = __dirname2;
    let templatesPath = "";
    for (let i = 0; i < 5; i++) {
      const candidatePath = join(currentDir, "templates/scaffolding/bindings");
      try {
        if (statSync(candidatePath).isDirectory()) {
          templatesPath = candidatePath;
          break;
        }
      } catch {
      }
      currentDir = dirname(currentDir);
    }
    if (!templatesPath) {
      throw new Error(
        `Could not locate templates/scaffolding/bindings directory. Searched from: ${__dirname2}`
      );
    }
    this.templatesDir = templatesPath;
  }
  /**
   * Load and compile a Handlebars template
   *
   * @param templatePath - Path to template file relative to templates/scaffolding/bindings/
   * @returns Compiled Handlebars template
   */
  loadTemplate(templatePath) {
    if (this.templateCache.has(templatePath)) {
      return this.templateCache.get(templatePath);
    }
    const fullPath = join(this.templatesDir, templatePath);
    const templateContent = readFileSync(fullPath, "utf-8");
    const compiled = Handlebars.compile(templateContent, { noEscape: true });
    this.templateCache.set(templatePath, compiled);
    return compiled;
  }
  /**
   * Generate KV helper file content
   *
   * @param vars - Template variables
   * @returns Generated TypeScript code
   */
  generateKVHelper(vars) {
    const template = this.loadTemplate("kv-helper.hbs");
    return template(vars);
  }
  /**
   * Generate D1 helper file content
   *
   * @param vars - Template variables
   * @returns Generated TypeScript code
   */
  generateD1Helper(vars) {
    const template = this.loadTemplate("d1-helper.hbs");
    return template(vars);
  }
  /**
   * Generate R2 helper file content
   *
   * @param vars - Template variables
   * @returns Generated TypeScript code
   */
  generateR2Helper(vars) {
    const template = this.loadTemplate("r2-helper.hbs");
    return template(vars);
  }
  /**
   * Generate helper file content based on binding type
   *
   * @param bindingType - Type of binding (kv, d1)
   * @param vars - Template variables
   * @returns Generated TypeScript code
   */
  generateHelper(bindingType, vars) {
    switch (bindingType) {
      case "kv":
        return this.generateKVHelper(vars);
      case "d1":
        return this.generateD1Helper(vars);
      case "r2":
        return this.generateR2Helper(vars);
      case "queues":
      case "ai":
      case "vectorize":
      case "hyperdrive":
        throw new Error(
          `Binding type '${bindingType}' is not yet implemented (Phase 2+)`
        );
      default:
        throw new Error(`Unknown binding type: ${bindingType}`);
    }
  }
  /**
   * Generate and write helper file to disk
   *
   * @param cwd - Project root directory
   * @param bindingType - Type of binding (kv, d1)
   * @param vars - Template variables
   * @returns Path to the created file
   */
  async createHelperFile(cwd, bindingType, vars) {
    const content = this.generateHelper(bindingType, vars);
    const bindingsDir = join(cwd, "src", "utils", "bindings");
    const fileName = `${bindingType}-${vars.KEBAB_NAME}.ts`;
    const outputPath = join(bindingsDir, fileName);
    if (!existsSync(bindingsDir)) {
      await mkdir(bindingsDir, { recursive: true });
    }
    await writeFile(outputPath, content, "utf-8");
    return outputPath;
  }
  /**
   * Get the expected helper file path without creating it
   *
   * @param cwd - Project root directory
   * @param bindingType - Type of binding (kv, d1)
   * @param kebabName - Binding name in kebab-case
   * @returns Expected path to the helper file
   */
  getHelperPath(cwd, bindingType, kebabName) {
    return join(cwd, "src", "utils", "bindings", `${bindingType}-${kebabName}.ts`);
  }
  /**
   * Generate import statement for a helper class
   *
   * @param helperClassName - Name of the helper class (e.g., MyCacheKV)
   * @param bindingType - Type of binding (kv, d1)
   * @param kebabName - Binding name in kebab-case
   * @returns Import statement
   */
  generateImportStatement(helperClassName, bindingType, kebabName) {
    return `import { ${helperClassName} } from "./utils/bindings/${bindingType}-${kebabName}.js";`;
  }
  /**
   * Clear template cache (useful for testing)
   */
  clearCache() {
    this.templateCache.clear();
  }
  /**
   * Get templates directory path (useful for testing)
   */
  getTemplatesDir() {
    return this.templatesDir;
  }
};
async function addKVBinding(cwd, bindingName, kvId) {
  const wranglerPath = getWranglerConfigPath(cwd);
  if (!wranglerPath || !wranglerPath.endsWith(".jsonc")) {
    throw new Error(
      "wrangler.jsonc not found. KV bindings require wrangler.jsonc format."
    );
  }
  const anchorService = new AnchorService();
  const hasAnchor = await anchorService.hasAnchor(
    wranglerPath,
    BINDING_ANCHORS.KV
  );
  if (!hasAnchor) {
    throw new Error(
      "Missing KV anchor block in wrangler.jsonc. Your project may be outdated."
    );
  }
  const kvBinding = `"kv_namespaces": [
		{
			"binding": "${bindingName}",
			"id": "TODO: Run 'wrangler kv namespace create ${bindingName}' and add the ID here"
		}
	],`;
  const result = await anchorService.insertAtAnchor(
    wranglerPath,
    BINDING_ANCHORS.KV,
    kvBinding,
    { indent: "	" }
  );
  return result.modified;
}
async function addD1Binding(cwd, bindingName, databaseName, databaseId) {
  const wranglerPath = getWranglerConfigPath(cwd);
  if (!wranglerPath || !wranglerPath.endsWith(".jsonc")) {
    throw new Error(
      "wrangler.jsonc not found. D1 bindings require wrangler.jsonc format."
    );
  }
  const anchorService = new AnchorService();
  const hasAnchor = await anchorService.hasAnchor(
    wranglerPath,
    BINDING_ANCHORS.D1
  );
  if (!hasAnchor) {
    throw new Error(
      "Missing D1 anchor block in wrangler.jsonc. Your project may be outdated."
    );
  }
  const d1Binding = `"d1_databases": [
		{
			"binding": "${bindingName}",
			"database_name": "${databaseName}",
			"database_id": "TODO: Run 'wrangler d1 create ${databaseName}' and add the ID here"
		}
	],`;
  const result = await anchorService.insertAtAnchor(
    wranglerPath,
    BINDING_ANCHORS.D1,
    d1Binding,
    { indent: "	" }
  );
  return result.modified;
}
async function addR2Binding(cwd, bindingName, bucketName, previewBucketName) {
  const wranglerPath = getWranglerConfigPath(cwd);
  if (!wranglerPath || !wranglerPath.endsWith(".jsonc")) {
    throw new Error(
      "wrangler.jsonc not found. R2 bindings require wrangler.jsonc format."
    );
  }
  const anchorService = new AnchorService();
  const hasAnchor = await anchorService.hasAnchor(
    wranglerPath,
    BINDING_ANCHORS.R2
  );
  if (!hasAnchor) {
    throw new Error(
      "Missing R2 anchor block in wrangler.jsonc. Your project may be outdated."
    );
  }
  let r2Binding;
  {
    r2Binding = `"r2_buckets": [
		{
			"binding": "${bindingName}",
			"bucket_name": "${bucketName}"
		}
	],`;
  }
  const result = await anchorService.insertAtAnchor(
    wranglerPath,
    BINDING_ANCHORS.R2,
    r2Binding,
    { indent: "	" }
  );
  return result.modified;
}
async function addBindingImport(cwd, importStatement) {
  const indexPath = join(cwd, "src", "index.ts");
  if (!existsSync(indexPath)) {
    throw new Error("src/index.ts not found");
  }
  const anchorService = new AnchorService();
  const hasAnchor = await anchorService.hasAnchor(
    indexPath,
    BINDING_ANCHORS.IMPORTS
  );
  if (!hasAnchor) {
    throw new Error(
      "Missing bindings import anchor in src/index.ts. Your project may be outdated."
    );
  }
  const fileContent = await readFile(indexPath, "utf-8");
  const anchor = BINDING_ANCHORS.IMPORTS;
  const startIdx = fileContent.indexOf(anchor.startMarker);
  const endIdx = fileContent.indexOf(anchor.endMarker);
  if (startIdx === -1 || endIdx === -1) {
    throw new Error("Anchor markers not found in src/index.ts");
  }
  const currentContent = fileContent.slice(startIdx + anchor.startMarker.length, endIdx).trim();
  if (currentContent.includes(importStatement.trim())) {
    return false;
  }
  let newContent;
  if (currentContent === "" || currentContent.startsWith("//")) {
    newContent = importStatement;
  } else {
    newContent = currentContent + "\n" + importStatement;
  }
  const result = await anchorService.insertAtAnchor(
    indexPath,
    BINDING_ANCHORS.IMPORTS,
    newContent,
    { force: true }
  );
  return result.modified;
}

// src/core/commands/shared/strategies/binding-scaffold-strategy.ts
var execAsync2 = promisify(exec);
function toKebabCase2(str) {
  return str.toLowerCase().replace(/_/g, "-");
}
function toCamelCase(str) {
  const kebab = toKebabCase2(str);
  return kebab.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}
function toPascalCase2(str) {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}
var BindingScaffoldStrategy = class {
  validator = new BindingValidator();
  templateService = new BindingTemplateService();
  /**
   * Validate binding configuration
   */
  async validate(cwd, config) {
    await this.validator.validateBindingConfig(cwd, config);
  }
  /**
   * Execute binding scaffolding
   *
   * 1. Generate template variables
   * 2. Create helper file (if not skipped)
   * 3. Update wrangler.jsonc
   * 4. Add import to index.ts (if not skipped)
   * 5. Run cf-typegen (if not skipped)
   * 6. Generate next steps
   */
  async execute(context) {
    const { cwd, config, result } = context;
    const templateVars = this.generateTemplateVars(config);
    if (!config.skipHelper) {
      const helperPath = await this.templateService.createHelperFile(
        cwd,
        config.bindingType,
        templateVars
      );
      result.helperPath = helperPath;
      result.filesCreated.push(helperPath);
    }
    await this.updateWranglerConfig(cwd, config, result);
    if (!config.skipHelper) {
      const importStatement = this.templateService.generateImportStatement(
        templateVars.HELPER_CLASS_NAME,
        config.bindingType,
        templateVars.KEBAB_NAME
      );
      const importAdded = await addBindingImport(cwd, importStatement);
      if (importAdded) {
        result.filesModified.push(`${cwd}/src/index.ts`);
      }
    }
    if (!config.skipTypegen) {
      await this.runCfTypegen(cwd, result);
    }
    result.nextSteps = this.generateNextSteps(config, result);
    result.success = true;
  }
  /**
   * Bindings need backup (modifies wrangler.jsonc)
   */
  needsBackup() {
    return true;
  }
  /**
   * Create initial result object
   */
  createResult() {
    return {
      success: false,
      bindingType: "kv",
      // Will be overwritten by config
      bindingName: "",
      // Will be overwritten by config
      filesCreated: [],
      filesModified: [],
      nextSteps: [],
      warnings: []
    };
  }
  /**
   * Generate template variables from binding configuration
   */
  generateTemplateVars(config) {
    const kebabName = toKebabCase2(config.bindingName);
    const pascalName = toPascalCase2(config.bindingName);
    const camelName = toCamelCase(config.bindingName);
    const typeSuffix = config.bindingType.toUpperCase();
    const vars = {
      BINDING_NAME: config.bindingName,
      HELPER_CLASS_NAME: `${pascalName}${typeSuffix}`,
      KEBAB_NAME: kebabName,
      CAMEL_NAME: camelName,
      TYPE_SUFFIX: typeSuffix
    };
    if (config.bindingType === "d1") {
      vars.DATABASE_NAME = config.databaseName || kebabName;
    }
    if (config.bindingType === "r2") {
      vars.BUCKET_NAME = config.bucketName || kebabName;
    }
    return vars;
  }
  /**
   * Update wrangler.jsonc with binding configuration
   */
  async updateWranglerConfig(cwd, config, result) {
    let modified = false;
    if (config.bindingType === "kv") {
      modified = await addKVBinding(cwd, config.bindingName);
    } else if (config.bindingType === "d1") {
      const databaseName = config.databaseName || toKebabCase2(config.bindingName);
      modified = await addD1Binding(cwd, config.bindingName, databaseName);
    } else if (config.bindingType === "r2") {
      const bucketName = config.bucketName || toKebabCase2(config.bindingName);
      modified = await addR2Binding(cwd, config.bindingName, bucketName);
    } else {
      throw new Error(
        `Binding type '${config.bindingType}' is not yet implemented`
      );
    }
    if (modified) {
      result.filesModified.push(`${cwd}/wrangler.jsonc`);
    }
  }
  /**
   * Run cf-typegen to generate TypeScript types from wrangler.jsonc
   */
  async runCfTypegen(cwd, result) {
    try {
      const packageJsonPath = `${cwd}/package.json`;
      if (!existsSync(packageJsonPath)) {
        result.warnings?.push("package.json not found, skipping cf-typegen");
        return;
      }
      const { stdout, stderr } = await execAsync2("npm run cf-typegen", {
        cwd,
        timeout: 3e4
        // 30 second timeout
      });
      if (stderr && !stderr.includes("WARN")) {
        result.warnings?.push(`cf-typegen warnings: ${stderr}`);
      }
      const workerConfigPath = `${cwd}/worker-configuration.d.ts`;
      if (existsSync(workerConfigPath)) {
        result.filesModified.push(workerConfigPath);
      }
    } catch (error) {
      result.warnings?.push(
        `Failed to run cf-typegen: ${error instanceof Error ? error.message : String(error)}. Run 'npm run cf-typegen' manually.`
      );
    }
  }
  /**
   * Generate next steps for the user
   */
  generateNextSteps(config, result) {
    const steps = [];
    const templateVars = this.generateTemplateVars(config);
    if (config.bindingType === "kv") {
      steps.push(
        `1. Create a KV namespace: wrangler kv namespace create ${config.bindingName}`
      );
      steps.push(
        "2. Update the binding ID in wrangler.jsonc with the namespace ID from step 1"
      );
      steps.push(
        `3. Use the helper class in your tools: new ${templateVars.HELPER_CLASS_NAME}(env.${config.bindingName})`
      );
    } else if (config.bindingType === "d1") {
      const databaseName = config.databaseName || toKebabCase2(config.bindingName);
      steps.push(`1. Create a D1 database: wrangler d1 create ${databaseName}`);
      steps.push(
        "2. Update the database_id in wrangler.jsonc with the database ID from step 1"
      );
      steps.push(
        `3. Create your schema: wrangler d1 execute ${databaseName} --file=./schema.sql`
      );
      steps.push(
        `4. Use the helper class in your tools: new ${templateVars.HELPER_CLASS_NAME}(env.${config.bindingName})`
      );
    } else if (config.bindingType === "r2") {
      const bucketName = config.bucketName || toKebabCase2(config.bindingName);
      steps.push(`1. Create an R2 bucket: wrangler r2 bucket create ${bucketName}`);
      steps.push(
        `2. Use the helper class in your tools: new ${templateVars.HELPER_CLASS_NAME}(env.${config.bindingName})`
      );
      steps.push(
        `3. Upload objects: await bucket.put('path/to/file.txt', fileData)`
      );
    }
    steps.push("5. Deploy your changes: npm run deploy");
    return steps;
  }
};

// src/core/commands/shared/binding-scaffolder.ts
var BindingScaffolder = class {
  orchestrator;
  strategy;
  constructor() {
    this.orchestrator = new ScaffoldOrchestrator();
    this.strategy = new BindingScaffoldStrategy();
  }
  /**
   * Add a Cloudflare binding to an MCP server project
   *
   * @param cwd - Project root directory
   * @param config - Binding configuration
   * @returns Result with paths to created/modified files
   */
  async scaffold(cwd, config) {
    const skipBackup = config.skipHelper === true;
    try {
      const result = await this.orchestrator.scaffold(
        cwd,
        config,
        this.strategy,
        {
          skipBackup,
          dryRun: false
        }
      );
      result.bindingType = config.bindingType;
      result.bindingName = config.bindingName;
      return result;
    } catch (error) {
      const result = this.strategy.createResult();
      result.bindingType = config.bindingType;
      result.bindingName = config.bindingName;
      result.error = error instanceof Error ? error.message : String(error);
      if (!skipBackup) {
        result.warnings?.push("Changes have been rolled back due to error");
      }
      return result;
    }
  }
};

// src/core/commands/add-binding.ts
function validateAddBindingOptions(bindingType, options) {
  const validTypes = [
    "kv",
    "d1",
    "r2",
    "queues",
    "ai",
    "vectorize",
    "hyperdrive"
  ];
  if (!validTypes.includes(bindingType)) {
    throw new Error(
      `Invalid binding type '${bindingType}'. Valid types: ${validTypes.join(", ")}`
    );
  }
  if (!isPhase1Binding(bindingType)) {
    throw new Error(
      `Binding type '${bindingType}' is not yet supported. Phase 1 supports: kv, d1, r2`
    );
  }
  if (!options.name) {
    throw new Error("Binding name is required (--name <NAME>)");
  }
  if (!/^[A-Z][A-Z0-9_]*$/.test(options.name)) {
    throw new Error(
      `Binding name must be UPPER_SNAKE_CASE (e.g., MY_CACHE, USER_DATA)`
    );
  }
}
async function addBinding(bindingType, options) {
  const scaffolder = new BindingScaffolder();
  const config = {
    bindingType,
    bindingName: options.name,
    databaseName: options.database,
    bucketName: options.bucket,
    skipHelper: options.skipHelper,
    skipTypegen: options.skipTypegen
  };
  const result = await scaffolder.scaffold(
    options.cwd || process.cwd(),
    config
  );
  if (options.json) {
    console.log(JSON.stringify(result, null, 2));
  } else {
    printHumanReadableResult2(result);
  }
  return result;
}
function printHumanReadableResult2(result) {
  if (result.success) {
    console.log(
      `
\u2705 ${result.bindingType.toUpperCase()} binding added successfully!
`
    );
    console.log(`Binding: ${result.bindingName}`);
    console.log(`Type: ${result.bindingType.toUpperCase()}
`);
    if (result.helperPath) {
      console.log("Helper class:");
      console.log(`  + ${result.helperPath}
`);
    }
    if (result.filesCreated.length > 0) {
      console.log("Files created:");
      for (const file of result.filesCreated) {
        console.log(`  + ${file}`);
      }
      console.log();
    }
    if (result.filesModified.length > 0) {
      console.log("Files modified:");
      for (const file of result.filesModified) {
        console.log(`  ~ ${file}`);
      }
      console.log();
    }
    if (result.warnings && result.warnings.length > 0) {
      console.log("\u26A0\uFE0F  Warnings:");
      for (const warning of result.warnings) {
        console.log(`  ${warning}`);
      }
      console.log();
    }
    if (result.nextSteps.length > 0) {
      console.log("Next steps:");
      for (const step of result.nextSteps) {
        console.log(`  ${step}`);
      }
      console.log();
    }
  } else {
    console.error("\n\u274C Failed to add binding\n");
    console.error(`Error: ${result.error || "Unknown error"}
`);
    if (result.warnings && result.warnings.length > 0) {
      console.error("Warnings:");
      for (const warning of result.warnings) {
        console.error(`  ${warning}`);
      }
      console.error();
    }
    process.exit(1);
  }
}
function createAddBindingCommand() {
  const command = new Command("binding").description("Add a Cloudflare binding to your MCP server (Phase 1: kv, d1, r2)").argument("<type>", "Binding type: kv, d1, or r2").requiredOption("--name <NAME>", "Binding name in UPPER_SNAKE_CASE").option(
    "--database <name>",
    "Database name (for D1 only, defaults to binding name in kebab-case)"
  ).option(
    "--bucket <name>",
    "Bucket name (for R2 only, defaults to binding name in kebab-case)"
  ).option("--skip-helper", "Skip generating helper class").option("--skip-typegen", "Skip running cf-typegen").option("--json", "Output result as JSON").action(
    async (bindingType, options) => {
      try {
        validateAddBindingOptions(bindingType, options);
        await addBinding(bindingType, options);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (options.json) {
          const result = {
            success: false,
            bindingType,
            bindingName: options.name || "unknown",
            filesCreated: [],
            filesModified: [],
            nextSteps: [],
            error: errorMessage
          };
          console.log(JSON.stringify(result, null, 2));
        } else {
          console.error(`
\u274C Error: ${errorMessage}
`);
        }
        process.exit(1);
      }
    }
  );
  return command;
}

// src/core/commands/add-tool.ts
function createAddToolCommand() {
  const command = new Command("tool").description("Add a new MCP tool to the project").argument("<name>", "Tool name (lowercase with hyphens)").option(
    "--description <desc>",
    "Tool description",
    "TODO: Add description"
  ).option("--no-tests", "Skip test file generation").option("--no-register", "Don't auto-register in index.ts").option(
    "--template <type>",
    "Template type: simple|validated|async",
    "simple"
  ).option("--json", "Output result as JSON").action(async (name, options) => {
    try {
      const cwd = process.cwd();
      const scaffolder = new EntityScaffolder();
      const config = {
        entityType: "tool",
        name,
        description: options.description,
        generateTests: options.tests,
        autoRegister: options.register
      };
      const scaffoldResult = await scaffolder.scaffold(cwd, config);
      const result = {
        success: scaffoldResult.success,
        entityType: "tool",
        entityName: name,
        filesCreated: scaffoldResult.filesCreated,
        registered: scaffoldResult.registered,
        message: `Tool '${name}' created successfully`
      };
      outputResult(result, !!options.json, (r) => {
        console.log(`
\u{1F527} Adding tool: ${name}
`);
        for (const file of r.filesCreated) {
          console.log(`\u2713 Created ${file}`);
        }
        if (r.registered) {
          console.log(`\u2713 Registered in src/index.ts`);
        }
        console.log(`
\u2705 Tool '${name}' created successfully!
`);
        console.log("Next steps:");
        console.log(`  1. Edit src/tools/${name}.ts and implement your logic`);
        console.log(`  2. Run 'npm test' to verify tests pass`);
        console.log(`  3. Run 'npm run validate' to check project health
`);
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (options.json) {
        const result = {
          success: false,
          entityType: "tool",
          entityName: name,
          filesCreated: [],
          registered: false,
          error: errorMessage
        };
        console.log(JSON.stringify(result, null, 2));
      } else {
        console.error(`
\u274C Error: ${errorMessage}
`);
      }
      process.exit(1);
    }
  });
  return command;
}
function createAddCommand() {
  const addCmd = new Command("add").description(
    "Add components to your MCP server"
  );
  addCmd.addCommand(createAddToolCommand());
  addCmd.addCommand(createAddPromptCommand());
  addCmd.addCommand(createAddResourceCommand());
  addCmd.addCommand(createAddAuthCommand());
  addCmd.addCommand(createAddBindingCommand());
  return addCmd;
}
var __filename = fileURLToPath(import.meta.url);
path2__default.dirname(__filename);
function createValidateCommand2() {
  return new Command("validate").description("Validate MCP server project structure and configuration").option("--fix", "Automatically fix issues where possible").option("--strict", "Fail on warnings (not just errors)").option("--json", "Output result as JSON").action(async (options) => {
    const cwd = process.cwd();
    const result = await validateProject(cwd, options);
    if (options.json) {
      console.log(JSON.stringify(result, null, 2));
    } else {
      console.log("\u{1F50D} Validating MCP server project...\n");
      printValidationResults(result);
    }
    if (!result.passed) {
      process.exit(1);
    }
  });
}
async function validateProject(cwd, options = {}) {
  const issues = [];
  const metadataPath = path2__default.join(cwd, ".mcp-template.json");
  let metadata = null;
  try {
    const metadataContent = await fs.readFile(metadataPath, "utf-8");
    metadata = JSON.parse(metadataContent);
  } catch (error) {
    issues.push({
      severity: "error",
      category: "Metadata",
      message: ".mcp-template.json not found or invalid",
      file: ".mcp-template.json",
      suggestion: "Run this command from an MCP server project root"
    });
    return createResult(issues);
  }
  const toolsDir = path2__default.join(cwd, "src", "tools");
  const actualTools = await discoverTools(toolsDir);
  const indexPath = path2__default.join(cwd, "src", "index.ts");
  const registeredTools = await checkToolRegistrations(indexPath);
  for (const toolFile of actualTools) {
    const toolName = path2__default.basename(toolFile, path2__default.extname(toolFile));
    if (toolName.startsWith("_example")) {
      continue;
    }
    const isRegistered = registeredTools.includes(toolName);
    if (!isRegistered) {
      const pascalName = toolName.split("-").map((word) => capitalize(word)).join("");
      issues.push({
        severity: "error",
        category: "Registration",
        message: `Tool "${toolName}" is not registered in src/index.ts`,
        file: toolFile,
        suggestion: `Add: import { register${pascalName}Tool } from "./tools/${toolName}.js";
register${pascalName}Tool(this.server);`
      });
    }
    const unitTestPath = path2__default.join(
      cwd,
      "test",
      "unit",
      "tools",
      `${toolName}.test.ts`
    );
    const hasUnitTest = await fileExists2(unitTestPath);
    if (!hasUnitTest) {
      issues.push({
        severity: "warning",
        category: "Testing",
        message: `Tool "${toolName}" is missing unit test`,
        file: toolFile,
        suggestion: `Create test/unit/tools/${toolName}.test.ts`
      });
    }
    const integrationTestPath = path2__default.join(
      cwd,
      "test",
      "integration",
      "specs",
      `${toolName}.yaml`
    );
    const hasIntegrationTest = await fileExists2(integrationTestPath);
    if (!hasIntegrationTest) {
      issues.push({
        severity: "warning",
        category: "Testing",
        message: `Tool "${toolName}" is missing integration test`,
        file: toolFile,
        suggestion: `Create test/integration/specs/${toolName}.yaml`
      });
    }
    if (hasIntegrationTest) {
      const yamlIssues = await validateYaml(integrationTestPath, toolName);
      issues.push(...yamlIssues);
    }
  }
  for (const registeredTool of registeredTools) {
    const toolFile = actualTools.find((f) => {
      const fileName = path2__default.basename(f, path2__default.extname(f));
      return fileName === registeredTool;
    });
    if (!toolFile) {
      issues.push({
        severity: "error",
        category: "Registration",
        message: `Tool "${registeredTool}" is registered but file doesn't exist`,
        file: "src/index.ts",
        suggestion: `Remove registration or create src/tools/${registeredTool}.ts`
      });
    }
  }
  const configIssues = await validateConfiguration(cwd);
  issues.push(...configIssues);
  if (metadata) {
    const metadataIssues = await validateMetadata(
      metadata,
      actualTools,
      registeredTools,
      cwd
    );
    issues.push(...metadataIssues);
  }
  return createResult(issues, options.strict);
}
async function discoverTools(toolsDir) {
  try {
    const files = await fs.readdir(toolsDir);
    return files.filter((f) => f.endsWith(".ts") && !f.endsWith(".test.ts")).map((f) => path2__default.join(toolsDir, f));
  } catch (error) {
    return [];
  }
}
async function checkToolRegistrations(indexPath) {
  try {
    const content = await fs.readFile(indexPath, "utf-8");
    const registered = [];
    const registerRegex = /register(\w+)Tool\(this\.server\)/g;
    let match;
    while ((match = registerRegex.exec(content)) !== null) {
      const toolName = toKebabCase(match[1]);
      registered.push(toolName);
    }
    return registered;
  } catch (error) {
    return [];
  }
}
async function validateYaml(yamlPath, toolName) {
  const issues = [];
  try {
    const content = await fs.readFile(yamlPath, "utf-8");
    const data = yaml.parse(content);
    if (!data.name) {
      issues.push({
        severity: "error",
        category: "YAML",
        message: `Integration test for "${toolName}" is missing "name" field`,
        file: yamlPath
      });
    }
    if (!data.tool) {
      issues.push({
        severity: "error",
        category: "YAML",
        message: `Integration test for "${toolName}" is missing "tool" field`,
        file: yamlPath
      });
    }
    if (!data.assertions || !Array.isArray(data.assertions)) {
      issues.push({
        severity: "error",
        category: "YAML",
        message: `Integration test for "${toolName}" is missing "assertions" array`,
        file: yamlPath
      });
    }
    if (data.tool && data.tool !== toolName) {
      issues.push({
        severity: "warning",
        category: "YAML",
        message: `Integration test tool name "${data.tool}" doesn't match file name "${toolName}"`,
        file: yamlPath
      });
    }
  } catch (error) {
    issues.push({
      severity: "error",
      category: "YAML",
      message: `Integration test for "${toolName}" has invalid YAML: ${error instanceof Error ? error.message : String(error)}`,
      file: yamlPath
    });
  }
  return issues;
}
async function validateConfiguration(cwd) {
  const issues = [];
  const wranglerJsoncPath = path2__default.join(cwd, "wrangler.jsonc");
  const wranglerJsonPath = path2__default.join(cwd, "wrangler.json");
  let wranglerPath = null;
  if (await fileExists2(wranglerJsoncPath)) {
    wranglerPath = wranglerJsoncPath;
  } else if (await fileExists2(wranglerJsonPath)) {
    wranglerPath = wranglerJsonPath;
  }
  if (!wranglerPath) {
    issues.push({
      severity: "error",
      category: "Configuration",
      message: "wrangler.jsonc or wrangler.json not found",
      suggestion: "This project needs a Cloudflare Workers configuration file"
    });
    return issues;
  }
  let config;
  try {
    const content = await fs.readFile(wranglerPath, "utf-8");
    const jsonContent = content.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/.*/g, "");
    config = JSON.parse(jsonContent);
  } catch (error) {
    issues.push({
      severity: "error",
      category: "Configuration",
      message: `Invalid JSON in ${path2__default.basename(wranglerPath)}: ${error instanceof Error ? error.message : String(error)}`,
      file: wranglerPath,
      suggestion: "Fix JSON syntax errors"
    });
    return issues;
  }
  const requiredFields = ["name", "main", "compatibility_date"];
  for (const field of requiredFields) {
    if (!config[field]) {
      issues.push({
        severity: "error",
        category: "Configuration",
        message: `Missing required field "${field}" in ${path2__default.basename(wranglerPath)}`,
        file: wranglerPath
      });
    }
  }
  if (!config.durable_objects) {
    issues.push({
      severity: "error",
      category: "Configuration",
      message: "Missing 'durable_objects' configuration",
      file: wranglerPath,
      suggestion: 'Add: "durable_objects": { "bindings": [{ "name": "MCP_OBJECT", "class_name": "MCPServerAgent" }] }'
    });
  } else {
    const durableObjects = config.durable_objects;
    const bindings = durableObjects.bindings;
    if (!bindings || !Array.isArray(bindings)) {
      issues.push({
        severity: "error",
        category: "Configuration",
        message: "durable_objects.bindings must be an array",
        file: wranglerPath
      });
    } else {
      const mcpBinding = bindings.find(
        (b) => b.name === "MCP_OBJECT"
      );
      if (!mcpBinding) {
        issues.push({
          severity: "error",
          category: "Configuration",
          message: 'Missing "MCP_OBJECT" binding in durable_objects.bindings',
          file: wranglerPath,
          suggestion: 'Add: { "name": "MCP_OBJECT", "class_name": "MCPServerAgent" }'
        });
      } else {
        if (!mcpBinding.class_name) {
          issues.push({
            severity: "error",
            category: "Configuration",
            message: "MCP_OBJECT binding is missing class_name",
            file: wranglerPath
          });
        } else {
          const indexPath = path2__default.join(cwd, "src", "index.ts");
          try {
            const indexContent = await fs.readFile(indexPath, "utf-8");
            const className = mcpBinding.class_name;
            const classRegex = new RegExp(
              `export\\s+class\\s+${className}\\s+extends\\s+McpAgent`
            );
            if (!classRegex.test(indexContent)) {
              issues.push({
                severity: "error",
                category: "Configuration",
                message: `Class "${className}" not found in src/index.ts or doesn't extend McpAgent`,
                file: wranglerPath,
                suggestion: `Ensure src/index.ts exports: export class ${className} extends McpAgent<Env>`
              });
            }
          } catch (error) {
          }
        }
      }
    }
  }
  if (!config.migrations) {
    issues.push({
      severity: "error",
      category: "Configuration",
      message: "Missing 'migrations' configuration (required for Agents)",
      file: wranglerPath,
      suggestion: 'Add: "migrations": [{ "tag": "v1", "new_sqlite_classes": ["MCPServerAgent"] }]'
    });
  } else {
    const migrations = config.migrations;
    if (!Array.isArray(migrations)) {
      issues.push({
        severity: "error",
        category: "Configuration",
        message: "migrations must be an array",
        file: wranglerPath
      });
    } else if (migrations.length === 0) {
      issues.push({
        severity: "error",
        category: "Configuration",
        message: "migrations array is empty",
        file: wranglerPath,
        suggestion: 'Add at least one migration: { "tag": "v1", "new_sqlite_classes": ["MCPServerAgent"] }'
      });
    } else {
      const hasSqliteClasses = migrations.some((m) => {
        const sqliteClasses = m.new_sqlite_classes;
        return Array.isArray(sqliteClasses) && sqliteClasses.some(
          (c) => c.includes("MCPServerAgent") || c.includes("McpAgent")
        );
      });
      if (!hasSqliteClasses) {
        issues.push({
          severity: "warning",
          category: "Configuration",
          message: "No migration includes MCPServerAgent in new_sqlite_classes",
          file: wranglerPath,
          suggestion: "Add your Agent class to new_sqlite_classes in migrations"
        });
      }
    }
  }
  if (config.mcp) {
    issues.push({
      severity: "error",
      category: "Configuration",
      message: 'Deprecated "mcp" field found (this field is not recognized by wrangler)',
      file: wranglerPath,
      suggestion: 'Remove "mcp" field and use "durable_objects" instead (see above)'
    });
  }
  return issues;
}
async function validateMetadata(metadata, actualTools, registeredTools, cwd) {
  const issues = [];
  if (!metadata.tools || !Array.isArray(metadata.tools)) {
    issues.push({
      severity: "warning",
      category: "Metadata",
      message: ".mcp-template.json is missing tools array",
      file: ".mcp-template.json",
      suggestion: "Tools array should track all tools in the project"
    });
    return issues;
  }
  const actualToolNames = actualTools.map((f) => path2__default.basename(f, path2__default.extname(f))).filter((name) => !name.startsWith("_example"));
  for (const tool of metadata.tools) {
    if (!actualToolNames.includes(tool.name)) {
      issues.push({
        severity: "warning",
        category: "Metadata",
        message: `Tool "${tool.name}" in .mcp-template.json doesn't exist`,
        file: ".mcp-template.json",
        suggestion: "Remove from tools array or create the tool file"
      });
    }
  }
  for (const toolName of actualToolNames) {
    const inMetadata = metadata.tools.find((t) => t.name === toolName);
    if (!inMetadata) {
      issues.push({
        severity: "info",
        category: "Metadata",
        message: `Tool "${toolName}" exists but not tracked in .mcp-template.json`,
        file: ".mcp-template.json",
        suggestion: "Add to tools array for better tracking"
      });
    } else {
      const isRegistered = registeredTools.includes(toolName);
      if (inMetadata.registered !== isRegistered) {
        issues.push({
          severity: "info",
          category: "Metadata",
          message: `Tool "${toolName}" registration status in .mcp-template.json is incorrect`,
          file: ".mcp-template.json"
        });
      }
      const unitTestPath = path2__default.join(
        cwd,
        "test",
        "unit",
        "tools",
        `${toolName}.test.ts`
      );
      const hasUnitTest = await fileExists2(unitTestPath);
      if (inMetadata.hasUnitTest !== hasUnitTest) {
        issues.push({
          severity: "info",
          category: "Metadata",
          message: `Tool "${toolName}" unit test status in .mcp-template.json is incorrect`,
          file: ".mcp-template.json"
        });
      }
    }
  }
  return issues;
}
async function fileExists2(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}
function createResult(issues, strict = false) {
  const summary = {
    errors: issues.filter((i) => i.severity === "error").length,
    warnings: issues.filter((i) => i.severity === "warning").length,
    info: issues.filter((i) => i.severity === "info").length
  };
  const passed = strict ? summary.errors === 0 && summary.warnings === 0 : summary.errors === 0;
  return { passed, issues, summary };
}
function printValidationResults(result) {
  if (result.issues.length === 0) {
    console.log("\u2705 No issues found! Project is valid.\n");
    return;
  }
  const byCategory = /* @__PURE__ */ new Map();
  for (const issue of result.issues) {
    const existing = byCategory.get(issue.category) || [];
    existing.push(issue);
    byCategory.set(issue.category, existing);
  }
  for (const [category, issues] of byCategory) {
    console.log(`
${category}:`);
    for (const issue of issues) {
      const icon = issue.severity === "error" ? "\u274C" : issue.severity === "warning" ? "\u26A0\uFE0F" : "\u2139\uFE0F";
      console.log(`  ${icon} ${issue.message}`);
      if (issue.file) {
        console.log(`     File: ${issue.file}`);
      }
      if (issue.suggestion) {
        console.log(`     Suggestion: ${issue.suggestion}`);
      }
    }
  }
  console.log(`
${"=".repeat(60)}`);
  console.log(`Summary: ${result.summary.errors} errors, ${result.summary.warnings} warnings, ${result.summary.info} info`);
  if (result.passed) {
    console.log("\u2705 Validation passed (no critical errors)\n");
  } else {
    console.log("\u274C Validation failed (fix errors above)\n");
  }
}
var EntityLister = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * Create Commander command for listing entities
   */
  createCommand() {
    return new Command(this.config.entityTypePlural).description(
      `List all ${this.config.entityTypePlural} in the MCP server project`
    ).option("-j, --json", "Output as JSON").option(
      "-f, --filter <status>",
      "Filter by status (all, registered, unregistered, tested, untested)",
      "all"
    ).option(
      "--show-examples",
      `Include example ${this.config.entityTypePlural} in output`
    ).action(async (options) => {
      const cwd = process.cwd();
      try {
        const entities = await this.discoverEntities(
          cwd,
          options.showExamples
        );
        const filtered = this.filterEntities(entities, options.filter);
        if (options.json) {
          console.log(JSON.stringify(filtered, null, 2));
        } else {
          this.printTable(filtered);
        }
      } catch (error) {
        console.error(
          `\u274C Error: ${error instanceof Error ? error.message : String(error)}`
        );
        process.exit(1);
      }
    });
  }
  /**
   * Discover all entities in the project
   */
  async discoverEntities(cwd, includeExamples = false) {
    const entities = [];
    const sourceDir = path2__default.join(cwd, this.config.sourceDir);
    let entityFiles = [];
    try {
      const files = await fs.readdir(sourceDir);
      entityFiles = files.filter((f) => f.endsWith(".ts") && !f.endsWith(".test.ts")).filter((f) => includeExamples || !f.startsWith("_example"));
    } catch (error) {
      throw new Error(
        `${this.config.sourceDir}/ directory not found. Are you in an MCP server project?`
      );
    }
    const indexPath = path2__default.join(cwd, "src", "index.ts");
    const registeredEntities = await this.checkRegistrations(indexPath);
    for (const file of entityFiles) {
      const entityName = path2__default.basename(file, ".ts");
      const entityPath = path2__default.join(sourceDir, file);
      const registered = registeredEntities.includes(entityName);
      const unitTestPath = path2__default.join(
        cwd,
        this.config.unitTestDir,
        `${entityName}.test.ts`
      );
      const hasUnitTest = await fileExists(unitTestPath);
      const integrationTestPath = path2__default.join(
        cwd,
        this.config.integrationTestDir,
        `${entityName}.yaml`
      );
      const hasIntegrationTest = await fileExists(integrationTestPath);
      const description = await this.extractDescription(entityPath);
      entities.push({
        name: entityName,
        file: path2__default.relative(cwd, entityPath),
        registered,
        hasUnitTest,
        hasIntegrationTest,
        description
      });
    }
    return entities;
  }
  /**
   * Check which entities are registered in src/index.ts
   */
  async checkRegistrations(indexPath) {
    try {
      const content = await fs.readFile(indexPath, "utf-8");
      const registered = [];
      let match;
      while ((match = this.config.registrationPattern.exec(content)) !== null) {
        const entityName = toKebabCase(match[1]);
        registered.push(entityName);
      }
      return registered;
    } catch (error) {
      return [];
    }
  }
  /**
   * Filter entities by status
   */
  filterEntities(entities, filter) {
    switch (filter.toLowerCase()) {
      case "registered":
        return entities.filter((e) => e.registered);
      case "unregistered":
        return entities.filter((e) => !e.registered);
      case "tested":
        return entities.filter((e) => e.hasUnitTest || e.hasIntegrationTest);
      case "untested":
        return entities.filter((e) => !e.hasUnitTest && !e.hasIntegrationTest);
      case "all":
      default:
        return entities;
    }
  }
  /**
   * Print entities in a formatted table
   */
  printTable(entities) {
    if (entities.length === 0) {
      console.log(`No ${this.config.entityTypePlural} found.
`);
      return;
    }
    console.log(
      `
Found ${entities.length} ${entities.length === 1 ? this.config.entityType : this.config.entityTypePlural}:
`
    );
    const nameWidth = Math.max(10, ...entities.map((e) => e.name.length));
    const fileWidth = Math.max(20, ...entities.map((e) => e.file.length));
    const header = `${"NAME".padEnd(nameWidth)} | REG | UNIT | INT | ${"FILE".padEnd(fileWidth)}`;
    console.log(header);
    console.log("=".repeat(header.length));
    for (const entity of entities) {
      const name = entity.name.padEnd(nameWidth);
      const reg = entity.registered ? " \u2713 " : " \u2717 ";
      const unit = entity.hasUnitTest ? " \u2713 " : " \u2717 ";
      const int = entity.hasIntegrationTest ? " \u2713 " : " \u2717 ";
      const file = entity.file.padEnd(fileWidth);
      console.log(`${name} | ${reg} | ${unit} | ${int} | ${file}`);
      if (entity.description && entity.description !== "No description") {
        console.log(`${"".padEnd(nameWidth)}   ${entity.description}`);
      }
    }
    const registered = entities.filter((e) => e.registered).length;
    const withUnitTests = entities.filter((e) => e.hasUnitTest).length;
    const withIntegrationTests = entities.filter(
      (e) => e.hasIntegrationTest
    ).length;
    console.log("\nSummary:");
    console.log(`  Registered:       ${registered}/${entities.length}`);
    console.log(`  Unit tests:       ${withUnitTests}/${entities.length}`);
    console.log(
      `  Integration tests: ${withIntegrationTests}/${entities.length}`
    );
    console.log("");
  }
  /**
   * Extract description from entity file
   */
  async extractDescription(filePath) {
    try {
      const content = await fs.readFile(filePath, "utf-8");
      const match = content.match(this.config.descriptionPattern);
      if (match && match[2]) {
        return match[2];
      }
      const headerRegex = /\/\*\*[\s\S]*?\*\s*([^\n]+)/;
      const headerMatch = content.match(headerRegex);
      if (headerMatch && headerMatch[1]) {
        return headerMatch[1].trim();
      }
      return "No description";
    } catch (error) {
      return "No description";
    }
  }
};

// src/core/commands/list-tools.ts
var toolsConfig = {
  entityType: "tool",
  entityTypePlural: "tools",
  sourceDir: "src/tools",
  registrationPattern: /register(\w+)Tool\(this\.server\)/g,
  unitTestDir: "test/unit/tools",
  integrationTestDir: "test/integration/specs",
  descriptionPattern: /server\.tool\(\s*["']([^"']+)["'],\s*["']([^"']+)["']/
};
function createListToolsCommand() {
  return new EntityLister(toolsConfig).createCommand();
}

// src/core/commands/list-prompts.ts
var promptsConfig = {
  entityType: "prompt",
  entityTypePlural: "prompts",
  sourceDir: "src/prompts",
  registrationPattern: /register(\w+)Prompt\(this\.server\)/g,
  unitTestDir: "test/unit/prompts",
  integrationTestDir: "test/integration/specs/prompts",
  descriptionPattern: /server\.prompt\(\s*["']([^"']+)["'],\s*["']([^"']+)["']/
};
function createListPromptsCommand() {
  return new EntityLister(promptsConfig).createCommand();
}

// src/core/commands/list-resources.ts
var resourcesConfig = {
  entityType: "resource",
  entityTypePlural: "resources",
  sourceDir: "src/resources",
  registrationPattern: /register(\w+)Resource\(this\.server\)/g,
  unitTestDir: "test/unit/resources",
  integrationTestDir: "test/integration/specs/resources",
  descriptionPattern: /server\.resource\(\s*["']([^"']+)["'],\s*["']([^"']+)["']/
};
function createListResourcesCommand() {
  return new EntityLister(resourcesConfig).createCommand();
}

// src/core/commands/list.ts
function createListCommand2() {
  const listCommand = new Command("list").description("List project elements (tools, prompts, resources, etc.)");
  listCommand.addCommand(createListToolsCommand());
  listCommand.addCommand(createListPromptsCommand());
  listCommand.addCommand(createListResourcesCommand());
  return listCommand;
}

export { createAddCommand, createListCommand2 as createListCommand, createNewCommand, createTemplateCommand, createValidateCommand2 as createValidateCommand };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map