import { Command } from 'commander';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import yaml from 'yaml';

// src/core/commands/validate.ts
function toKebabCase(str) {
  return str.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// src/core/commands/validate.ts
var __filename = fileURLToPath(import.meta.url);
path.dirname(__filename);
function createValidateCommand() {
  return new Command("validate").description("Validate MCP server project structure and configuration").option("--fix", "Automatically fix issues where possible").option("--strict", "Fail on warnings (not just errors)").option("--json", "Output result as JSON").action(async (options) => {
    const cwd = process.cwd();
    const result = await validateProject(cwd, options);
    if (options.json) {
      console.log(JSON.stringify(result, null, 2));
    } else {
      console.log("\u{1F50D} Validating MCP server project...\n");
      printValidationResults(result);
    }
    if (!result.passed) {
      process.exit(1);
    }
  });
}
async function validateProject(cwd, options = {}) {
  const issues = [];
  const metadataPath = path.join(cwd, ".mcp-template.json");
  let metadata = null;
  try {
    const metadataContent = await fs.readFile(metadataPath, "utf-8");
    metadata = JSON.parse(metadataContent);
  } catch (error) {
    issues.push({
      severity: "error",
      category: "Metadata",
      message: ".mcp-template.json not found or invalid",
      file: ".mcp-template.json",
      suggestion: "Run this command from an MCP server project root"
    });
    return createResult(issues);
  }
  const toolsDir = path.join(cwd, "src", "tools");
  const actualTools = await discoverTools(toolsDir);
  const indexPath = path.join(cwd, "src", "index.ts");
  const registeredTools = await checkToolRegistrations(indexPath);
  for (const toolFile of actualTools) {
    const toolName = path.basename(toolFile, path.extname(toolFile));
    if (toolName.startsWith("_example")) {
      continue;
    }
    const isRegistered = registeredTools.includes(toolName);
    if (!isRegistered) {
      const pascalName = toolName.split("-").map((word) => capitalize(word)).join("");
      issues.push({
        severity: "error",
        category: "Registration",
        message: `Tool "${toolName}" is not registered in src/index.ts`,
        file: toolFile,
        suggestion: `Add: import { register${pascalName}Tool } from "./tools/${toolName}.js";
register${pascalName}Tool(this.server);`
      });
    }
    const unitTestPath = path.join(
      cwd,
      "test",
      "unit",
      "tools",
      `${toolName}.test.ts`
    );
    const hasUnitTest = await fileExists(unitTestPath);
    if (!hasUnitTest) {
      issues.push({
        severity: "warning",
        category: "Testing",
        message: `Tool "${toolName}" is missing unit test`,
        file: toolFile,
        suggestion: `Create test/unit/tools/${toolName}.test.ts`
      });
    }
    const integrationTestPath = path.join(
      cwd,
      "test",
      "integration",
      "specs",
      `${toolName}.yaml`
    );
    const hasIntegrationTest = await fileExists(integrationTestPath);
    if (!hasIntegrationTest) {
      issues.push({
        severity: "warning",
        category: "Testing",
        message: `Tool "${toolName}" is missing integration test`,
        file: toolFile,
        suggestion: `Create test/integration/specs/${toolName}.yaml`
      });
    }
    if (hasIntegrationTest) {
      const yamlIssues = await validateYaml(integrationTestPath, toolName);
      issues.push(...yamlIssues);
    }
  }
  for (const registeredTool of registeredTools) {
    const toolFile = actualTools.find((f) => {
      const fileName = path.basename(f, path.extname(f));
      return fileName === registeredTool;
    });
    if (!toolFile) {
      issues.push({
        severity: "error",
        category: "Registration",
        message: `Tool "${registeredTool}" is registered but file doesn't exist`,
        file: "src/index.ts",
        suggestion: `Remove registration or create src/tools/${registeredTool}.ts`
      });
    }
  }
  const configIssues = await validateConfiguration(cwd);
  issues.push(...configIssues);
  if (metadata) {
    const metadataIssues = await validateMetadata(
      metadata,
      actualTools,
      registeredTools,
      cwd
    );
    issues.push(...metadataIssues);
  }
  return createResult(issues, options.strict);
}
async function discoverTools(toolsDir) {
  try {
    const files = await fs.readdir(toolsDir);
    return files.filter((f) => f.endsWith(".ts") && !f.endsWith(".test.ts")).map((f) => path.join(toolsDir, f));
  } catch (error) {
    return [];
  }
}
async function checkToolRegistrations(indexPath) {
  try {
    const content = await fs.readFile(indexPath, "utf-8");
    const registered = [];
    const registerRegex = /register(\w+)Tool\(this\.server\)/g;
    let match;
    while ((match = registerRegex.exec(content)) !== null) {
      const toolName = toKebabCase(match[1]);
      registered.push(toolName);
    }
    return registered;
  } catch (error) {
    return [];
  }
}
async function validateYaml(yamlPath, toolName) {
  const issues = [];
  try {
    const content = await fs.readFile(yamlPath, "utf-8");
    const data = yaml.parse(content);
    if (!data.name) {
      issues.push({
        severity: "error",
        category: "YAML",
        message: `Integration test for "${toolName}" is missing "name" field`,
        file: yamlPath
      });
    }
    if (!data.tool) {
      issues.push({
        severity: "error",
        category: "YAML",
        message: `Integration test for "${toolName}" is missing "tool" field`,
        file: yamlPath
      });
    }
    if (!data.assertions || !Array.isArray(data.assertions)) {
      issues.push({
        severity: "error",
        category: "YAML",
        message: `Integration test for "${toolName}" is missing "assertions" array`,
        file: yamlPath
      });
    }
    if (data.tool && data.tool !== toolName) {
      issues.push({
        severity: "warning",
        category: "YAML",
        message: `Integration test tool name "${data.tool}" doesn't match file name "${toolName}"`,
        file: yamlPath
      });
    }
  } catch (error) {
    issues.push({
      severity: "error",
      category: "YAML",
      message: `Integration test for "${toolName}" has invalid YAML: ${error instanceof Error ? error.message : String(error)}`,
      file: yamlPath
    });
  }
  return issues;
}
async function validateConfiguration(cwd) {
  const issues = [];
  const wranglerJsoncPath = path.join(cwd, "wrangler.jsonc");
  const wranglerJsonPath = path.join(cwd, "wrangler.json");
  let wranglerPath = null;
  if (await fileExists(wranglerJsoncPath)) {
    wranglerPath = wranglerJsoncPath;
  } else if (await fileExists(wranglerJsonPath)) {
    wranglerPath = wranglerJsonPath;
  }
  if (!wranglerPath) {
    issues.push({
      severity: "error",
      category: "Configuration",
      message: "wrangler.jsonc or wrangler.json not found",
      suggestion: "This project needs a Cloudflare Workers configuration file"
    });
    return issues;
  }
  let config;
  try {
    const content = await fs.readFile(wranglerPath, "utf-8");
    const jsonContent = content.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/.*/g, "");
    config = JSON.parse(jsonContent);
  } catch (error) {
    issues.push({
      severity: "error",
      category: "Configuration",
      message: `Invalid JSON in ${path.basename(wranglerPath)}: ${error instanceof Error ? error.message : String(error)}`,
      file: wranglerPath,
      suggestion: "Fix JSON syntax errors"
    });
    return issues;
  }
  const requiredFields = ["name", "main", "compatibility_date"];
  for (const field of requiredFields) {
    if (!config[field]) {
      issues.push({
        severity: "error",
        category: "Configuration",
        message: `Missing required field "${field}" in ${path.basename(wranglerPath)}`,
        file: wranglerPath
      });
    }
  }
  if (!config.durable_objects) {
    issues.push({
      severity: "error",
      category: "Configuration",
      message: "Missing 'durable_objects' configuration",
      file: wranglerPath,
      suggestion: 'Add: "durable_objects": { "bindings": [{ "name": "MCP_OBJECT", "class_name": "MCPServerAgent" }] }'
    });
  } else {
    const durableObjects = config.durable_objects;
    const bindings = durableObjects.bindings;
    if (!bindings || !Array.isArray(bindings)) {
      issues.push({
        severity: "error",
        category: "Configuration",
        message: "durable_objects.bindings must be an array",
        file: wranglerPath
      });
    } else {
      const mcpBinding = bindings.find(
        (b) => b.name === "MCP_OBJECT"
      );
      if (!mcpBinding) {
        issues.push({
          severity: "error",
          category: "Configuration",
          message: 'Missing "MCP_OBJECT" binding in durable_objects.bindings',
          file: wranglerPath,
          suggestion: 'Add: { "name": "MCP_OBJECT", "class_name": "MCPServerAgent" }'
        });
      } else {
        if (!mcpBinding.class_name) {
          issues.push({
            severity: "error",
            category: "Configuration",
            message: "MCP_OBJECT binding is missing class_name",
            file: wranglerPath
          });
        } else {
          const indexPath = path.join(cwd, "src", "index.ts");
          try {
            const indexContent = await fs.readFile(indexPath, "utf-8");
            const className = mcpBinding.class_name;
            const classRegex = new RegExp(
              `export\\s+class\\s+${className}\\s+extends\\s+McpAgent`
            );
            if (!classRegex.test(indexContent)) {
              issues.push({
                severity: "error",
                category: "Configuration",
                message: `Class "${className}" not found in src/index.ts or doesn't extend McpAgent`,
                file: wranglerPath,
                suggestion: `Ensure src/index.ts exports: export class ${className} extends McpAgent<Env>`
              });
            }
          } catch (error) {
          }
        }
      }
    }
  }
  if (!config.migrations) {
    issues.push({
      severity: "error",
      category: "Configuration",
      message: "Missing 'migrations' configuration (required for Agents)",
      file: wranglerPath,
      suggestion: 'Add: "migrations": [{ "tag": "v1", "new_sqlite_classes": ["MCPServerAgent"] }]'
    });
  } else {
    const migrations = config.migrations;
    if (!Array.isArray(migrations)) {
      issues.push({
        severity: "error",
        category: "Configuration",
        message: "migrations must be an array",
        file: wranglerPath
      });
    } else if (migrations.length === 0) {
      issues.push({
        severity: "error",
        category: "Configuration",
        message: "migrations array is empty",
        file: wranglerPath,
        suggestion: 'Add at least one migration: { "tag": "v1", "new_sqlite_classes": ["MCPServerAgent"] }'
      });
    } else {
      const hasSqliteClasses = migrations.some((m) => {
        const sqliteClasses = m.new_sqlite_classes;
        return Array.isArray(sqliteClasses) && sqliteClasses.some(
          (c) => c.includes("MCPServerAgent") || c.includes("McpAgent")
        );
      });
      if (!hasSqliteClasses) {
        issues.push({
          severity: "warning",
          category: "Configuration",
          message: "No migration includes MCPServerAgent in new_sqlite_classes",
          file: wranglerPath,
          suggestion: "Add your Agent class to new_sqlite_classes in migrations"
        });
      }
    }
  }
  if (config.mcp) {
    issues.push({
      severity: "error",
      category: "Configuration",
      message: 'Deprecated "mcp" field found (this field is not recognized by wrangler)',
      file: wranglerPath,
      suggestion: 'Remove "mcp" field and use "durable_objects" instead (see above)'
    });
  }
  return issues;
}
async function validateMetadata(metadata, actualTools, registeredTools, cwd) {
  const issues = [];
  if (!metadata.tools || !Array.isArray(metadata.tools)) {
    issues.push({
      severity: "warning",
      category: "Metadata",
      message: ".mcp-template.json is missing tools array",
      file: ".mcp-template.json",
      suggestion: "Tools array should track all tools in the project"
    });
    return issues;
  }
  const actualToolNames = actualTools.map((f) => path.basename(f, path.extname(f))).filter((name) => !name.startsWith("_example"));
  for (const tool of metadata.tools) {
    if (!actualToolNames.includes(tool.name)) {
      issues.push({
        severity: "warning",
        category: "Metadata",
        message: `Tool "${tool.name}" in .mcp-template.json doesn't exist`,
        file: ".mcp-template.json",
        suggestion: "Remove from tools array or create the tool file"
      });
    }
  }
  for (const toolName of actualToolNames) {
    const inMetadata = metadata.tools.find((t) => t.name === toolName);
    if (!inMetadata) {
      issues.push({
        severity: "info",
        category: "Metadata",
        message: `Tool "${toolName}" exists but not tracked in .mcp-template.json`,
        file: ".mcp-template.json",
        suggestion: "Add to tools array for better tracking"
      });
    } else {
      const isRegistered = registeredTools.includes(toolName);
      if (inMetadata.registered !== isRegistered) {
        issues.push({
          severity: "info",
          category: "Metadata",
          message: `Tool "${toolName}" registration status in .mcp-template.json is incorrect`,
          file: ".mcp-template.json"
        });
      }
      const unitTestPath = path.join(
        cwd,
        "test",
        "unit",
        "tools",
        `${toolName}.test.ts`
      );
      const hasUnitTest = await fileExists(unitTestPath);
      if (inMetadata.hasUnitTest !== hasUnitTest) {
        issues.push({
          severity: "info",
          category: "Metadata",
          message: `Tool "${toolName}" unit test status in .mcp-template.json is incorrect`,
          file: ".mcp-template.json"
        });
      }
    }
  }
  return issues;
}
async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}
function createResult(issues, strict = false) {
  const summary = {
    errors: issues.filter((i) => i.severity === "error").length,
    warnings: issues.filter((i) => i.severity === "warning").length,
    info: issues.filter((i) => i.severity === "info").length
  };
  const passed = strict ? summary.errors === 0 && summary.warnings === 0 : summary.errors === 0;
  return { passed, issues, summary };
}
function printValidationResults(result) {
  if (result.issues.length === 0) {
    console.log("\u2705 No issues found! Project is valid.\n");
    return;
  }
  const byCategory = /* @__PURE__ */ new Map();
  for (const issue of result.issues) {
    const existing = byCategory.get(issue.category) || [];
    existing.push(issue);
    byCategory.set(issue.category, existing);
  }
  for (const [category, issues] of byCategory) {
    console.log(`
${category}:`);
    for (const issue of issues) {
      const icon = issue.severity === "error" ? "\u274C" : issue.severity === "warning" ? "\u26A0\uFE0F" : "\u2139\uFE0F";
      console.log(`  ${icon} ${issue.message}`);
      if (issue.file) {
        console.log(`     File: ${issue.file}`);
      }
      if (issue.suggestion) {
        console.log(`     Suggestion: ${issue.suggestion}`);
      }
    }
  }
  console.log(`
${"=".repeat(60)}`);
  console.log(`Summary: ${result.summary.errors} errors, ${result.summary.warnings} warnings, ${result.summary.info} info`);
  if (result.passed) {
    console.log("\u2705 Validation passed (no critical errors)\n");
  } else {
    console.log("\u274C Validation failed (fix errors above)\n");
  }
}

export { createValidateCommand, validateProject };
//# sourceMappingURL=validate.js.map
//# sourceMappingURL=validate.js.map