{"version":3,"sources":["../../../src/core/commands/shared/utils.ts","../../../src/core/commands/validate.ts"],"names":[],"mappings":"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","file":"validate.js","sourcesContent":["/**\n * Shared Utility Functions\n *\n * Common utilities used across multiple commands.\n * All functions are pure and have no side effects.\n */\n\nimport { access } from \"node:fs/promises\";\n\n/**\n * Convert kebab-case to PascalCase\n *\n * @param str - String in kebab-case format\n * @returns String in PascalCase format\n *\n * @example\n * toPascalCase(\"my-tool-name\") ‚Üí \"MyToolName\"\n * toPascalCase(\"api-client\") ‚Üí \"ApiClient\"\n */\nexport function toPascalCase(str: string): string {\n\treturn str\n\t\t.split(\"-\")\n\t\t.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n\t\t.join(\"\");\n}\n\n/**\n * Convert PascalCase to kebab-case\n *\n * @param str - String in PascalCase format\n * @returns String in kebab-case format\n *\n * @example\n * toKebabCase(\"MyToolName\") ‚Üí \"my-tool-name\"\n * toKebabCase(\"APIClient\") ‚Üí \"api-client\"\n */\nexport function toKebabCase(str: string): string {\n\treturn str\n\t\t.replace(/([A-Z])/g, \"-$1\")\n\t\t.toLowerCase()\n\t\t.replace(/^-/, \"\");\n}\n\n/**\n * Check if a file exists\n *\n * @param filePath - Path to check\n * @returns true if file exists, false otherwise\n *\n * @example\n * await fileExists(\"/path/to/file.ts\") ‚Üí true\n * await fileExists(\"/non/existent.ts\") ‚Üí false\n */\nexport async function fileExists(filePath: string): Promise<boolean> {\n\ttry {\n\t\tawait access(filePath);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Capitalize first letter of a string\n *\n * @param str - String to capitalize\n * @returns String with first letter capitalized\n *\n * @example\n * capitalize(\"hello\") ‚Üí \"Hello\"\n * capitalize(\"world\") ‚Üí \"World\"\n */\nexport function capitalize(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n","/**\n * Validate Command\n *\n * Validates an MCP server project:\n * - Checks tool registration in index.ts\n * - Verifies test files exist\n * - Validates integration test YAMLs\n * - Checks .mcp-template.json metadata\n */\n\nimport { Command } from \"commander\";\nimport fs from \"node:fs/promises\";\nimport path from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport yaml from \"yaml\";\nimport { toKebabCase, capitalize } from \"./shared/utils.js\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n/**\n * Validation issue severity\n */\nexport type IssueSeverity = \"error\" | \"warning\" | \"info\";\n\n/**\n * Validation issue\n */\nexport interface ValidationIssue {\n\tseverity: IssueSeverity;\n\tcategory: string;\n\tmessage: string;\n\tfile?: string;\n\tsuggestion?: string;\n}\n\n/**\n * Validation result\n */\nexport interface ValidationResult {\n\tpassed: boolean;\n\tissues: ValidationIssue[];\n\tsummary: {\n\t\terrors: number;\n\t\twarnings: number;\n\t\tinfo: number;\n\t};\n}\n\n/**\n * Tool metadata\n */\ninterface ToolMetadata {\n\tname: string;\n\tfile: string;\n\tregistered: boolean;\n\thasUnitTest: boolean;\n\thasIntegrationTest: boolean;\n}\n\n/**\n * MCP Template metadata\n */\ninterface McpTemplateMetadata {\n\tid: string;\n\tversion: string;\n\tname: string;\n\tscaffolded_at: string;\n\ttools: ToolMetadata[];\n\t[key: string]: unknown;\n}\n\n/**\n * Create validate command\n */\nexport function createValidateCommand(): Command {\n\treturn new Command(\"validate\")\n\t\t.description(\"Validate MCP server project structure and configuration\")\n\t\t.option(\"--fix\", \"Automatically fix issues where possible\")\n\t\t.option(\"--strict\", \"Fail on warnings (not just errors)\")\n\t\t.option(\"--json\", \"Output result as JSON\")\n\t\t.action(async (options) => {\n\t\t\tconst cwd = process.cwd();\n\n\t\t\tconst result = await validateProject(cwd, options);\n\n\t\t\t// Output results\n\t\t\tif (options.json) {\n\t\t\t\tconsole.log(JSON.stringify(result, null, 2));\n\t\t\t} else {\n\t\t\t\tconsole.log(\"üîç Validating MCP server project...\\n\");\n\t\t\t\tprintValidationResults(result);\n\t\t\t}\n\n\t\t\t// Exit with appropriate code\n\t\t\tif (!result.passed) {\n\t\t\t\tprocess.exit(1);\n\t\t\t}\n\t\t});\n}\n\n/**\n * Validate entire project\n */\nexport async function validateProject(\n\tcwd: string,\n\toptions: { fix?: boolean; strict?: boolean } = {},\n): Promise<ValidationResult> {\n\tconst issues: ValidationIssue[] = [];\n\n\t// 1. Check .mcp-template.json exists\n\tconst metadataPath = path.join(cwd, \".mcp-template.json\");\n\tlet metadata: McpTemplateMetadata | null = null;\n\n\ttry {\n\t\tconst metadataContent = await fs.readFile(metadataPath, \"utf-8\");\n\t\tmetadata = JSON.parse(metadataContent);\n\t} catch (error) {\n\t\tissues.push({\n\t\t\tseverity: \"error\",\n\t\t\tcategory: \"Metadata\",\n\t\t\tmessage: \".mcp-template.json not found or invalid\",\n\t\t\tfile: \".mcp-template.json\",\n\t\t\tsuggestion: \"Run this command from an MCP server project root\",\n\t\t});\n\t\treturn createResult(issues);\n\t}\n\n\t// 2. Discover actual tools in src/tools/\n\tconst toolsDir = path.join(cwd, \"src\", \"tools\");\n\tconst actualTools = await discoverTools(toolsDir);\n\n\t// 3. Check index.ts registrations\n\tconst indexPath = path.join(cwd, \"src\", \"index.ts\");\n\tconst registeredTools = await checkToolRegistrations(indexPath);\n\n\t// 4. Validate tool registrations\n\tfor (const toolFile of actualTools) {\n\t\tconst toolName = path.basename(toolFile, path.extname(toolFile));\n\n\t\t// Skip example files\n\t\tif (toolName.startsWith(\"_example\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check if tool is registered\n\t\tconst isRegistered = registeredTools.includes(toolName);\n\t\tif (!isRegistered) {\n\t\t\t// Convert kebab-case to PascalCase for function names\n\t\t\tconst pascalName = toolName\n\t\t\t\t.split(\"-\")\n\t\t\t\t.map((word) => capitalize(word))\n\t\t\t\t.join(\"\");\n\t\t\tissues.push({\n\t\t\t\tseverity: \"error\",\n\t\t\t\tcategory: \"Registration\",\n\t\t\t\tmessage: `Tool \"${toolName}\" is not registered in src/index.ts`,\n\t\t\t\tfile: toolFile,\n\t\t\t\tsuggestion: `Add: import { register${pascalName}Tool } from \"./tools/${toolName}.js\";\\nregister${pascalName}Tool(this.server);`,\n\t\t\t});\n\t\t}\n\n\t\t// Check for unit test\n\t\tconst unitTestPath = path.join(\n\t\t\tcwd,\n\t\t\t\"test\",\n\t\t\t\"unit\",\n\t\t\t\"tools\",\n\t\t\t`${toolName}.test.ts`,\n\t\t);\n\t\tconst hasUnitTest = await fileExists(unitTestPath);\n\t\tif (!hasUnitTest) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"warning\",\n\t\t\t\tcategory: \"Testing\",\n\t\t\t\tmessage: `Tool \"${toolName}\" is missing unit test`,\n\t\t\t\tfile: toolFile,\n\t\t\t\tsuggestion: `Create test/unit/tools/${toolName}.test.ts`,\n\t\t\t});\n\t\t}\n\n\t\t// Check for integration test\n\t\tconst integrationTestPath = path.join(\n\t\t\tcwd,\n\t\t\t\"test\",\n\t\t\t\"integration\",\n\t\t\t\"specs\",\n\t\t\t`${toolName}.yaml`,\n\t\t);\n\t\tconst hasIntegrationTest = await fileExists(integrationTestPath);\n\t\tif (!hasIntegrationTest) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"warning\",\n\t\t\t\tcategory: \"Testing\",\n\t\t\t\tmessage: `Tool \"${toolName}\" is missing integration test`,\n\t\t\t\tfile: toolFile,\n\t\t\t\tsuggestion: `Create test/integration/specs/${toolName}.yaml`,\n\t\t\t});\n\t\t}\n\n\t\t// Validate integration test YAML if it exists\n\t\tif (hasIntegrationTest) {\n\t\t\tconst yamlIssues = await validateYaml(integrationTestPath, toolName);\n\t\t\tissues.push(...yamlIssues);\n\t\t}\n\t}\n\n\t// 5. Check for orphaned registrations (registered but file doesn't exist)\n\tfor (const registeredTool of registeredTools) {\n\t\tconst toolFile = actualTools.find((f) => {\n\t\t\tconst fileName = path.basename(f, path.extname(f));\n\t\t\treturn fileName === registeredTool;\n\t\t});\n\t\tif (!toolFile) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"error\",\n\t\t\t\tcategory: \"Registration\",\n\t\t\t\tmessage: `Tool \"${registeredTool}\" is registered but file doesn't exist`,\n\t\t\t\tfile: \"src/index.ts\",\n\t\t\t\tsuggestion: `Remove registration or create src/tools/${registeredTool}.ts`,\n\t\t\t});\n\t\t}\n\t}\n\n\t// 6. Validate wrangler.jsonc configuration\n\tconst configIssues = await validateConfiguration(cwd);\n\tissues.push(...configIssues);\n\n\t// 7. Validate .mcp-template.json metadata matches reality\n\tif (metadata) {\n\t\tconst metadataIssues = await validateMetadata(\n\t\t\tmetadata,\n\t\t\tactualTools,\n\t\t\tregisteredTools,\n\t\t\tcwd,\n\t\t);\n\t\tissues.push(...metadataIssues);\n\t}\n\n\treturn createResult(issues, options.strict);\n}\n\n/**\n * Discover tool files in src/tools/\n */\nasync function discoverTools(toolsDir: string): Promise<string[]> {\n\ttry {\n\t\tconst files = await fs.readdir(toolsDir);\n\t\treturn files\n\t\t\t.filter((f) => f.endsWith(\".ts\") && !f.endsWith(\".test.ts\"))\n\t\t\t.map((f) => path.join(toolsDir, f));\n\t} catch (error) {\n\t\treturn [];\n\t}\n}\n\n/**\n * Check which tools are registered in src/index.ts\n */\nasync function checkToolRegistrations(indexPath: string): Promise<string[]> {\n\ttry {\n\t\tconst content = await fs.readFile(indexPath, \"utf-8\");\n\t\tconst registered: string[] = [];\n\n\t\t// Match: registerXxxTool(this.server);\n\t\tconst registerRegex = /register(\\w+)Tool\\(this\\.server\\)/g;\n\t\tlet match: RegExpExecArray | null;\n\n\t\twhile ((match = registerRegex.exec(content)) !== null) {\n\t\t\tconst toolName = toKebabCase(match[1]);\n\t\t\tregistered.push(toolName);\n\t\t}\n\n\t\treturn registered;\n\t} catch (error) {\n\t\treturn [];\n\t}\n}\n\n/**\n * Validate integration test YAML\n */\nasync function validateYaml(\n\tyamlPath: string,\n\ttoolName: string,\n): Promise<ValidationIssue[]> {\n\tconst issues: ValidationIssue[] = [];\n\n\ttry {\n\t\tconst content = await fs.readFile(yamlPath, \"utf-8\");\n\t\tconst data = yaml.parse(content);\n\n\t\t// Check required fields\n\t\tif (!data.name) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"error\",\n\t\t\t\tcategory: \"YAML\",\n\t\t\t\tmessage: `Integration test for \"${toolName}\" is missing \"name\" field`,\n\t\t\t\tfile: yamlPath,\n\t\t\t});\n\t\t}\n\n\t\tif (!data.tool) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"error\",\n\t\t\t\tcategory: \"YAML\",\n\t\t\t\tmessage: `Integration test for \"${toolName}\" is missing \"tool\" field`,\n\t\t\t\tfile: yamlPath,\n\t\t\t});\n\t\t}\n\n\t\tif (!data.assertions || !Array.isArray(data.assertions)) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"error\",\n\t\t\t\tcategory: \"YAML\",\n\t\t\t\tmessage: `Integration test for \"${toolName}\" is missing \"assertions\" array`,\n\t\t\t\tfile: yamlPath,\n\t\t\t});\n\t\t}\n\n\t\t// Check that tool name matches\n\t\tif (data.tool && data.tool !== toolName) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"warning\",\n\t\t\t\tcategory: \"YAML\",\n\t\t\t\tmessage: `Integration test tool name \"${data.tool}\" doesn't match file name \"${toolName}\"`,\n\t\t\t\tfile: yamlPath,\n\t\t\t});\n\t\t}\n\t} catch (error) {\n\t\tissues.push({\n\t\t\tseverity: \"error\",\n\t\t\tcategory: \"YAML\",\n\t\t\tmessage: `Integration test for \"${toolName}\" has invalid YAML: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\tfile: yamlPath,\n\t\t});\n\t}\n\n\treturn issues;\n}\n\n/**\n * Validate wrangler.jsonc configuration\n */\nasync function validateConfiguration(cwd: string): Promise<ValidationIssue[]> {\n\tconst issues: ValidationIssue[] = [];\n\n\t// Check for wrangler.jsonc or wrangler.json\n\tconst wranglerJsoncPath = path.join(cwd, \"wrangler.jsonc\");\n\tconst wranglerJsonPath = path.join(cwd, \"wrangler.json\");\n\n\tlet wranglerPath: string | null = null;\n\tif (await fileExists(wranglerJsoncPath)) {\n\t\twranglerPath = wranglerJsoncPath;\n\t} else if (await fileExists(wranglerJsonPath)) {\n\t\twranglerPath = wranglerJsonPath;\n\t}\n\n\tif (!wranglerPath) {\n\t\tissues.push({\n\t\t\tseverity: \"error\",\n\t\t\tcategory: \"Configuration\",\n\t\t\tmessage: \"wrangler.jsonc or wrangler.json not found\",\n\t\t\tsuggestion:\n\t\t\t\t\"This project needs a Cloudflare Workers configuration file\",\n\t\t});\n\t\treturn issues;\n\t}\n\n\t// Parse configuration (handle JSONC comments)\n\tlet config: Record<string, unknown>;\n\ttry {\n\t\tconst content = await fs.readFile(wranglerPath, \"utf-8\");\n\t\t// Simple JSONC comment removal (good enough for validation)\n\t\tconst jsonContent = content\n\t\t\t.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\") // Remove /* */ comments\n\t\t\t.replace(/\\/\\/.*/g, \"\"); // Remove // comments\n\t\tconfig = JSON.parse(jsonContent);\n\t} catch (error) {\n\t\tissues.push({\n\t\t\tseverity: \"error\",\n\t\t\tcategory: \"Configuration\",\n\t\t\tmessage: `Invalid JSON in ${path.basename(wranglerPath)}: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\tfile: wranglerPath,\n\t\t\tsuggestion: \"Fix JSON syntax errors\",\n\t\t});\n\t\treturn issues;\n\t}\n\n\t// Check required fields\n\tconst requiredFields = [\"name\", \"main\", \"compatibility_date\"];\n\tfor (const field of requiredFields) {\n\t\tif (!config[field]) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"error\",\n\t\t\t\tcategory: \"Configuration\",\n\t\t\t\tmessage: `Missing required field \"${field}\" in ${path.basename(wranglerPath)}`,\n\t\t\t\tfile: wranglerPath,\n\t\t\t});\n\t\t}\n\t}\n\n\t// Check for durable_objects configuration\n\tif (!config.durable_objects) {\n\t\tissues.push({\n\t\t\tseverity: \"error\",\n\t\t\tcategory: \"Configuration\",\n\t\t\tmessage: \"Missing 'durable_objects' configuration\",\n\t\t\tfile: wranglerPath,\n\t\t\tsuggestion:\n\t\t\t\t'Add: \"durable_objects\": { \"bindings\": [{ \"name\": \"MCP_OBJECT\", \"class_name\": \"MCPServerAgent\" }] }',\n\t\t});\n\t} else {\n\t\tconst durableObjects = config.durable_objects as Record<string, unknown>;\n\t\tconst bindings = durableObjects.bindings as Array<Record<string, unknown>>;\n\n\t\tif (!bindings || !Array.isArray(bindings)) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"error\",\n\t\t\t\tcategory: \"Configuration\",\n\t\t\t\tmessage: \"durable_objects.bindings must be an array\",\n\t\t\t\tfile: wranglerPath,\n\t\t\t});\n\t\t} else {\n\t\t\t// Check for MCP_OBJECT binding\n\t\t\tconst mcpBinding = bindings.find(\n\t\t\t\t(b) => b.name === \"MCP_OBJECT\",\n\t\t\t);\n\t\t\tif (!mcpBinding) {\n\t\t\t\tissues.push({\n\t\t\t\t\tseverity: \"error\",\n\t\t\t\t\tcategory: \"Configuration\",\n\t\t\t\t\tmessage:\n\t\t\t\t\t\t'Missing \"MCP_OBJECT\" binding in durable_objects.bindings',\n\t\t\t\t\tfile: wranglerPath,\n\t\t\t\t\tsuggestion:\n\t\t\t\t\t\t'Add: { \"name\": \"MCP_OBJECT\", \"class_name\": \"MCPServerAgent\" }',\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Verify class_name is set\n\t\t\t\tif (!mcpBinding.class_name) {\n\t\t\t\t\tissues.push({\n\t\t\t\t\t\tseverity: \"error\",\n\t\t\t\t\t\tcategory: \"Configuration\",\n\t\t\t\t\t\tmessage: \"MCP_OBJECT binding is missing class_name\",\n\t\t\t\t\t\tfile: wranglerPath,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Verify class exists in src/index.ts\n\t\t\t\t\tconst indexPath = path.join(cwd, \"src\", \"index.ts\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst indexContent = await fs.readFile(indexPath, \"utf-8\");\n\t\t\t\t\t\tconst className = mcpBinding.class_name as string;\n\t\t\t\t\t\tconst classRegex = new RegExp(\n\t\t\t\t\t\t\t`export\\\\s+class\\\\s+${className}\\\\s+extends\\\\s+McpAgent`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!classRegex.test(indexContent)) {\n\t\t\t\t\t\t\tissues.push({\n\t\t\t\t\t\t\t\tseverity: \"error\",\n\t\t\t\t\t\t\t\tcategory: \"Configuration\",\n\t\t\t\t\t\t\t\tmessage: `Class \"${className}\" not found in src/index.ts or doesn't extend McpAgent`,\n\t\t\t\t\t\t\t\tfile: wranglerPath,\n\t\t\t\t\t\t\t\tsuggestion: `Ensure src/index.ts exports: export class ${className} extends McpAgent<Env>`,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// src/index.ts not found or unreadable - will be caught by other validation\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check for migrations configuration\n\tif (!config.migrations) {\n\t\tissues.push({\n\t\t\tseverity: \"error\",\n\t\t\tcategory: \"Configuration\",\n\t\t\tmessage: \"Missing 'migrations' configuration (required for Agents)\",\n\t\t\tfile: wranglerPath,\n\t\t\tsuggestion:\n\t\t\t\t'Add: \"migrations\": [{ \"tag\": \"v1\", \"new_sqlite_classes\": [\"MCPServerAgent\"] }]',\n\t\t});\n\t} else {\n\t\tconst migrations = config.migrations as Array<Record<string, unknown>>;\n\t\tif (!Array.isArray(migrations)) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"error\",\n\t\t\t\tcategory: \"Configuration\",\n\t\t\t\tmessage: \"migrations must be an array\",\n\t\t\t\tfile: wranglerPath,\n\t\t\t});\n\t\t} else if (migrations.length === 0) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"error\",\n\t\t\t\tcategory: \"Configuration\",\n\t\t\t\tmessage: \"migrations array is empty\",\n\t\t\t\tfile: wranglerPath,\n\t\t\t\tsuggestion:\n\t\t\t\t\t'Add at least one migration: { \"tag\": \"v1\", \"new_sqlite_classes\": [\"MCPServerAgent\"] }',\n\t\t\t});\n\t\t} else {\n\t\t\t// Check that at least one migration has new_sqlite_classes with MCPServerAgent\n\t\t\tconst hasSqliteClasses = migrations.some((m) => {\n\t\t\t\tconst sqliteClasses = m.new_sqlite_classes as string[];\n\t\t\t\treturn (\n\t\t\t\t\tArray.isArray(sqliteClasses) &&\n\t\t\t\t\tsqliteClasses.some((c) =>\n\t\t\t\t\t\tc.includes(\"MCPServerAgent\") || c.includes(\"McpAgent\"),\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tif (!hasSqliteClasses) {\n\t\t\t\tissues.push({\n\t\t\t\t\tseverity: \"warning\",\n\t\t\t\t\tcategory: \"Configuration\",\n\t\t\t\t\tmessage:\n\t\t\t\t\t\t\"No migration includes MCPServerAgent in new_sqlite_classes\",\n\t\t\t\t\tfile: wranglerPath,\n\t\t\t\t\tsuggestion:\n\t\t\t\t\t\t\"Add your Agent class to new_sqlite_classes in migrations\",\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check for deprecated 'mcp' field (from old template)\n\tif (config.mcp) {\n\t\tissues.push({\n\t\t\tseverity: \"error\",\n\t\t\tcategory: \"Configuration\",\n\t\t\tmessage:\n\t\t\t\t'Deprecated \"mcp\" field found (this field is not recognized by wrangler)',\n\t\t\tfile: wranglerPath,\n\t\t\tsuggestion:\n\t\t\t\t'Remove \"mcp\" field and use \"durable_objects\" instead (see above)',\n\t\t});\n\t}\n\n\treturn issues;\n}\n\n/**\n * Validate .mcp-template.json metadata\n */\nasync function validateMetadata(\n\tmetadata: McpTemplateMetadata,\n\tactualTools: string[],\n\tregisteredTools: string[],\n\tcwd: string,\n): Promise<ValidationIssue[]> {\n\tconst issues: ValidationIssue[] = [];\n\n\t// Check if tools array exists\n\tif (!metadata.tools || !Array.isArray(metadata.tools)) {\n\t\tissues.push({\n\t\t\tseverity: \"warning\",\n\t\t\tcategory: \"Metadata\",\n\t\t\tmessage: \".mcp-template.json is missing tools array\",\n\t\t\tfile: \".mcp-template.json\",\n\t\t\tsuggestion: \"Tools array should track all tools in the project\",\n\t\t});\n\t\treturn issues;\n\t}\n\n\t// Get actual tool names (without examples)\n\tconst actualToolNames = actualTools\n\t\t.map((f) => path.basename(f, path.extname(f)))\n\t\t.filter((name) => !name.startsWith(\"_example\"));\n\n\t// Check for tools in metadata that don't exist\n\tfor (const tool of metadata.tools) {\n\t\tif (!actualToolNames.includes(tool.name)) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"warning\",\n\t\t\t\tcategory: \"Metadata\",\n\t\t\t\tmessage: `Tool \"${tool.name}\" in .mcp-template.json doesn't exist`,\n\t\t\t\tfile: \".mcp-template.json\",\n\t\t\t\tsuggestion: \"Remove from tools array or create the tool file\",\n\t\t\t});\n\t\t}\n\t}\n\n\t// Check for tools that exist but aren't in metadata\n\tfor (const toolName of actualToolNames) {\n\t\tconst inMetadata = metadata.tools.find((t) => t.name === toolName);\n\t\tif (!inMetadata) {\n\t\t\tissues.push({\n\t\t\t\tseverity: \"info\",\n\t\t\t\tcategory: \"Metadata\",\n\t\t\t\tmessage: `Tool \"${toolName}\" exists but not tracked in .mcp-template.json`,\n\t\t\t\tfile: \".mcp-template.json\",\n\t\t\t\tsuggestion: \"Add to tools array for better tracking\",\n\t\t\t});\n\t\t} else {\n\t\t\t// Verify metadata is accurate\n\t\t\tconst isRegistered = registeredTools.includes(toolName);\n\t\t\tif (inMetadata.registered !== isRegistered) {\n\t\t\t\tissues.push({\n\t\t\t\t\tseverity: \"info\",\n\t\t\t\t\tcategory: \"Metadata\",\n\t\t\t\t\tmessage: `Tool \"${toolName}\" registration status in .mcp-template.json is incorrect`,\n\t\t\t\t\tfile: \".mcp-template.json\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst unitTestPath = path.join(\n\t\t\t\tcwd,\n\t\t\t\t\"test\",\n\t\t\t\t\"unit\",\n\t\t\t\t\"tools\",\n\t\t\t\t`${toolName}.test.ts`,\n\t\t\t);\n\t\t\tconst hasUnitTest = await fileExists(unitTestPath);\n\t\t\tif (inMetadata.hasUnitTest !== hasUnitTest) {\n\t\t\t\tissues.push({\n\t\t\t\t\tseverity: \"info\",\n\t\t\t\t\tcategory: \"Metadata\",\n\t\t\t\t\tmessage: `Tool \"${toolName}\" unit test status in .mcp-template.json is incorrect`,\n\t\t\t\t\tfile: \".mcp-template.json\",\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn issues;\n}\n\n/**\n * Check if file exists\n */\nasync function fileExists(filePath: string): Promise<boolean> {\n\ttry {\n\t\tawait fs.access(filePath);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Create validation result\n */\nfunction createResult(\n\tissues: ValidationIssue[],\n\tstrict = false,\n): ValidationResult {\n\tconst summary = {\n\t\terrors: issues.filter((i) => i.severity === \"error\").length,\n\t\twarnings: issues.filter((i) => i.severity === \"warning\").length,\n\t\tinfo: issues.filter((i) => i.severity === \"info\").length,\n\t};\n\n\tconst passed = strict\n\t\t? summary.errors === 0 && summary.warnings === 0\n\t\t: summary.errors === 0;\n\n\treturn { passed, issues, summary };\n}\n\n/**\n * Print validation results\n */\nfunction printValidationResults(result: ValidationResult): void {\n\tif (result.issues.length === 0) {\n\t\tconsole.log(\"‚úÖ No issues found! Project is valid.\\n\");\n\t\treturn;\n\t}\n\n\t// Group issues by category\n\tconst byCategory = new Map<string, ValidationIssue[]>();\n\tfor (const issue of result.issues) {\n\t\tconst existing = byCategory.get(issue.category) || [];\n\t\texisting.push(issue);\n\t\tbyCategory.set(issue.category, existing);\n\t}\n\n\t// Print each category\n\tfor (const [category, issues] of byCategory) {\n\t\tconsole.log(`\\n${category}:`);\n\t\tfor (const issue of issues) {\n\t\t\tconst icon =\n\t\t\t\tissue.severity === \"error\"\n\t\t\t\t\t? \"‚ùå\"\n\t\t\t\t\t: issue.severity === \"warning\"\n\t\t\t\t\t\t? \"‚ö†Ô∏è\"\n\t\t\t\t\t\t: \"‚ÑπÔ∏è\";\n\t\t\tconsole.log(`  ${icon} ${issue.message}`);\n\t\t\tif (issue.file) {\n\t\t\t\tconsole.log(`     File: ${issue.file}`);\n\t\t\t}\n\t\t\tif (issue.suggestion) {\n\t\t\t\tconsole.log(`     Suggestion: ${issue.suggestion}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Print summary\n\tconsole.log(`\\n${\"=\".repeat(60)}`);\n\tconsole.log(`Summary: ${result.summary.errors} errors, ${result.summary.warnings} warnings, ${result.summary.info} info`);\n\n\tif (result.passed) {\n\t\tconsole.log(\"‚úÖ Validation passed (no critical errors)\\n\");\n\t} else {\n\t\tconsole.log(\"‚ùå Validation failed (fix errors above)\\n\");\n\t}\n}\n\n// ============================================================================\n// Public API Exports\n// ============================================================================\n\n/**\n * These exports allow programmatic usage of the validation system.\n * Example:\n *\n * import { validateProject } from 'mcp-server-kit/validation';\n *\n * const result = await validateProject(process.cwd(), { strict: true });\n * if (!result.passed) {\n *   for (const issue of result.issues) {\n *     console.error(`${issue.severity}: ${issue.message}`);\n *   }\n * }\n */\n\n// Types are exported for programmatic usage\n// validateProject is already exported above (line 100)\n"]}