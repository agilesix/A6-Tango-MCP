import fs, { readFile, writeFile, access, mkdir, cp, rm, readdir, stat } from 'fs/promises';
import { existsSync, statSync, readFileSync } from 'fs';
import path, { join, dirname } from 'path';
import Handlebars from 'handlebars';
import { fileURLToPath } from 'url';
import stripJsonComments from 'strip-json-comments';
import { z } from 'zod';
import { Command } from 'commander';

// src/core/commands/shared/backup-restore.ts
async function createBackup(cwd) {
  const timestamp = Date.now();
  const backupDir = join(cwd, `.backup-auth-${timestamp}`);
  const srcDir = join(cwd, "src");
  if (existsSync(srcDir)) {
    await cp(srcDir, join(backupDir, "src"), { recursive: true });
  }
  const filesToBackup = [
    "package.json",
    "wrangler.toml",
    "wrangler.jsonc",
    "wrangler.json",
    "vercel.json",
    "next.config.js",
    "next.config.mjs",
    "next.config.ts",
    "README.md",
    ".gitignore",
    ".env",
    ".env.local"
  ];
  for (const file of filesToBackup) {
    const filePath = join(cwd, file);
    if (existsSync(filePath)) {
      await cp(filePath, join(backupDir, file));
    }
  }
  return backupDir;
}
async function restoreFromBackup(backupDir, cwd) {
  if (!existsSync(backupDir)) {
    throw new Error(`Backup directory not found: ${backupDir}`);
  }
  const backupSrcDir = join(backupDir, "src");
  if (existsSync(backupSrcDir)) {
    const targetSrcDir = join(cwd, "src");
    if (existsSync(targetSrcDir)) {
      await rm(targetSrcDir, { recursive: true, force: true });
    }
    await cp(backupSrcDir, targetSrcDir, { recursive: true });
  }
  const backupFiles = await readdir(backupDir);
  for (const file of backupFiles) {
    if (file === "src") {
      continue;
    }
    const backupFilePath = join(backupDir, file);
    const targetFilePath = join(cwd, file);
    const stats = await stat(backupFilePath);
    if (stats.isFile()) {
      await cp(backupFilePath, targetFilePath);
    }
  }
}
async function removeBackup(backupDir) {
  if (existsSync(backupDir)) {
    await rm(backupDir, { recursive: true, force: true });
  }
}

// src/core/commands/shared/orchestration/scaffold-orchestrator.ts
var ScaffoldOrchestrator = class {
  /**
   * Execute scaffolding with given strategy
   *
   * Template Method that defines the scaffolding algorithm:
   * 1. Create context
   * 2. Validate
   * 3. Backup (if needed)
   * 4. Execute strategy
   * 5. Cleanup backup on success
   * 6. Rollback on failure
   *
   * @param cwd - Current working directory
   * @param config - Configuration for scaffolding
   * @param strategy - Strategy to execute
   * @param options - Optional orchestration options
   * @returns Result from strategy
   */
  async scaffold(cwd, config, strategy, options = {}) {
    const context = this.createContext(cwd, config, strategy);
    if (options.dryRun) {
      await strategy.validate(cwd, config);
      return context.result;
    }
    try {
      await strategy.validate(cwd, config);
      if (strategy.needsBackup() && !options.skipBackup) {
        context.backupDir = await createBackup(cwd);
      }
      await strategy.execute(context);
      if (context.backupDir) {
        await removeBackup(context.backupDir);
        context.backupDir = void 0;
      }
      return context.result;
    } catch (error) {
      if (context.backupDir) {
        try {
          await restoreFromBackup(context.backupDir, cwd);
          await removeBackup(context.backupDir);
        } catch (rollbackError) {
          const rollbackMsg = rollbackError instanceof Error ? rollbackError.message : String(rollbackError);
          throw new Error(
            `Original error: ${error instanceof Error ? error.message : String(error)}
Rollback also failed: ${rollbackMsg}`
          );
        }
      }
      throw error;
    }
  }
  /**
   * Create scaffolding context
   *
   * @param cwd - Current working directory
   * @param config - Configuration
   * @param strategy - Strategy (used to create initial result)
   * @returns Initial context
   */
  createContext(cwd, config, strategy) {
    return {
      cwd,
      config,
      result: strategy.createResult(),
      metadata: {}
    };
  }
};
var RegistrationService = class _RegistrationService {
  static ENTITY_ORDER = ["tool", "prompt", "resource"];
  /**
   * Register an entity in src/index.ts
   */
  async registerEntity(cwd, name, capitalizedName, config) {
    const indexPath = join(cwd, "src", "index.ts");
    if (!existsSync(indexPath)) {
      throw new Error("src/index.ts not found");
    }
    const content = await readFile(indexPath, "utf-8");
    const functionName = `register${capitalizedName}${config.functionSuffix}`;
    if (content.includes(functionName)) {
      console.warn(
        `  \u26A0\uFE0F  ${config.entityType.charAt(0).toUpperCase() + config.entityType.slice(1)} already registered in src/index.ts`
      );
      return;
    }
    const needsEnv = await this.functionNeedsEnv(
      cwd,
      name,
      functionName,
      config
    );
    const importStatement = `import { ${functionName} } from "${config.directory}${name}.js";`;
    const registrationCall = needsEnv ? `		${functionName}(this.server, this.env);` : `		${functionName}(this.server);`;
    let updatedContent = this.addImport(content, importStatement, config);
    updatedContent = this.addRegistrationCall(
      updatedContent,
      registrationCall,
      config
    );
    await writeFile(indexPath, updatedContent, "utf-8");
  }
  /**
   * Check if an entity is already registered
   */
  async isRegistered(cwd, capitalizedName, config) {
    const indexPath = join(cwd, "src", "index.ts");
    if (!existsSync(indexPath)) {
      return false;
    }
    const content = await readFile(indexPath, "utf-8");
    const functionName = `register${capitalizedName}${config.functionSuffix}`;
    return content.includes(functionName);
  }
  /**
   * Add import statement to the file
   */
  addImport(content, importStatement, config) {
    let updatedContent = content;
    const currentTypeRegex = this.getImportRegex(config.directory);
    const currentTypeMatches = Array.from(content.matchAll(currentTypeRegex));
    if (currentTypeMatches.length > 0) {
      const lastMatch = currentTypeMatches[currentTypeMatches.length - 1];
      const insertPos = lastMatch.index + lastMatch[0].length;
      return content.slice(0, insertPos) + `
${importStatement}` + content.slice(insertPos);
    }
    const currentIndex = _RegistrationService.ENTITY_ORDER.indexOf(
      config.entityType
    );
    for (let i = currentIndex - 1; i >= 0; i--) {
      const fallbackType = _RegistrationService.ENTITY_ORDER[i];
      const fallbackDir = `./${fallbackType}s/`;
      const fallbackRegex = this.getImportRegex(fallbackDir);
      const fallbackMatches = Array.from(content.matchAll(fallbackRegex));
      if (fallbackMatches.length > 0) {
        const lastMatch = fallbackMatches[fallbackMatches.length - 1];
        const insertPos = lastMatch.index + lastMatch[0].length;
        const comment = `

// ${config.entityTypePlural.charAt(0).toUpperCase() + config.entityTypePlural.slice(1)}
`;
        return content.slice(0, insertPos) + comment + importStatement + content.slice(insertPos);
      }
    }
    const lastImportMatch = content.match(
      /import\s+[^;]+;(?=\s*\n\s*(?:\/\*|\/\/|\n|export|class))/g
    );
    if (lastImportMatch) {
      const lastImport = lastImportMatch[lastImportMatch.length - 1];
      const insertPos = content.indexOf(lastImport) + lastImport.length;
      const comment = `

// ${config.entityTypePlural.charAt(0).toUpperCase() + config.entityTypePlural.slice(1)}
`;
      return content.slice(0, insertPos) + comment + importStatement + content.slice(insertPos);
    }
    return updatedContent;
  }
  /**
   * Add registration call to init() method
   */
  addRegistrationCall(content, registrationCall, config) {
    const initMethodRegex = /async\s+init\(\)\s*\{([^}]*)\}/;
    const initMatch = content.match(initMethodRegex);
    if (!initMatch) {
      return content;
    }
    const initBody = initMatch[1];
    const currentTypePattern = `register\\w+${config.functionSuffix}\\(this\\.server\\);`;
    const currentTypeRegex = new RegExp(`\\s+${currentTypePattern}`, "g");
    const currentTypeMatches = initBody.match(currentTypeRegex);
    if (currentTypeMatches) {
      const lastCall = currentTypeMatches[currentTypeMatches.length - 1];
      const insertPos2 = initMatch.index + initMatch[0].lastIndexOf(lastCall) + lastCall.length;
      return content.slice(0, insertPos2) + `
${registrationCall}` + content.slice(insertPos2);
    }
    const currentIndex = _RegistrationService.ENTITY_ORDER.indexOf(
      config.entityType
    );
    for (let i = currentIndex - 1; i >= 0; i--) {
      const fallbackType = _RegistrationService.ENTITY_ORDER[i];
      const fallbackSuffix = fallbackType.charAt(0).toUpperCase() + fallbackType.slice(1);
      const fallbackPattern = `register\\w+${fallbackSuffix}\\(this\\.server\\);`;
      const fallbackRegex = new RegExp(`\\s+${fallbackPattern}`, "g");
      const fallbackMatches = initBody.match(fallbackRegex);
      if (fallbackMatches) {
        const lastCall = fallbackMatches[fallbackMatches.length - 1];
        const insertPos2 = initMatch.index + initMatch[0].lastIndexOf(lastCall) + lastCall.length;
        const comment2 = `

		// Register all ${config.entityTypePlural}
`;
        return content.slice(0, insertPos2) + comment2 + registrationCall + content.slice(insertPos2);
      }
    }
    const insertPos = initMatch.index + initMatch[0].indexOf("{") + 1;
    const comment = `
		// Register all ${config.entityTypePlural}
`;
    return content.slice(0, insertPos) + comment + registrationCall + content.slice(insertPos);
  }
  /**
   * Get import regex pattern for a directory
   */
  getImportRegex(directory) {
    const escapedDir = directory.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return new RegExp(
      `import\\s+\\{[^}]+\\}\\s+from\\s+["']${escapedDir}[^"']+["'];`,
      "g"
    );
  }
  /**
   * Detect if a registration function needs the env parameter
   * Reads the entity file and checks the function signature
   */
  async functionNeedsEnv(cwd, name, functionName, config) {
    try {
      const entityPath = join(
        cwd,
        "src",
        config.entityTypePlural,
        `${name}.ts`
      );
      if (!existsSync(entityPath)) {
        return false;
      }
      const entityContent = await readFile(entityPath, "utf-8");
      const functionPattern = new RegExp(
        `export\\s+function\\s+${functionName}\\s*\\([^)]*env[^)]*\\)`,
        "i"
      );
      return functionPattern.test(entityContent);
    } catch (error) {
      return false;
    }
  }
};
var ValidationService = class {
  /**
   * Validate entity name format
   *
   * Names must:
   * - Start with a lowercase letter
   * - Contain only lowercase letters, numbers, and hyphens
   * - Follow kebab-case convention
   *
   * @throws Error if name is invalid
   */
  validateName(name, config) {
    const nameRegex = /^[a-z][a-z0-9-]*$/;
    if (!nameRegex.test(name)) {
      const entityName = config.entityType.charAt(0).toUpperCase() + config.entityType.slice(1);
      throw new Error(
        `${entityName} name must be lowercase with hyphens (e.g., my-${config.entityType})`
      );
    }
  }
  /**
   * Validate we're in a valid MCP project
   *
   * @throws Error if not in a valid project
   */
  validateProject(cwd) {
    const packageJsonPath = join(cwd, "package.json");
    if (!existsSync(packageJsonPath)) {
      throw new Error(
        "Not in a valid project directory (no package.json found)"
      );
    }
  }
  /**
   * Check if entity file already exists
   *
   * @throws Error if entity file already exists
   */
  validateFileNotExists(cwd, name, config) {
    const filePath = join(cwd, config.sourceDir, `${name}.ts`);
    if (existsSync(filePath)) {
      const entityName = config.entityType.charAt(0).toUpperCase() + config.entityType.slice(1);
      throw new Error(`${entityName} already exists: ${filePath}`);
    }
  }
  /**
   * Validate all basic requirements for entity creation
   *
   * @throws Error if any validation fails
   */
  validateEntity(cwd, name, config) {
    this.validateName(name, config);
    this.validateProject(cwd);
    this.validateFileNotExists(cwd, name, config);
  }
  /**
   * Validate resource-specific options
   *
   * @throws Error if options are invalid
   */
  validateResourceOptions(options) {
    if (options.static && options.dynamic) {
      throw new Error("Cannot use both --static and --dynamic flags");
    }
  }
  /**
   * Determine URI pattern for a resource
   *
   * - If uriPattern is explicitly provided, use it
   * - If --dynamic flag is set, use dynamic pattern (resource://{id})
   * - Otherwise, default to static pattern (config://name)
   */
  determineUriPattern(name, options) {
    if (options.uriPattern) {
      return options.uriPattern;
    }
    if (options.dynamic) {
      return "resource://{id}";
    }
    return `config://${name}`;
  }
};
var TemplateService = class {
  templateCache = /* @__PURE__ */ new Map();
  templatesDir;
  constructor() {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    let currentDir = __dirname;
    let templatesPath = "";
    for (let i = 0; i < 5; i++) {
      const candidatePath = join(currentDir, "templates/scaffolding");
      try {
        if (statSync(candidatePath).isDirectory()) {
          templatesPath = candidatePath;
          break;
        }
      } catch {
      }
      currentDir = dirname(currentDir);
    }
    if (!templatesPath) {
      throw new Error(
        `Could not locate templates/scaffolding directory. Searched from: ${__dirname}`
      );
    }
    this.templatesDir = templatesPath;
  }
  /**
   * Load and compile a Handlebars template
   */
  loadTemplate(templatePath) {
    if (this.templateCache.has(templatePath)) {
      return this.templateCache.get(templatePath);
    }
    const fullPath = join(this.templatesDir, templatePath);
    const templateContent = readFileSync(fullPath, "utf-8");
    const compiled = Handlebars.compile(templateContent, { noEscape: true });
    this.templateCache.set(templatePath, compiled);
    return compiled;
  }
  /**
   * Generate tool file content
   */
  generateToolFile(config) {
    const template = this.loadTemplate("entities/tool.hbs");
    return template(config);
  }
  /**
   * Generate prompt file content
   */
  generatePromptFile(config) {
    const template = this.loadTemplate("entities/prompt.hbs");
    return template(config);
  }
  /**
   * Generate resource file content
   */
  generateResourceFile(config) {
    const { uriPattern } = config;
    const hasVariables = uriPattern.includes("{") && uriPattern.includes("}");
    const variables = hasVariables ? Array.from(uriPattern.matchAll(/\{(\w+)\}/g)).map((m) => m[1]) : [];
    const context = {
      ...config,
      hasVariables,
      variables,
      variablesJoined: variables.join(", ")
    };
    const template = this.loadTemplate("entities/resource.hbs");
    return template(context);
  }
  /**
   * Generate entity file content based on entity type
   */
  generateEntityFile(config) {
    switch (config.entityType) {
      case "tool":
        return this.generateToolFile(config);
      case "prompt":
        return this.generatePromptFile(config);
      case "resource":
        if (!("uriPattern" in config)) {
          throw new Error("Resource template config must include uriPattern");
        }
        return this.generateResourceFile(config);
      default:
        throw new Error(`Unknown entity type: ${config.entityType}`);
    }
  }
  /**
   * Generate unit test file content
   */
  generateUnitTestFile(config) {
    const { entityType, name, capitalizedName } = config;
    const entityTypePlural = `${entityType}s`;
    const functionSuffix = entityType.charAt(0).toUpperCase() + entityType.slice(1);
    const context = {
      ...config,
      entityTypePlural,
      functionSuffix,
      isToolType: entityType === "tool",
      isPromptType: entityType === "prompt",
      isResourceType: entityType === "resource"
    };
    const template = this.loadTemplate("unit-tests/main.hbs");
    return template(context);
  }
  /**
   * Generate integration test YAML content
   */
  generateIntegrationTestYaml(config) {
    const { entityType, name, description } = config;
    if (entityType === "tool") {
      return this.generateToolIntegrationYaml(name, description);
    } else if (entityType === "prompt") {
      return this.generatePromptIntegrationYaml(name, description);
    } else if (entityType === "resource") {
      const uriPattern = config.uriPattern;
      return this.generateResourceIntegrationYaml(name, description, uriPattern);
    }
    throw new Error(`Unknown entity type: ${entityType}`);
  }
  /**
   * Generate tool integration test YAML
   */
  generateToolIntegrationYaml(name, description) {
    const context = {
      name,
      nameWithSpaces: name.replace(/_/g, " "),
      description: description || `Verify that ${name} tool works correctly`
    };
    const template = this.loadTemplate("integration-tests/tool.yaml.hbs");
    return template(context);
  }
  /**
   * Generate prompt integration test YAML
   */
  generatePromptIntegrationYaml(name, description) {
    const context = {
      name,
      nameWithSpaces: name.replace(/_/g, " "),
      description: description || `Verify that ${name} prompt works correctly`
    };
    const template = this.loadTemplate("integration-tests/prompt.yaml.hbs");
    return template(context);
  }
  /**
   * Generate resource integration test YAML
   */
  generateResourceIntegrationYaml(name, description, uriPattern) {
    const context = {
      name,
      nameWithSpaces: name.replace(/_/g, " "),
      description: description || "Test resource",
      uriPattern,
      uriPatternNoVars: uriPattern.replace(/\{[^}]+\}/g, "")
    };
    const template = this.loadTemplate("integration-tests/resource.yaml.hbs");
    return template(context);
  }
};
function getWranglerConfigPath(cwd) {
  const configFiles = ["wrangler.jsonc", "wrangler.json", "wrangler.toml"];
  for (const file of configFiles) {
    const path2 = join(cwd, file);
    if (existsSync(path2)) {
      return path2;
    }
  }
  return null;
}
function parseJSONC(content) {
  const stripped = stripJsonComments(content);
  return JSON.parse(stripped);
}
function toPascalCase(str) {
  return str.split("-").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join("");
}
function toKebabCase(str) {
  return str.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
}
async function fileExists(filePath) {
  try {
    await access(filePath);
    return true;
  } catch {
    return false;
  }
}

// src/core/commands/shared/binding-detection-service.ts
var BindingDetectionService = class {
  /**
   * Detect all bindings configured in wrangler.jsonc
   *
   * @param cwd - Project root directory
   * @returns Detected bindings organized by type
   */
  async detectBindings(cwd) {
    const bindings = {
      kv: [],
      d1: [],
      r2: []
    };
    const wranglerPath = getWranglerConfigPath(cwd);
    if (!wranglerPath || !existsSync(wranglerPath)) {
      return bindings;
    }
    try {
      const content = await readFile(wranglerPath, "utf-8");
      const config = parseJSONC(content);
      if (Array.isArray(config.kv_namespaces)) {
        bindings.kv = config.kv_namespaces.map((ns) => ns.binding).filter((b) => typeof b === "string" && b.length > 0);
      }
      if (Array.isArray(config.d1_databases)) {
        bindings.d1 = config.d1_databases.map((db) => db.binding).filter((b) => typeof b === "string" && b.length > 0);
      }
      if (Array.isArray(config.r2_buckets)) {
        bindings.r2 = config.r2_buckets.map((bucket) => bucket.binding).filter((b) => typeof b === "string" && b.length > 0);
      }
      if (config.ai && typeof config.ai.binding === "string" && config.ai.binding.length > 0) {
        bindings.ai = config.ai.binding;
      }
    } catch (error) {
      console.warn(
        `Warning: Could not parse wrangler config: ${error instanceof Error ? error.message : String(error)}`
      );
    }
    return bindings;
  }
  /**
   * Check if project has any bindings configured
   *
   * @param cwd - Project root directory
   * @returns True if at least one binding is configured
   */
  async hasAnyBindings(cwd) {
    const bindings = await this.detectBindings(cwd);
    return bindings.kv.length > 0 || bindings.d1.length > 0 || bindings.r2.length > 0 || !!bindings.ai;
  }
  /**
   * Generate binding usage examples for template comments
   *
   * @param bindings - Detected bindings
   * @returns Array of binding examples with imports and usage
   */
  generateBindingExamples(bindings) {
    const examples = [];
    for (const bindingName of bindings.kv) {
      const helperClass = this.getHelperClassName(bindingName, "kv");
      const helperFile = this.getHelperFileName(bindingName, "kv");
      examples.push({
        type: "kv",
        bindingName,
        helperClass,
        importStatement: `import { ${helperClass} } from "../utils/bindings/${helperFile}.js";`,
        usageExample: [
          `const cache = new ${helperClass}(env.${bindingName});`,
          `const data = await cache.get<MyType>('key');`,
          `await cache.set('key', { value: 'data' }, { expirationTtl: 3600 });`
        ].join("\n// ")
      });
    }
    for (const bindingName of bindings.d1) {
      const helperClass = this.getHelperClassName(bindingName, "d1");
      const helperFile = this.getHelperFileName(bindingName, "d1");
      examples.push({
        type: "d1",
        bindingName,
        helperClass,
        importStatement: `import { ${helperClass} } from "../utils/bindings/${helperFile}.js";`,
        usageExample: [
          `const db = new ${helperClass}(env.${bindingName});`,
          `const users = await db.query<User>('SELECT * FROM users WHERE active = ?', [true]);`,
          `await db.execute('INSERT INTO logs (message) VALUES (?)', ['User logged in']);`
        ].join("\n// ")
      });
    }
    for (const bindingName of bindings.r2) {
      const helperClass = this.getHelperClassName(bindingName, "r2");
      const helperFile = this.getHelperFileName(bindingName, "r2");
      examples.push({
        type: "r2",
        bindingName,
        helperClass,
        importStatement: `import { ${helperClass} } from "../utils/bindings/${helperFile}.js";`,
        usageExample: [
          `const bucket = new ${helperClass}(env.${bindingName});`,
          `await bucket.putText('files/readme.txt', 'Hello World');`,
          `const content = await bucket.getText('files/readme.txt');`
        ].join("\n// ")
      });
    }
    if (bindings.ai) {
      examples.push({
        type: "ai",
        bindingName: bindings.ai,
        usageExample: [
          `// RAG with LLM:`,
          `const ragResult = await env.${bindings.ai}.aiSearch('my-instance', 'query text');`,
          ``,
          `// Vector-only search:`,
          `const searchResult = await env.${bindings.ai}.search('my-instance', 'query text');`
        ].join("\n// ")
      });
    }
    return examples;
  }
  /**
   * Generate compact binding summary for template comments
   * Format: "KV: MY_CACHE, SESSION_STORE | D1: USER_DB | R2: UPLOADS | AI: AI"
   *
   * @param bindings - Detected bindings
   * @returns Compact summary string
   */
  generateBindingSummary(bindings) {
    const parts = [];
    if (bindings.kv.length > 0) {
      parts.push(`KV: ${bindings.kv.join(", ")}`);
    }
    if (bindings.d1.length > 0) {
      parts.push(`D1: ${bindings.d1.join(", ")}`);
    }
    if (bindings.r2.length > 0) {
      parts.push(`R2: ${bindings.r2.join(", ")}`);
    }
    if (bindings.ai) {
      parts.push(`AI: ${bindings.ai}`);
    }
    return parts.join(" | ");
  }
  /**
   * Get helper class name for a binding
   * Example: MY_CACHE (kv) -> MyCacheKV
   */
  getHelperClassName(bindingName, bindingType) {
    const baseName = toPascalCase(bindingName.toLowerCase().replace(/_/g, "-"));
    const suffix = bindingType.toUpperCase();
    return `${baseName}${suffix}`;
  }
  /**
   * Get helper file name for a binding
   * Example: MY_CACHE (kv) -> kv-my-cache
   */
  getHelperFileName(bindingName, bindingType) {
    const fileName = bindingName.toLowerCase().replace(/_/g, "-");
    return `${bindingType}-${fileName}`;
  }
};
async function updateTemplateMetadata(cwd, entityType, name, fileSubpath, hasTests) {
  const metadataPath = join(cwd, ".mcp-template.json");
  if (!existsSync(metadataPath)) {
    return;
  }
  try {
    const content = await readFile(metadataPath, "utf-8");
    const metadata = JSON.parse(content);
    if (!metadata[entityType]) {
      metadata[entityType] = [];
    }
    const entityMetadata = {
      name,
      file: fileSubpath,
      registered: true,
      hasUnitTest: hasTests,
      hasIntegrationTest: hasTests
    };
    metadata[entityType].push(entityMetadata);
    await writeFile(metadataPath, JSON.stringify(metadata, null, "	"), "utf-8");
  } catch (error) {
    console.warn(`  \u26A0\uFE0F  Could not update .mcp-template.json: ${error}`);
  }
}
async function readTemplateMetadata(cwd) {
  const metadataPath = join(cwd, ".mcp-template.json");
  if (!existsSync(metadataPath)) {
    return null;
  }
  try {
    const content = await readFile(metadataPath, "utf-8");
    return JSON.parse(content);
  } catch (error) {
    console.warn(`  \u26A0\uFE0F  Could not read .mcp-template.json: ${error}`);
    return null;
  }
}
var ResourceOptionsSchema = z.object({
  /** URI pattern for the resource */
  uriPattern: z.string().optional(),
  /** Whether this is a static resource */
  static: z.boolean().optional(),
  /** Whether this is a dynamic resource with variables */
  dynamic: z.boolean().optional()
});
var ScaffoldConfigSchema = z.object({
  /** Entity type (tool, prompt, resource) */
  entityType: z.enum(["tool", "prompt", "resource"]),
  /** Entity name in kebab-case */
  name: z.string().regex(/^[a-z][a-z0-9-]*$/, {
    message: "Entity name must be lowercase with hyphens (e.g., my-entity)"
  }),
  /** Description of the entity */
  description: z.string().optional(),
  /** Whether to generate test files (default: true) */
  generateTests: z.boolean().optional().default(true),
  /** Whether to auto-register in index.ts (default: true) */
  autoRegister: z.boolean().optional().default(true),
  /** Resource-specific options (required for resources) */
  resourceOptions: ResourceOptionsSchema.optional()
}).refine(
  (data) => {
    if (data.entityType === "resource" && !data.resourceOptions) {
      return false;
    }
    return true;
  },
  {
    message: "Resource options are required when entityType is 'resource'",
    path: ["resourceOptions"]
  }
).refine(
  (data) => {
    if (data.resourceOptions?.static && data.resourceOptions?.dynamic) {
      return false;
    }
    return true;
  },
  {
    message: "Cannot use both --static and --dynamic flags",
    path: ["resourceOptions"]
  }
);
var RegistrationConfigSchema = z.object({
  /** Entity type */
  entityType: z.enum(["tool", "prompt", "resource"]),
  /** Entity type plural form */
  entityTypePlural: z.enum(["tools", "prompts", "resources"]),
  /** Import directory path */
  directory: z.string(),
  /** Function name suffix */
  functionSuffix: z.string()
});
var ValidationConfigSchema = z.object({
  /** Entity type */
  entityType: z.enum(["tool", "prompt", "resource"]),
  /** Directory where entity file will be created */
  sourceDir: z.string()
});
var TemplateConfigSchema = z.object({
  /** Entity type */
  entityType: z.enum(["tool", "prompt", "resource"]),
  /** Entity name in kebab-case */
  name: z.string(),
  /** Capitalized name (PascalCase) */
  capitalizedName: z.string(),
  /** Entity description */
  description: z.string().optional()
});
var ResourceTemplateOptionsSchema = TemplateConfigSchema.extend({
  /** Entity type must be resource */
  entityType: z.literal("resource"),
  /** URI pattern for the resource */
  uriPattern: z.string()
});
var EntityListerConfigSchema = z.object({
  /** Entity type */
  entityType: z.enum(["tool", "prompt", "resource"]),
  /** Entity type plural form */
  entityTypePlural: z.enum(["tools", "prompts", "resources"]),
  /** Directory where entities are stored */
  directory: z.string(),
  /** Function name suffix */
  functionSuffix: z.string(),
  /** Regex pattern to extract description from file */
  descriptionPattern: z.instanceof(RegExp),
  /** Command name for CLI */
  commandName: z.string(),
  /** Command description for CLI */
  commandDescription: z.string()
});

// src/core/commands/shared/strategies/entity-scaffold-strategy.ts
var EntityScaffoldStrategy = class {
  registrationService;
  validationService;
  templateService;
  bindingDetectionService;
  constructor() {
    this.registrationService = new RegistrationService();
    this.validationService = new ValidationService();
    this.templateService = new TemplateService();
    this.bindingDetectionService = new BindingDetectionService();
  }
  /**
   * Validate entity configuration
   */
  async validate(cwd, config) {
    const parseResult = ScaffoldConfigSchema.safeParse(config);
    if (!parseResult.success) {
      const firstError = parseResult.error.errors[0];
      throw new Error(firstError.message);
    }
    const { entityType, name } = parseResult.data;
    const validationConfig = {
      entityType,
      sourceDir: `src/${entityType}s`
    };
    this.validationService.validateEntity(cwd, name, validationConfig);
    if (entityType === "resource" && config.resourceOptions) {
      this.validationService.validateResourceOptions(config.resourceOptions);
    }
  }
  /**
   * Execute entity scaffolding
   *
   * 1. Generate entity file
   * 2. Generate test files (if enabled)
   * 3. Register entity (if enabled)
   * 4. Update metadata
   */
  async execute(context) {
    const { cwd, config, result } = context;
    const { entityType, name } = config;
    const capitalizedName = toPascalCase(name);
    const description = config.description || "TODO: Add description";
    const generateTests = config.generateTests !== false;
    const autoRegister = config.autoRegister !== false;
    const entityFilePath = await this.generateEntityFile(
      cwd,
      name,
      capitalizedName,
      description,
      config
    );
    result.filesCreated.push(entityFilePath);
    if (generateTests) {
      const testFiles = await this.generateTestFiles(
        cwd,
        name,
        capitalizedName,
        description,
        config
      );
      result.filesCreated.push(...testFiles);
    }
    if (autoRegister) {
      const registrationConfig = {
        entityType,
        entityTypePlural: `${entityType}s`,
        directory: `./${entityType}s/`,
        functionSuffix: entityType.charAt(0).toUpperCase() + entityType.slice(1)
      };
      await this.registrationService.registerEntity(
        cwd,
        name,
        capitalizedName,
        registrationConfig
      );
      result.registered = true;
    }
    await updateTemplateMetadata(
      cwd,
      `${entityType}s`,
      name,
      `src/${entityType}s/${name}.ts`,
      generateTests
    );
    result.success = true;
  }
  /**
   * Entities don't need backup (low risk)
   */
  needsBackup() {
    return false;
  }
  /**
   * Create initial result object
   */
  createResult() {
    return {
      success: false,
      filesCreated: [],
      registered: false,
      messages: []
    };
  }
  /**
   * Generate the main entity file
   */
  async generateEntityFile(cwd, name, capitalizedName, description, config) {
    const { entityType, resourceOptions } = config;
    const dirPath = join(cwd, "src", `${entityType}s`);
    const filePath = join(dirPath, `${name}.ts`);
    await mkdir(dirPath, { recursive: true });
    let bindingContext;
    if (entityType === "tool") {
      const bindings = await this.bindingDetectionService.detectBindings(cwd);
      const hasBindings = bindings.kv.length > 0 || bindings.d1.length > 0 || bindings.r2.length > 0 || !!bindings.ai;
      if (hasBindings) {
        const examples = this.bindingDetectionService.generateBindingExamples(bindings);
        const summary = this.bindingDetectionService.generateBindingSummary(bindings);
        bindingContext = {
          hasBindings: true,
          bindingSummary: summary,
          bindingExamples: examples
        };
      } else {
        bindingContext = {
          hasBindings: false
        };
      }
    }
    let content;
    if (entityType === "resource" && resourceOptions) {
      const uriPattern = this.validationService.determineUriPattern(
        name,
        resourceOptions
      );
      const resourceConfig = {
        entityType,
        name,
        capitalizedName,
        description,
        uriPattern
      };
      content = this.templateService.generateEntityFile(resourceConfig);
    } else {
      content = this.templateService.generateEntityFile({
        entityType,
        name,
        capitalizedName,
        description,
        bindingContext
      });
    }
    await writeFile(filePath, content, "utf-8");
    return filePath;
  }
  /**
   * Generate unit and integration test files
   */
  async generateTestFiles(cwd, name, capitalizedName, description, config) {
    const { entityType, resourceOptions } = config;
    const testFiles = [];
    const unitTestPath = await this.generateUnitTest(
      cwd,
      name,
      capitalizedName,
      description,
      entityType
    );
    testFiles.push(unitTestPath);
    const integrationTestPath = await this.generateIntegrationTest(
      cwd,
      name,
      capitalizedName,
      description,
      entityType,
      resourceOptions
    );
    testFiles.push(integrationTestPath);
    return testFiles;
  }
  /**
   * Generate unit test file
   */
  async generateUnitTest(cwd, name, capitalizedName, description, entityType) {
    const dirPath = join(cwd, "test", "unit", `${entityType}s`);
    const filePath = join(dirPath, `${name}.test.ts`);
    await mkdir(dirPath, { recursive: true });
    const content = this.templateService.generateUnitTestFile({
      entityType,
      name,
      capitalizedName,
      description
    });
    await writeFile(filePath, content, "utf-8");
    return filePath;
  }
  /**
   * Generate integration test file (YAML)
   */
  async generateIntegrationTest(cwd, name, capitalizedName, description, entityType, resourceOptions) {
    const dirPath = join(
      cwd,
      "test",
      "integration",
      "specs",
      entityType === "tool" ? "" : `${entityType}s`
    );
    const filePath = join(dirPath, `${name}.yaml`);
    await mkdir(dirPath, { recursive: true });
    let content;
    if (entityType === "resource" && resourceOptions) {
      const uriPattern = this.validationService.determineUriPattern(
        name,
        resourceOptions
      );
      content = this.templateService.generateIntegrationTestYaml({
        entityType,
        name,
        capitalizedName,
        description,
        uriPattern
      });
    } else {
      content = this.templateService.generateIntegrationTestYaml({
        entityType,
        name,
        capitalizedName,
        description
      });
    }
    await writeFile(filePath, content, "utf-8");
    return filePath;
  }
};

// src/core/commands/shared/entity-scaffolder.ts
var EntityScaffolder = class {
  orchestrator;
  strategy;
  constructor() {
    this.orchestrator = new ScaffoldOrchestrator();
    this.strategy = new EntityScaffoldStrategy();
  }
  /**
   * Scaffold a new entity
   *
   * @param cwd Current working directory (project root)
   * @param config Scaffolding configuration
   * @returns Result with created files and registration status
   */
  async scaffold(cwd, config) {
    return this.orchestrator.scaffold(cwd, config, this.strategy);
  }
  /**
   * Get emoji for entity type (for console output)
   */
  static getEntityEmoji(entityType) {
    switch (entityType) {
      case "tool":
        return "\u{1F527}";
      case "prompt":
        return "\u{1F4DD}";
      case "resource":
        return "\u{1F4E6}";
    }
  }
  /**
   * Get entity type display name
   */
  static getEntityDisplayName(entityType) {
    return entityType.charAt(0).toUpperCase() + entityType.slice(1);
  }
};
var EntityLister = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * Create Commander command for listing entities
   */
  createCommand() {
    return new Command(this.config.entityTypePlural).description(
      `List all ${this.config.entityTypePlural} in the MCP server project`
    ).option("-j, --json", "Output as JSON").option(
      "-f, --filter <status>",
      "Filter by status (all, registered, unregistered, tested, untested)",
      "all"
    ).option(
      "--show-examples",
      `Include example ${this.config.entityTypePlural} in output`
    ).action(async (options) => {
      const cwd = process.cwd();
      try {
        const entities = await this.discoverEntities(
          cwd,
          options.showExamples
        );
        const filtered = this.filterEntities(entities, options.filter);
        if (options.json) {
          console.log(JSON.stringify(filtered, null, 2));
        } else {
          this.printTable(filtered);
        }
      } catch (error) {
        console.error(
          `\u274C Error: ${error instanceof Error ? error.message : String(error)}`
        );
        process.exit(1);
      }
    });
  }
  /**
   * Discover all entities in the project
   */
  async discoverEntities(cwd, includeExamples = false) {
    const entities = [];
    const sourceDir = path.join(cwd, this.config.sourceDir);
    let entityFiles = [];
    try {
      const files = await fs.readdir(sourceDir);
      entityFiles = files.filter((f) => f.endsWith(".ts") && !f.endsWith(".test.ts")).filter((f) => includeExamples || !f.startsWith("_example"));
    } catch (error) {
      throw new Error(
        `${this.config.sourceDir}/ directory not found. Are you in an MCP server project?`
      );
    }
    const indexPath = path.join(cwd, "src", "index.ts");
    const registeredEntities = await this.checkRegistrations(indexPath);
    for (const file of entityFiles) {
      const entityName = path.basename(file, ".ts");
      const entityPath = path.join(sourceDir, file);
      const registered = registeredEntities.includes(entityName);
      const unitTestPath = path.join(
        cwd,
        this.config.unitTestDir,
        `${entityName}.test.ts`
      );
      const hasUnitTest = await fileExists(unitTestPath);
      const integrationTestPath = path.join(
        cwd,
        this.config.integrationTestDir,
        `${entityName}.yaml`
      );
      const hasIntegrationTest = await fileExists(integrationTestPath);
      const description = await this.extractDescription(entityPath);
      entities.push({
        name: entityName,
        file: path.relative(cwd, entityPath),
        registered,
        hasUnitTest,
        hasIntegrationTest,
        description
      });
    }
    return entities;
  }
  /**
   * Check which entities are registered in src/index.ts
   */
  async checkRegistrations(indexPath) {
    try {
      const content = await fs.readFile(indexPath, "utf-8");
      const registered = [];
      let match;
      while ((match = this.config.registrationPattern.exec(content)) !== null) {
        const entityName = toKebabCase(match[1]);
        registered.push(entityName);
      }
      return registered;
    } catch (error) {
      return [];
    }
  }
  /**
   * Filter entities by status
   */
  filterEntities(entities, filter) {
    switch (filter.toLowerCase()) {
      case "registered":
        return entities.filter((e) => e.registered);
      case "unregistered":
        return entities.filter((e) => !e.registered);
      case "tested":
        return entities.filter((e) => e.hasUnitTest || e.hasIntegrationTest);
      case "untested":
        return entities.filter((e) => !e.hasUnitTest && !e.hasIntegrationTest);
      case "all":
      default:
        return entities;
    }
  }
  /**
   * Print entities in a formatted table
   */
  printTable(entities) {
    if (entities.length === 0) {
      console.log(`No ${this.config.entityTypePlural} found.
`);
      return;
    }
    console.log(
      `
Found ${entities.length} ${entities.length === 1 ? this.config.entityType : this.config.entityTypePlural}:
`
    );
    const nameWidth = Math.max(10, ...entities.map((e) => e.name.length));
    const fileWidth = Math.max(20, ...entities.map((e) => e.file.length));
    const header = `${"NAME".padEnd(nameWidth)} | REG | UNIT | INT | ${"FILE".padEnd(fileWidth)}`;
    console.log(header);
    console.log("=".repeat(header.length));
    for (const entity of entities) {
      const name = entity.name.padEnd(nameWidth);
      const reg = entity.registered ? " \u2713 " : " \u2717 ";
      const unit = entity.hasUnitTest ? " \u2713 " : " \u2717 ";
      const int = entity.hasIntegrationTest ? " \u2713 " : " \u2717 ";
      const file = entity.file.padEnd(fileWidth);
      console.log(`${name} | ${reg} | ${unit} | ${int} | ${file}`);
      if (entity.description && entity.description !== "No description") {
        console.log(`${"".padEnd(nameWidth)}   ${entity.description}`);
      }
    }
    const registered = entities.filter((e) => e.registered).length;
    const withUnitTests = entities.filter((e) => e.hasUnitTest).length;
    const withIntegrationTests = entities.filter(
      (e) => e.hasIntegrationTest
    ).length;
    console.log("\nSummary:");
    console.log(`  Registered:       ${registered}/${entities.length}`);
    console.log(`  Unit tests:       ${withUnitTests}/${entities.length}`);
    console.log(
      `  Integration tests: ${withIntegrationTests}/${entities.length}`
    );
    console.log("");
  }
  /**
   * Extract description from entity file
   */
  async extractDescription(filePath) {
    try {
      const content = await fs.readFile(filePath, "utf-8");
      const match = content.match(this.config.descriptionPattern);
      if (match && match[2]) {
        return match[2];
      }
      const headerRegex = /\/\*\*[\s\S]*?\*\s*([^\n]+)/;
      const headerMatch = content.match(headerRegex);
      if (headerMatch && headerMatch[1]) {
        return headerMatch[1].trim();
      }
      return "No description";
    } catch (error) {
      return "No description";
    }
  }
};

export { BindingDetectionService, EntityLister, EntityListerConfigSchema, EntityScaffolder, RegistrationConfigSchema, RegistrationService, ResourceOptionsSchema, ResourceTemplateOptionsSchema, ScaffoldConfigSchema, TemplateConfigSchema, TemplateService, ValidationConfigSchema, ValidationService, fileExists, readTemplateMetadata, toKebabCase, toPascalCase, updateTemplateMetadata };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map