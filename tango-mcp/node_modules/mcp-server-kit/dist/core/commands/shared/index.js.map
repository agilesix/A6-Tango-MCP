{"version":3,"sources":["../../../../src/core/commands/shared/backup-restore.ts","../../../../src/core/commands/shared/orchestration/scaffold-orchestrator.ts","../../../../src/core/commands/shared/registration-service.ts","../../../../src/core/commands/shared/validation-service.ts","../../../../src/core/commands/shared/template-service.ts","../../../../src/core/commands/shared/config/wrangler-utils.ts","../../../../src/core/commands/shared/utils.ts","../../../../src/core/commands/shared/binding-detection-service.ts","../../../../src/core/commands/shared/metadata.ts","../../../../src/core/commands/shared/schemas.ts","../../../../src/core/commands/shared/strategies/entity-scaffold-strategy.ts","../../../../src/core/commands/shared/entity-scaffolder.ts","../../../../src/core/commands/shared/entity-lister.ts"],"names":["join","existsSync","insertPos","comment","path","readFile","writeFile"],"mappings":";;;;;;;;;;AAiBA,eAAsB,aAAa,GAAA,EAA8B;AAChE,EAAA,MAAM,SAAA,GAAY,KAAK,GAAA,EAAI;AAC3B,EAAA,MAAM,SAAA,GAAY,IAAA,CAAK,GAAA,EAAK,CAAA,aAAA,EAAgB,SAAS,CAAA,CAAE,CAAA;AAGvD,EAAA,MAAM,MAAA,GAAS,IAAA,CAAK,GAAA,EAAK,KAAK,CAAA;AAC9B,EAAA,IAAI,UAAA,CAAW,MAAM,CAAA,EAAG;AACvB,IAAA,MAAM,EAAA,CAAG,QAAQ,IAAA,CAAK,SAAA,EAAW,KAAK,CAAA,EAAG,EAAE,SAAA,EAAW,IAAA,EAAM,CAAA;AAAA,EAC7D;AAGA,EAAA,MAAM,aAAA,GAAgB;AAAA,IACrB,cAAA;AAAA,IACA,eAAA;AAAA,IACA,gBAAA;AAAA,IACA,eAAA;AAAA,IACA,aAAA;AAAA,IACA,gBAAA;AAAA,IACA,iBAAA;AAAA,IACA,gBAAA;AAAA,IACA,WAAA;AAAA,IACA,YAAA;AAAA,IACA,MAAA;AAAA,IACA;AAAA,GACD;AAEA,EAAA,KAAA,MAAW,QAAQ,aAAA,EAAe;AACjC,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,GAAA,EAAK,IAAI,CAAA;AAC/B,IAAA,IAAI,UAAA,CAAW,QAAQ,CAAA,EAAG;AACzB,MAAA,MAAM,EAAA,CAAG,QAAA,EAAU,IAAA,CAAK,SAAA,EAAW,IAAI,CAAC,CAAA;AAAA,IACzC;AAAA,EACD;AAEA,EAAA,OAAO,SAAA;AACR;AAQA,eAAsB,iBAAA,CACrB,WACA,GAAA,EACgB;AAChB,EAAA,IAAI,CAAC,UAAA,CAAW,SAAS,CAAA,EAAG;AAC3B,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,4BAAA,EAA+B,SAAS,CAAA,CAAE,CAAA;AAAA,EAC3D;AAGA,EAAA,MAAM,YAAA,GAAe,IAAA,CAAK,SAAA,EAAW,KAAK,CAAA;AAC1C,EAAA,IAAI,UAAA,CAAW,YAAY,CAAA,EAAG;AAC7B,IAAA,MAAM,YAAA,GAAe,IAAA,CAAK,GAAA,EAAK,KAAK,CAAA;AAGpC,IAAA,IAAI,UAAA,CAAW,YAAY,CAAA,EAAG;AAC7B,MAAA,MAAM,GAAG,YAAA,EAAc,EAAE,WAAW,IAAA,EAAM,KAAA,EAAO,MAAM,CAAA;AAAA,IACxD;AAGA,IAAA,MAAM,GAAG,YAAA,EAAc,YAAA,EAAc,EAAE,SAAA,EAAW,MAAM,CAAA;AAAA,EACzD;AAGA,EAAA,MAAM,WAAA,GAAc,MAAM,OAAA,CAAQ,SAAS,CAAA;AAE3C,EAAA,KAAA,MAAW,QAAQ,WAAA,EAAa;AAC/B,IAAA,IAAI,SAAS,KAAA,EAAO;AACnB,MAAA;AAAA,IACD;AAEA,IAAA,MAAM,cAAA,GAAiB,IAAA,CAAK,SAAA,EAAW,IAAI,CAAA;AAC3C,IAAA,MAAM,cAAA,GAAiB,IAAA,CAAK,GAAA,EAAK,IAAI,CAAA;AAGrC,IAAA,MAAM,KAAA,GAAQ,MAAM,IAAA,CAAK,cAAc,CAAA;AACvC,IAAA,IAAI,KAAA,CAAM,QAAO,EAAG;AACnB,MAAA,MAAM,EAAA,CAAG,gBAAgB,cAAc,CAAA;AAAA,IACxC;AAAA,EACD;AACD;AAOA,eAAsB,aAAa,SAAA,EAAkC;AACpE,EAAA,IAAI,UAAA,CAAW,SAAS,CAAA,EAAG;AAC1B,IAAA,MAAM,GAAG,SAAA,EAAW,EAAE,WAAW,IAAA,EAAM,KAAA,EAAO,MAAM,CAAA;AAAA,EACrD;AACD;;;AChFO,IAAM,uBAAN,MAAqF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkB3F,MAAM,QAAA,CACL,GAAA,EACA,QACA,QAAA,EACA,OAAA,GAA2B,EAAC,EACT;AAEnB,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,aAAA,CAAc,GAAA,EAAK,QAAQ,QAAQ,CAAA;AAGxD,IAAA,IAAI,QAAQ,MAAA,EAAQ;AACnB,MAAA,MAAM,QAAA,CAAS,QAAA,CAAS,GAAA,EAAK,MAAM,CAAA;AACnC,MAAA,OAAO,OAAA,CAAQ,MAAA;AAAA,IAChB;AAEA,IAAA,IAAI;AAEH,MAAA,MAAM,QAAA,CAAS,QAAA,CAAS,GAAA,EAAK,MAAM,CAAA;AAGnC,MAAA,IAAI,QAAA,CAAS,WAAA,EAAY,IAAK,CAAC,QAAQ,UAAA,EAAY;AAClD,QAAA,OAAA,CAAQ,SAAA,GAAY,MAAM,YAAA,CAAa,GAAG,CAAA;AAAA,MAC3C;AAGA,MAAA,MAAM,QAAA,CAAS,QAAQ,OAAO,CAAA;AAG9B,MAAA,IAAI,QAAQ,SAAA,EAAW;AACtB,QAAA,MAAM,YAAA,CAAa,QAAQ,SAAS,CAAA;AACpC,QAAA,OAAA,CAAQ,SAAA,GAAY,KAAA,CAAA;AAAA,MACrB;AAEA,MAAA,OAAO,OAAA,CAAQ,MAAA;AAAA,IAChB,SAAS,KAAA,EAAO;AAEf,MAAA,IAAI,QAAQ,SAAA,EAAW;AACtB,QAAA,IAAI;AACH,UAAA,MAAM,iBAAA,CAAkB,OAAA,CAAQ,SAAA,EAAW,GAAG,CAAA;AAC9C,UAAA,MAAM,YAAA,CAAa,QAAQ,SAAS,CAAA;AAAA,QACrC,SAAS,aAAA,EAAe;AAEvB,UAAA,MAAM,cACL,aAAA,YAAyB,KAAA,GACtB,aAAA,CAAc,OAAA,GACd,OAAO,aAAa,CAAA;AACxB,UAAA,MAAM,IAAI,KAAA;AAAA,YACT,mBAAmB,KAAA,YAAiB,KAAA,GAAQ,MAAM,OAAA,GAAU,MAAA,CAAO,KAAK,CAAC;AAAA,sBAAA,EAA2B,WAAW,CAAA;AAAA,WAChH;AAAA,QACD;AAAA,MACD;AAEA,MAAA,MAAM,KAAA;AAAA,IACP;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUQ,aAAA,CACP,GAAA,EACA,MAAA,EACA,QAAA,EACoC;AACpC,IAAA,OAAO;AAAA,MACN,GAAA;AAAA,MACA,MAAA;AAAA,MACA,MAAA,EAAQ,SAAS,YAAA,EAAa;AAAA,MAC9B,UAAU;AAAC,KACZ;AAAA,EACD;AACD,CAAA;AC/FO,IAAM,mBAAA,GAAN,MAAM,oBAAA,CAAoB;AAAA,EAChC,OAAwB,YAAA,GAAe,CAAC,MAAA,EAAQ,UAAU,UAAU,CAAA;AAAA;AAAA;AAAA;AAAA,EAKpE,MAAM,cAAA,CACL,GAAA,EACA,IAAA,EACA,iBACA,MAAA,EACgB;AAChB,IAAA,MAAM,SAAA,GAAYA,IAAAA,CAAK,GAAA,EAAK,KAAA,EAAO,UAAU,CAAA;AAE7C,IAAA,IAAI,CAACC,UAAAA,CAAW,SAAS,CAAA,EAAG;AAC3B,MAAA,MAAM,IAAI,MAAM,wBAAwB,CAAA;AAAA,IACzC;AAEA,IAAA,MAAM,OAAA,GAAU,MAAM,QAAA,CAAS,SAAA,EAAW,OAAO,CAAA;AACjD,IAAA,MAAM,YAAA,GAAe,CAAA,QAAA,EAAW,eAAe,CAAA,EAAG,OAAO,cAAc,CAAA,CAAA;AAGvE,IAAA,IAAI,OAAA,CAAQ,QAAA,CAAS,YAAY,CAAA,EAAG;AACnC,MAAA,OAAA,CAAQ,IAAA;AAAA,QACP,CAAA,gBAAA,EAAS,MAAA,CAAO,UAAA,CAAW,MAAA,CAAO,CAAC,CAAA,CAAE,WAAA,EAAY,GAAI,MAAA,CAAO,UAAA,CAAW,KAAA,CAAM,CAAC,CAAC,CAAA,mCAAA;AAAA,OAChF;AACA,MAAA;AAAA,IACD;AAGA,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,gBAAA;AAAA,MAC3B,GAAA;AAAA,MACA,IAAA;AAAA,MACA,YAAA;AAAA,MACA;AAAA,KACD;AAGA,IAAA,MAAM,kBAAkB,CAAA,SAAA,EAAY,YAAY,YAAY,MAAA,CAAO,SAAS,GAAG,IAAI,CAAA,KAAA,CAAA;AACnF,IAAA,MAAM,mBAAmB,QAAA,GACtB,CAAA,EAAA,EAAO,YAAY,CAAA,wBAAA,CAAA,GACnB,KAAO,YAAY,CAAA,cAAA,CAAA;AAEtB,IAAA,IAAI,cAAA,GAAiB,IAAA,CAAK,SAAA,CAAU,OAAA,EAAS,iBAAiB,MAAM,CAAA;AACpE,IAAA,cAAA,GAAiB,IAAA,CAAK,mBAAA;AAAA,MACrB,cAAA;AAAA,MACA,gBAAA;AAAA,MACA;AAAA,KACD;AAEA,IAAA,MAAM,SAAA,CAAU,SAAA,EAAW,cAAA,EAAgB,OAAO,CAAA;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAA,CACL,GAAA,EACA,eAAA,EACA,MAAA,EACmB;AACnB,IAAA,MAAM,SAAA,GAAYD,IAAAA,CAAK,GAAA,EAAK,KAAA,EAAO,UAAU,CAAA;AAE7C,IAAA,IAAI,CAACC,UAAAA,CAAW,SAAS,CAAA,EAAG;AAC3B,MAAA,OAAO,KAAA;AAAA,IACR;AAEA,IAAA,MAAM,OAAA,GAAU,MAAM,QAAA,CAAS,SAAA,EAAW,OAAO,CAAA;AACjD,IAAA,MAAM,YAAA,GAAe,CAAA,QAAA,EAAW,eAAe,CAAA,EAAG,OAAO,cAAc,CAAA,CAAA;AAEvE,IAAA,OAAO,OAAA,CAAQ,SAAS,YAAY,CAAA;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKQ,SAAA,CACP,OAAA,EACA,eAAA,EACA,MAAA,EACS;AACT,IAAA,IAAI,cAAA,GAAiB,OAAA;AACrB,IAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,cAAA,CAAe,MAAA,CAAO,SAAS,CAAA;AAG7D,IAAA,MAAM,qBAAqB,KAAA,CAAM,IAAA,CAAK,OAAA,CAAQ,QAAA,CAAS,gBAAgB,CAAC,CAAA;AAExE,IAAA,IAAI,kBAAA,CAAmB,SAAS,CAAA,EAAG;AAClC,MAAA,MAAM,SAAA,GAAY,kBAAA,CAAmB,kBAAA,CAAmB,MAAA,GAAS,CAAC,CAAA;AAClE,MAAA,MAAM,SAAA,GAAY,SAAA,CAAU,KAAA,GAAS,SAAA,CAAU,CAAC,CAAA,CAAE,MAAA;AAClD,MAAA,OACC,OAAA,CAAQ,KAAA,CAAM,CAAA,EAAG,SAAS,CAAA,GAC1B;AAAA,EAAK,eAAe,CAAA,CAAA,GACpB,OAAA,CAAQ,KAAA,CAAM,SAAS,CAAA;AAAA,IAEzB;AAGA,IAAA,MAAM,YAAA,GAAe,qBAAoB,YAAA,CAAa,OAAA;AAAA,MACrD,MAAA,CAAO;AAAA,KACR;AAGA,IAAA,KAAA,IAAS,CAAA,GAAI,YAAA,GAAe,CAAA,EAAG,CAAA,IAAK,GAAG,CAAA,EAAA,EAAK;AAC3C,MAAA,MAAM,YAAA,GAAe,oBAAA,CAAoB,YAAA,CAAa,CAAC,CAAA;AACvD,MAAA,MAAM,WAAA,GAAc,KAAK,YAAY,CAAA,EAAA,CAAA;AACrC,MAAA,MAAM,aAAA,GAAgB,IAAA,CAAK,cAAA,CAAe,WAAW,CAAA;AACrD,MAAA,MAAM,kBAAkB,KAAA,CAAM,IAAA,CAAK,OAAA,CAAQ,QAAA,CAAS,aAAa,CAAC,CAAA;AAElE,MAAA,IAAI,eAAA,CAAgB,SAAS,CAAA,EAAG;AAC/B,QAAA,MAAM,SAAA,GAAY,eAAA,CAAgB,eAAA,CAAgB,MAAA,GAAS,CAAC,CAAA;AAC5D,QAAA,MAAM,SAAA,GAAY,SAAA,CAAU,KAAA,GAAS,SAAA,CAAU,CAAC,CAAA,CAAE,MAAA;AAClD,QAAA,MAAM,OAAA,GAAU;;AAAA,GAAA,EAAU,MAAA,CAAO,gBAAA,CAAiB,MAAA,CAAO,CAAC,CAAA,CAAE,WAAA,EAAY,GAAI,MAAA,CAAO,gBAAA,CAAiB,KAAA,CAAM,CAAC,CAAC;AAAA,CAAA;AAC5G,QAAA,OACC,OAAA,CAAQ,MAAM,CAAA,EAAG,SAAS,IAC1B,OAAA,GACA,eAAA,GACA,OAAA,CAAQ,KAAA,CAAM,SAAS,CAAA;AAAA,MAEzB;AAAA,IACD;AAGA,IAAA,MAAM,kBAAkB,OAAA,CAAQ,KAAA;AAAA,MAC/B;AAAA,KACD;AAEA,IAAA,IAAI,eAAA,EAAiB;AACpB,MAAA,MAAM,UAAA,GAAa,eAAA,CAAgB,eAAA,CAAgB,MAAA,GAAS,CAAC,CAAA;AAC7D,MAAA,MAAM,SAAA,GAAY,OAAA,CAAQ,OAAA,CAAQ,UAAU,IAAI,UAAA,CAAW,MAAA;AAC3D,MAAA,MAAM,OAAA,GAAU;;AAAA,GAAA,EAAU,MAAA,CAAO,gBAAA,CAAiB,MAAA,CAAO,CAAC,CAAA,CAAE,WAAA,EAAY,GAAI,MAAA,CAAO,gBAAA,CAAiB,KAAA,CAAM,CAAC,CAAC;AAAA,CAAA;AAC5G,MAAA,OACC,OAAA,CAAQ,MAAM,CAAA,EAAG,SAAS,IAC1B,OAAA,GACA,eAAA,GACA,OAAA,CAAQ,KAAA,CAAM,SAAS,CAAA;AAAA,IAEzB;AAEA,IAAA,OAAO,cAAA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKQ,mBAAA,CACP,OAAA,EACA,gBAAA,EACA,MAAA,EACS;AACT,IAAA,MAAM,eAAA,GAAkB,gCAAA;AACxB,IAAA,MAAM,SAAA,GAAY,OAAA,CAAQ,KAAA,CAAM,eAAe,CAAA;AAE/C,IAAA,IAAI,CAAC,SAAA,EAAW;AACf,MAAA,OAAO,OAAA;AAAA,IACR;AAEA,IAAA,MAAM,QAAA,GAAW,UAAU,CAAC,CAAA;AAC5B,IAAA,MAAM,kBAAA,GAAqB,CAAA,YAAA,EAAe,MAAA,CAAO,cAAc,CAAA,oBAAA,CAAA;AAC/D,IAAA,MAAM,mBAAmB,IAAI,MAAA,CAAO,CAAA,IAAA,EAAO,kBAAkB,IAAI,GAAG,CAAA;AACpE,IAAA,MAAM,kBAAA,GAAqB,QAAA,CAAS,KAAA,CAAM,gBAAgB,CAAA;AAG1D,IAAA,IAAI,kBAAA,EAAoB;AACvB,MAAA,MAAM,QAAA,GAAW,kBAAA,CAAmB,kBAAA,CAAmB,MAAA,GAAS,CAAC,CAAA;AACjE,MAAA,MAAMC,UAAAA,GACL,UAAU,KAAA,GAAS,SAAA,CAAU,CAAC,CAAA,CAAE,WAAA,CAAY,QAAQ,CAAA,GAAI,QAAA,CAAS,MAAA;AAClE,MAAA,OACC,OAAA,CAAQ,KAAA,CAAM,CAAA,EAAGA,UAAS,CAAA,GAC1B;AAAA,EAAK,gBAAgB,CAAA,CAAA,GACrB,OAAA,CAAQ,KAAA,CAAMA,UAAS,CAAA;AAAA,IAEzB;AAGA,IAAA,MAAM,YAAA,GAAe,qBAAoB,YAAA,CAAa,OAAA;AAAA,MACrD,MAAA,CAAO;AAAA,KACR;AAEA,IAAA,KAAA,IAAS,CAAA,GAAI,YAAA,GAAe,CAAA,EAAG,CAAA,IAAK,GAAG,CAAA,EAAA,EAAK;AAC3C,MAAA,MAAM,YAAA,GAAe,oBAAA,CAAoB,YAAA,CAAa,CAAC,CAAA;AACvD,MAAA,MAAM,cAAA,GACL,aAAa,MAAA,CAAO,CAAC,EAAE,WAAA,EAAY,GAAI,YAAA,CAAa,KAAA,CAAM,CAAC,CAAA;AAC5D,MAAA,MAAM,eAAA,GAAkB,eAAe,cAAc,CAAA,oBAAA,CAAA;AACrD,MAAA,MAAM,gBAAgB,IAAI,MAAA,CAAO,CAAA,IAAA,EAAO,eAAe,IAAI,GAAG,CAAA;AAC9D,MAAA,MAAM,eAAA,GAAkB,QAAA,CAAS,KAAA,CAAM,aAAa,CAAA;AAEpD,MAAA,IAAI,eAAA,EAAiB;AACpB,QAAA,MAAM,QAAA,GAAW,eAAA,CAAgB,eAAA,CAAgB,MAAA,GAAS,CAAC,CAAA;AAC3D,QAAA,MAAMA,UAAAA,GACL,UAAU,KAAA,GACV,SAAA,CAAU,CAAC,CAAA,CAAE,WAAA,CAAY,QAAQ,CAAA,GACjC,QAAA,CAAS,MAAA;AACV,QAAA,MAAMC,QAAAA,GAAU;;AAAA,kBAAA,EAA2B,OAAO,gBAAgB;AAAA,CAAA;AAClE,QAAA,OACC,OAAA,CAAQ,MAAM,CAAA,EAAGD,UAAS,IAC1BC,QAAAA,GACA,gBAAA,GACA,OAAA,CAAQ,KAAA,CAAMD,UAAS,CAAA;AAAA,MAEzB;AAAA,IACD;AAGA,IAAA,MAAM,SAAA,GAAY,UAAU,KAAA,GAAS,SAAA,CAAU,CAAC,CAAA,CAAE,OAAA,CAAQ,GAAG,CAAA,GAAI,CAAA;AACjE,IAAA,MAAM,OAAA,GAAU;AAAA,kBAAA,EAAyB,OAAO,gBAAgB;AAAA,CAAA;AAChE,IAAA,OACC,OAAA,CAAQ,MAAM,CAAA,EAAG,SAAS,IAC1B,OAAA,GACA,gBAAA,GACA,OAAA,CAAQ,KAAA,CAAM,SAAS,CAAA;AAAA,EAEzB;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAe,SAAA,EAA2B;AAEjD,IAAA,MAAM,UAAA,GAAa,SAAA,CAAU,OAAA,CAAQ,qBAAA,EAAuB,MAAM,CAAA;AAClE,IAAA,OAAO,IAAI,MAAA;AAAA,MACV,wCAAwC,UAAU,CAAA,WAAA,CAAA;AAAA,MAClD;AAAA,KACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,gBAAA,CACb,GAAA,EACA,IAAA,EACA,cACA,MAAA,EACmB;AACnB,IAAA,IAAI;AACH,MAAA,MAAM,UAAA,GAAaF,IAAAA;AAAA,QAClB,GAAA;AAAA,QACA,KAAA;AAAA,QACA,MAAA,CAAO,gBAAA;AAAA,QACP,GAAG,IAAI,CAAA,GAAA;AAAA,OACR;AAEA,MAAA,IAAI,CAACC,UAAAA,CAAW,UAAU,CAAA,EAAG;AAC5B,QAAA,OAAO,KAAA;AAAA,MACR;AAEA,MAAA,MAAM,aAAA,GAAgB,MAAM,QAAA,CAAS,UAAA,EAAY,OAAO,CAAA;AAKxD,MAAA,MAAM,kBAAkB,IAAI,MAAA;AAAA,QAC3B,yBAAyB,YAAY,CAAA,uBAAA,CAAA;AAAA,QACrC;AAAA,OACD;AAEA,MAAA,OAAO,eAAA,CAAgB,KAAK,aAAa,CAAA;AAAA,IAC1C,SAAS,KAAA,EAAO;AAEf,MAAA,OAAO,KAAA;AAAA,IACR;AAAA,EACD;AACD;ACpQO,IAAM,oBAAN,MAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAW9B,YAAA,CAAa,MAAc,MAAA,EAAgC;AAC1D,IAAA,MAAM,SAAA,GAAY,mBAAA;AAElB,IAAA,IAAI,CAAC,SAAA,CAAU,IAAA,CAAK,IAAI,CAAA,EAAG;AAC1B,MAAA,MAAM,UAAA,GACL,MAAA,CAAO,UAAA,CAAW,MAAA,CAAO,CAAC,CAAA,CAAE,WAAA,EAAY,GAAI,MAAA,CAAO,UAAA,CAAW,KAAA,CAAM,CAAC,CAAA;AACtE,MAAA,MAAM,IAAI,KAAA;AAAA,QACT,CAAA,EAAG,UAAU,CAAA,+CAAA,EAAkD,MAAA,CAAO,UAAU,CAAA,CAAA;AAAA,OACjF;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,GAAA,EAAmB;AAClC,IAAA,MAAM,eAAA,GAAkBD,IAAAA,CAAK,GAAA,EAAK,cAAc,CAAA;AAEhD,IAAA,IAAI,CAACC,UAAAA,CAAW,eAAe,CAAA,EAAG;AACjC,MAAA,MAAM,IAAI,KAAA;AAAA,QACT;AAAA,OACD;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,qBAAA,CAAsB,GAAA,EAAa,IAAA,EAAc,MAAA,EAAgC;AAChF,IAAA,MAAM,WAAWD,IAAAA,CAAK,GAAA,EAAK,OAAO,SAAA,EAAW,CAAA,EAAG,IAAI,CAAA,GAAA,CAAK,CAAA;AAEzD,IAAA,IAAIC,UAAAA,CAAW,QAAQ,CAAA,EAAG;AACzB,MAAA,MAAM,UAAA,GACL,MAAA,CAAO,UAAA,CAAW,MAAA,CAAO,CAAC,CAAA,CAAE,WAAA,EAAY,GAAI,MAAA,CAAO,UAAA,CAAW,KAAA,CAAM,CAAC,CAAA;AACtE,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,EAAG,UAAU,CAAA,iBAAA,EAAoB,QAAQ,CAAA,CAAE,CAAA;AAAA,IAC5D;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAA,CAAe,GAAA,EAAa,IAAA,EAAc,MAAA,EAAgC;AACzE,IAAA,IAAA,CAAK,YAAA,CAAa,MAAM,MAAM,CAAA;AAC9B,IAAA,IAAA,CAAK,gBAAgB,GAAG,CAAA;AACxB,IAAA,IAAA,CAAK,qBAAA,CAAsB,GAAA,EAAK,IAAA,EAAM,MAAM,CAAA;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,wBAAwB,OAAA,EAAgC;AACvD,IAAA,IAAI,OAAA,CAAQ,MAAA,IAAU,OAAA,CAAQ,OAAA,EAAS;AACtC,MAAA,MAAM,IAAI,MAAM,8CAA8C,CAAA;AAAA,IAC/D;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,mBAAA,CACC,MACA,OAAA,EACS;AACT,IAAA,IAAI,QAAQ,UAAA,EAAY;AACvB,MAAA,OAAO,OAAA,CAAQ,UAAA;AAAA,IAChB;AAEA,IAAA,IAAI,QAAQ,OAAA,EAAS;AAEpB,MAAA,OAAO,iBAAA;AAAA,IACR;AAGA,IAAA,OAAO,YAAY,IAAI,CAAA,CAAA;AAAA,EACxB;AACD;ACzEO,IAAM,kBAAN,MAAsB;AAAA,EACpB,aAAA,uBAAoB,GAAA,EAAwC;AAAA,EAC5D,YAAA;AAAA,EAER,WAAA,GAAc;AAEb,IAAA,MAAM,UAAA,GAAa,aAAA,CAAc,MAAA,CAAA,IAAA,CAAY,GAAG,CAAA;AAChD,IAAA,MAAM,SAAA,GAAY,QAAQ,UAAU,CAAA;AAIpC,IAAA,IAAI,UAAA,GAAa,SAAA;AACjB,IAAA,IAAI,aAAA,GAAgB,EAAA;AAGpB,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,CAAA,EAAG,CAAA,EAAA,EAAK;AAC3B,MAAA,MAAM,aAAA,GAAgBD,IAAAA,CAAK,UAAA,EAAY,uBAAuB,CAAA;AAC9D,MAAA,IAAI;AAEH,QAAA,IAAI,QAAA,CAAS,aAAa,CAAA,CAAE,WAAA,EAAY,EAAG;AAC1C,UAAA,aAAA,GAAgB,aAAA;AAChB,UAAA;AAAA,QACD;AAAA,MACD,CAAA,CAAA,MAAQ;AAAA,MAER;AACA,MAAA,UAAA,GAAa,QAAQ,UAAU,CAAA;AAAA,IAChC;AAEA,IAAA,IAAI,CAAC,aAAA,EAAe;AACnB,MAAA,MAAM,IAAI,KAAA;AAAA,QACT,oEAAoE,SAAS,CAAA;AAAA,OAC9E;AAAA,IACD;AAEA,IAAA,IAAA,CAAK,YAAA,GAAe,aAAA;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKQ,aAAa,YAAA,EAAkD;AAEtE,IAAA,IAAI,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,YAAY,CAAA,EAAG;AACzC,MAAA,OAAO,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,YAAY,CAAA;AAAA,IAC3C;AAGA,IAAA,MAAM,QAAA,GAAWA,IAAAA,CAAK,IAAA,CAAK,YAAA,EAAc,YAAY,CAAA;AACrD,IAAA,MAAM,eAAA,GAAkB,YAAA,CAAa,QAAA,EAAU,OAAO,CAAA;AAGtD,IAAA,MAAM,WAAW,UAAA,CAAW,OAAA,CAAQ,iBAAiB,EAAE,QAAA,EAAU,MAAM,CAAA;AAGvE,IAAA,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,YAAA,EAAc,QAAQ,CAAA;AAE7C,IAAA,OAAO,QAAA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAiB,MAAA,EAAgC;AAChD,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,YAAA,CAAa,mBAAmB,CAAA;AAEtD,IAAA,OAAO,SAAS,MAAM,CAAA;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAmB,MAAA,EAAgC;AAClD,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,YAAA,CAAa,qBAAqB,CAAA;AACxD,IAAA,OAAO,SAAS,MAAM,CAAA;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAqB,MAAA,EAAyC;AAC7D,IAAA,MAAM,EAAE,YAAW,GAAI,MAAA;AAGvB,IAAA,MAAM,eAAe,UAAA,CAAW,QAAA,CAAS,GAAG,CAAA,IAAK,UAAA,CAAW,SAAS,GAAG,CAAA;AAGxE,IAAA,MAAM,YAAY,YAAA,GACf,KAAA,CAAM,IAAA,CAAK,UAAA,CAAW,SAAS,YAAY,CAAC,CAAA,CAAE,GAAA,CAAI,CAAC,CAAA,KAAM,CAAA,CAAE,CAAC,CAAC,IAC7D,EAAC;AAGJ,IAAA,MAAM,OAAA,GAAU;AAAA,MACf,GAAG,MAAA;AAAA,MACH,YAAA;AAAA,MACA,SAAA;AAAA,MACA,eAAA,EAAiB,SAAA,CAAU,IAAA,CAAK,IAAI;AAAA,KACrC;AAEA,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,YAAA,CAAa,uBAAuB,CAAA;AAC1D,IAAA,OAAO,SAAS,OAAO,CAAA;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKA,mBACC,MAAA,EACS;AACT,IAAA,QAAQ,OAAO,UAAA;AAAY,MAC1B,KAAK,MAAA;AACJ,QAAA,OAAO,IAAA,CAAK,iBAAiB,MAAM,CAAA;AAAA,MACpC,KAAK,QAAA;AACJ,QAAA,OAAO,IAAA,CAAK,mBAAmB,MAAM,CAAA;AAAA,MACtC,KAAK,UAAA;AACJ,QAAA,IAAI,EAAE,gBAAgB,MAAA,CAAA,EAAS;AAC9B,UAAA,MAAM,IAAI,MAAM,kDAAkD,CAAA;AAAA,QACnE;AACA,QAAA,OAAO,IAAA,CAAK,qBAAqB,MAAM,CAAA;AAAA,MACxC;AACC,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,qBAAA,EAAyB,MAAA,CAA0B,UAAU,CAAA,CAAE,CAAA;AAAA;AACjF,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAqB,MAAA,EAAgC;AACpD,IAAA,MAAM,EAAE,UAAA,EAAY,IAAA,EAAM,eAAA,EAAgB,GAAI,MAAA;AAC9C,IAAA,MAAM,gBAAA,GAAmB,GAAG,UAAU,CAAA,CAAA,CAAA;AACtC,IAAA,MAAM,cAAA,GACL,WAAW,MAAA,CAAO,CAAC,EAAE,WAAA,EAAY,GAAI,UAAA,CAAW,KAAA,CAAM,CAAC,CAAA;AAGxD,IAAA,MAAM,OAAA,GAAU;AAAA,MACf,GAAG,MAAA;AAAA,MACH,gBAAA;AAAA,MACA,cAAA;AAAA,MACA,YAAY,UAAA,KAAe,MAAA;AAAA,MAC3B,cAAc,UAAA,KAAe,QAAA;AAAA,MAC7B,gBAAgB,UAAA,KAAe;AAAA,KAChC;AAEA,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,YAAA,CAAa,qBAAqB,CAAA;AACxD,IAAA,OAAO,SAAS,OAAO,CAAA;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKA,4BAA4B,MAAA,EAA0D;AACrF,IAAA,MAAM,EAAE,UAAA,EAAY,IAAA,EAAM,WAAA,EAAY,GAAI,MAAA;AAE1C,IAAA,IAAI,eAAe,MAAA,EAAQ;AAC1B,MAAA,OAAO,IAAA,CAAK,2BAAA,CAA4B,IAAA,EAAM,WAAW,CAAA;AAAA,IAC1D,CAAA,MAAA,IAAW,eAAe,QAAA,EAAU;AACnC,MAAA,OAAO,IAAA,CAAK,6BAAA,CAA8B,IAAA,EAAM,WAAW,CAAA;AAAA,IAC5D,CAAA,MAAA,IAAW,eAAe,UAAA,EAAY;AACrC,MAAA,MAAM,aAAc,MAAA,CAAmC,UAAA;AACvD,MAAA,OAAO,IAAA,CAAK,+BAAA,CAAgC,IAAA,EAAM,WAAA,EAAa,UAAU,CAAA;AAAA,IAC1E;AAEA,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,qBAAA,EAAwB,UAAU,CAAA,CAAE,CAAA;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKQ,2BAAA,CAA4B,MAAc,WAAA,EAA6B;AAC9E,IAAA,MAAM,OAAA,GAAU;AAAA,MACf,IAAA;AAAA,MACA,cAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,IAAA,EAAM,GAAG,CAAA;AAAA,MACtC,WAAA,EAAa,WAAA,IAAe,CAAA,YAAA,EAAe,IAAI,CAAA,qBAAA;AAAA,KAChD;AAEA,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,YAAA,CAAa,iCAAiC,CAAA;AACpE,IAAA,OAAO,SAAS,OAAO,CAAA;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKQ,6BAAA,CACP,MACA,WAAA,EACS;AACT,IAAA,MAAM,OAAA,GAAU;AAAA,MACf,IAAA;AAAA,MACA,cAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,IAAA,EAAM,GAAG,CAAA;AAAA,MACtC,WAAA,EAAa,WAAA,IAAe,CAAA,YAAA,EAAe,IAAI,CAAA,uBAAA;AAAA,KAChD;AAEA,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,YAAA,CAAa,mCAAmC,CAAA;AACtE,IAAA,OAAO,SAAS,OAAO,CAAA;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKQ,+BAAA,CACP,IAAA,EACA,WAAA,EACA,UAAA,EACS;AACT,IAAA,MAAM,OAAA,GAAU;AAAA,MACf,IAAA;AAAA,MACA,cAAA,EAAgB,IAAA,CAAK,OAAA,CAAQ,IAAA,EAAM,GAAG,CAAA;AAAA,MACtC,aAAa,WAAA,IAAe,eAAA;AAAA,MAC5B,UAAA;AAAA,MACA,gBAAA,EAAkB,UAAA,CAAW,OAAA,CAAQ,YAAA,EAAc,EAAE;AAAA,KACtD;AAEA,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,YAAA,CAAa,qCAAqC,CAAA;AACxE,IAAA,OAAO,SAAS,OAAO,CAAA;AAAA,EACxB;AACD;ACjQO,SAAS,sBAAsB,GAAA,EAA4B;AACjE,EAAA,MAAM,WAAA,GAAc,CAAC,gBAAA,EAAkB,eAAA,EAAiB,eAAe,CAAA;AACvE,EAAA,KAAA,MAAW,QAAQ,WAAA,EAAa;AAC/B,IAAA,MAAMI,KAAAA,GAAOJ,IAAAA,CAAK,GAAA,EAAK,IAAI,CAAA;AAC3B,IAAA,IAAIC,UAAAA,CAAWG,KAAI,CAAA,EAAG;AACrB,MAAA,OAAOA,KAAAA;AAAA,IACR;AAAA,EACD;AACA,EAAA,OAAO,IAAA;AACR;AAKO,SAAS,WAAW,OAAA,EAAsB;AAChD,EAAA,MAAM,QAAA,GAAW,kBAAkB,OAAO,CAAA;AAC1C,EAAA,OAAO,IAAA,CAAK,MAAM,QAAQ,CAAA;AAC3B;ACbO,SAAS,aAAa,GAAA,EAAqB;AACjD,EAAA,OAAO,GAAA,CACL,MAAM,GAAG,CAAA,CACT,IAAI,CAAC,IAAA,KAAS,KAAK,MAAA,CAAO,CAAC,EAAE,WAAA,EAAY,GAAI,KAAK,KAAA,CAAM,CAAC,EAAE,WAAA,EAAa,CAAA,CACxE,IAAA,CAAK,EAAE,CAAA;AACV;AAYO,SAAS,YAAY,GAAA,EAAqB;AAChD,EAAA,OAAO,GAAA,CACL,QAAQ,UAAA,EAAY,KAAK,EACzB,WAAA,EAAY,CACZ,OAAA,CAAQ,IAAA,EAAM,EAAE,CAAA;AACnB;AAYA,eAAsB,WAAW,QAAA,EAAoC;AACpE,EAAA,IAAI;AACH,IAAA,MAAM,OAAO,QAAQ,CAAA;AACrB,IAAA,OAAO,IAAA;AAAA,EACR,CAAA,CAAA,MAAQ;AACP,IAAA,OAAO,KAAA;AAAA,EACR;AACD;;;ACvBO,IAAM,0BAAN,MAA8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOpC,MAAM,eAAe,GAAA,EAAwC;AAC5D,IAAA,MAAM,QAAA,GAA6B;AAAA,MAClC,IAAI,EAAC;AAAA,MACL,IAAI,EAAC;AAAA,MACL,IAAI;AAAC,KACN;AAEA,IAAA,MAAM,YAAA,GAAe,sBAAsB,GAAG,CAAA;AAC9C,IAAA,IAAI,CAAC,YAAA,IAAgB,CAACH,UAAAA,CAAW,YAAY,CAAA,EAAG;AAC/C,MAAA,OAAO,QAAA;AAAA,IACR;AAEA,IAAA,IAAI;AACH,MAAA,MAAM,OAAA,GAAU,MAAMI,QAAAA,CAAS,YAAA,EAAc,OAAO,CAAA;AACpD,MAAA,MAAM,MAAA,GAAS,WAAW,OAAO,CAAA;AAGjC,MAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,MAAA,CAAO,aAAa,CAAA,EAAG;AACxC,QAAA,QAAA,CAAS,KAAK,MAAA,CAAO,aAAA,CACnB,GAAA,CAAI,CAAC,OAAY,EAAA,CAAG,OAAO,CAAA,CAC3B,MAAA,CAAO,CAAC,CAAA,KAAW,OAAO,MAAM,QAAA,IAAY,CAAA,CAAE,SAAS,CAAC,CAAA;AAAA,MAC3D;AAGA,MAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,MAAA,CAAO,YAAY,CAAA,EAAG;AACvC,QAAA,QAAA,CAAS,KAAK,MAAA,CAAO,YAAA,CACnB,GAAA,CAAI,CAAC,OAAY,EAAA,CAAG,OAAO,CAAA,CAC3B,MAAA,CAAO,CAAC,CAAA,KAAW,OAAO,MAAM,QAAA,IAAY,CAAA,CAAE,SAAS,CAAC,CAAA;AAAA,MAC3D;AAGA,MAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,MAAA,CAAO,UAAU,CAAA,EAAG;AACrC,QAAA,QAAA,CAAS,KAAK,MAAA,CAAO,UAAA,CACnB,GAAA,CAAI,CAAC,WAAgB,MAAA,CAAO,OAAO,CAAA,CACnC,MAAA,CAAO,CAAC,CAAA,KAAW,OAAO,MAAM,QAAA,IAAY,CAAA,CAAE,SAAS,CAAC,CAAA;AAAA,MAC3D;AAGA,MAAA,IAAI,MAAA,CAAO,EAAA,IAAM,OAAO,MAAA,CAAO,EAAA,CAAG,OAAA,KAAY,QAAA,IAAY,MAAA,CAAO,EAAA,CAAG,OAAA,CAAQ,MAAA,GAAS,CAAA,EAAG;AACvF,QAAA,QAAA,CAAS,EAAA,GAAK,OAAO,EAAA,CAAG,OAAA;AAAA,MACzB;AAAA,IACD,SAAS,KAAA,EAAO;AAGf,MAAA,OAAA,CAAQ,IAAA;AAAA,QACP,6CAA6C,KAAA,YAAiB,KAAA,GAAQ,MAAM,OAAA,GAAU,MAAA,CAAO,KAAK,CAAC,CAAA;AAAA,OACpG;AAAA,IACD;AAEA,IAAA,OAAO,QAAA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,eAAe,GAAA,EAA+B;AACnD,IAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,cAAA,CAAe,GAAG,CAAA;AAC9C,IAAA,OACC,QAAA,CAAS,EAAA,CAAG,MAAA,GAAS,CAAA,IACrB,SAAS,EAAA,CAAG,MAAA,GAAS,CAAA,IACrB,QAAA,CAAS,EAAA,CAAG,MAAA,GAAS,CAAA,IACrB,CAAC,CAAC,QAAA,CAAS,EAAA;AAAA,EAEb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,wBAAwB,QAAA,EAA8C;AACrE,IAAA,MAAM,WAA6B,EAAC;AAGpC,IAAA,KAAA,MAAW,WAAA,IAAe,SAAS,EAAA,EAAI;AACtC,MAAA,MAAM,WAAA,GAAc,IAAA,CAAK,kBAAA,CAAmB,WAAA,EAAa,IAAI,CAAA;AAC7D,MAAA,MAAM,UAAA,GAAa,IAAA,CAAK,iBAAA,CAAkB,WAAA,EAAa,IAAI,CAAA;AAE3D,MAAA,QAAA,CAAS,IAAA,CAAK;AAAA,QACb,IAAA,EAAM,IAAA;AAAA,QACN,WAAA;AAAA,QACA,WAAA;AAAA,QACA,eAAA,EAAiB,CAAA,SAAA,EAAY,WAAW,CAAA,2BAAA,EAA8B,UAAU,CAAA,KAAA,CAAA;AAAA,QAChF,YAAA,EAAc;AAAA,UACb,CAAA,kBAAA,EAAqB,WAAW,CAAA,KAAA,EAAQ,WAAW,CAAA,EAAA,CAAA;AAAA,UACnD,CAAA,4CAAA,CAAA;AAAA,UACA,CAAA,mEAAA;AAAA,SACD,CAAE,KAAK,OAAO;AAAA,OACd,CAAA;AAAA,IACF;AAGA,IAAA,KAAA,MAAW,WAAA,IAAe,SAAS,EAAA,EAAI;AACtC,MAAA,MAAM,WAAA,GAAc,IAAA,CAAK,kBAAA,CAAmB,WAAA,EAAa,IAAI,CAAA;AAC7D,MAAA,MAAM,UAAA,GAAa,IAAA,CAAK,iBAAA,CAAkB,WAAA,EAAa,IAAI,CAAA;AAE3D,MAAA,QAAA,CAAS,IAAA,CAAK;AAAA,QACb,IAAA,EAAM,IAAA;AAAA,QACN,WAAA;AAAA,QACA,WAAA;AAAA,QACA,eAAA,EAAiB,CAAA,SAAA,EAAY,WAAW,CAAA,2BAAA,EAA8B,UAAU,CAAA,KAAA,CAAA;AAAA,QAChF,YAAA,EAAc;AAAA,UACb,CAAA,eAAA,EAAkB,WAAW,CAAA,KAAA,EAAQ,WAAW,CAAA,EAAA,CAAA;AAAA,UAChD,CAAA,mFAAA,CAAA;AAAA,UACA,CAAA,8EAAA;AAAA,SACD,CAAE,KAAK,OAAO;AAAA,OACd,CAAA;AAAA,IACF;AAGA,IAAA,KAAA,MAAW,WAAA,IAAe,SAAS,EAAA,EAAI;AACtC,MAAA,MAAM,WAAA,GAAc,IAAA,CAAK,kBAAA,CAAmB,WAAA,EAAa,IAAI,CAAA;AAC7D,MAAA,MAAM,UAAA,GAAa,IAAA,CAAK,iBAAA,CAAkB,WAAA,EAAa,IAAI,CAAA;AAE3D,MAAA,QAAA,CAAS,IAAA,CAAK;AAAA,QACb,IAAA,EAAM,IAAA;AAAA,QACN,WAAA;AAAA,QACA,WAAA;AAAA,QACA,eAAA,EAAiB,CAAA,SAAA,EAAY,WAAW,CAAA,2BAAA,EAA8B,UAAU,CAAA,KAAA,CAAA;AAAA,QAChF,YAAA,EAAc;AAAA,UACb,CAAA,mBAAA,EAAsB,WAAW,CAAA,KAAA,EAAQ,WAAW,CAAA,EAAA,CAAA;AAAA,UACpD,CAAA,wDAAA,CAAA;AAAA,UACA,CAAA,yDAAA;AAAA,SACD,CAAE,KAAK,OAAO;AAAA,OACd,CAAA;AAAA,IACF;AAGA,IAAA,IAAI,SAAS,EAAA,EAAI;AAChB,MAAA,QAAA,CAAS,IAAA,CAAK;AAAA,QACb,IAAA,EAAM,IAAA;AAAA,QACN,aAAa,QAAA,CAAS,EAAA;AAAA,QACtB,YAAA,EAAc;AAAA,UACb,CAAA,gBAAA,CAAA;AAAA,UACA,CAAA,4BAAA,EAA+B,SAAS,EAAE,CAAA,uCAAA,CAAA;AAAA,UAC1C,CAAA,CAAA;AAAA,UACA,CAAA,sBAAA,CAAA;AAAA,UACA,CAAA,+BAAA,EAAkC,SAAS,EAAE,CAAA,qCAAA;AAAA,SAC9C,CAAE,KAAK,OAAO;AAAA,OACd,CAAA;AAAA,IACF;AAEA,IAAA,OAAO,QAAA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,uBAAuB,QAAA,EAAoC;AAC1D,IAAA,MAAM,QAAkB,EAAC;AAEzB,IAAA,IAAI,QAAA,CAAS,EAAA,CAAG,MAAA,GAAS,CAAA,EAAG;AAC3B,MAAA,KAAA,CAAM,KAAK,CAAA,IAAA,EAAO,QAAA,CAAS,GAAG,IAAA,CAAK,IAAI,CAAC,CAAA,CAAE,CAAA;AAAA,IAC3C;AACA,IAAA,IAAI,QAAA,CAAS,EAAA,CAAG,MAAA,GAAS,CAAA,EAAG;AAC3B,MAAA,KAAA,CAAM,KAAK,CAAA,IAAA,EAAO,QAAA,CAAS,GAAG,IAAA,CAAK,IAAI,CAAC,CAAA,CAAE,CAAA;AAAA,IAC3C;AACA,IAAA,IAAI,QAAA,CAAS,EAAA,CAAG,MAAA,GAAS,CAAA,EAAG;AAC3B,MAAA,KAAA,CAAM,KAAK,CAAA,IAAA,EAAO,QAAA,CAAS,GAAG,IAAA,CAAK,IAAI,CAAC,CAAA,CAAE,CAAA;AAAA,IAC3C;AACA,IAAA,IAAI,SAAS,EAAA,EAAI;AAChB,MAAA,KAAA,CAAM,IAAA,CAAK,CAAA,IAAA,EAAO,QAAA,CAAS,EAAE,CAAA,CAAE,CAAA;AAAA,IAChC;AAEA,IAAA,OAAO,KAAA,CAAM,KAAK,KAAK,CAAA;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,kBAAA,CACP,aACA,WAAA,EACS;AACT,IAAA,MAAM,QAAA,GAAW,aAAa,WAAA,CAAY,WAAA,GAAc,OAAA,CAAQ,IAAA,EAAM,GAAG,CAAC,CAAA;AAC1E,IAAA,MAAM,MAAA,GAAS,YAAY,WAAA,EAAY;AACvC,IAAA,OAAO,CAAA,EAAG,QAAQ,CAAA,EAAG,MAAM,CAAA,CAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,iBAAA,CACP,aACA,WAAA,EACS;AACT,IAAA,MAAM,WAAW,WAAA,CAAY,WAAA,EAAY,CAAE,OAAA,CAAQ,MAAM,GAAG,CAAA;AAC5D,IAAA,OAAO,CAAA,EAAG,WAAW,CAAA,CAAA,EAAI,QAAQ,CAAA,CAAA;AAAA,EAClC;AACD;ACvMA,eAAsB,sBAAA,CACrB,GAAA,EACA,UAAA,EACA,IAAA,EACA,aACA,QAAA,EACgB;AAChB,EAAA,MAAM,YAAA,GAAeL,IAAAA,CAAK,GAAA,EAAK,oBAAoB,CAAA;AAEnD,EAAA,IAAI,CAACC,UAAAA,CAAW,YAAY,CAAA,EAAG;AAC9B,IAAA;AAAA,EACD;AAEA,EAAA,IAAI;AACH,IAAA,MAAM,OAAA,GAAU,MAAMI,QAAAA,CAAS,YAAA,EAAc,OAAO,CAAA;AACpD,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,KAAA,CAAM,OAAO,CAAA;AAGnC,IAAA,IAAI,CAAC,QAAA,CAAS,UAAU,CAAA,EAAG;AAC1B,MAAA,QAAA,CAAS,UAAU,IAAI,EAAC;AAAA,IACzB;AAGA,IAAA,MAAM,cAAA,GAAiC;AAAA,MACtC,IAAA;AAAA,MACA,IAAA,EAAM,WAAA;AAAA,MACN,UAAA,EAAY,IAAA;AAAA,MACZ,WAAA,EAAa,QAAA;AAAA,MACb,kBAAA,EAAoB;AAAA,KACrB;AAEA,IAAA,QAAA,CAAS,UAAU,CAAA,CAAE,IAAA,CAAK,cAAc,CAAA;AAExC,IAAA,MAAMC,SAAAA,CAAU,cAAc,IAAA,CAAK,SAAA,CAAU,UAAU,IAAA,EAAM,GAAI,GAAG,OAAO,CAAA;AAAA,EAC5E,SAAS,KAAA,EAAO;AACf,IAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,qDAAA,EAA8C,KAAK,CAAA,CAAE,CAAA;AAAA,EACnE;AACD;AAcA,eAAsB,qBACrB,GAAA,EAC0C;AAC1C,EAAA,MAAM,YAAA,GAAeN,IAAAA,CAAK,GAAA,EAAK,oBAAoB,CAAA;AAEnD,EAAA,IAAI,CAACC,UAAAA,CAAW,YAAY,CAAA,EAAG;AAC9B,IAAA,OAAO,IAAA;AAAA,EACR;AAEA,EAAA,IAAI;AACH,IAAA,MAAM,OAAA,GAAU,MAAMI,QAAAA,CAAS,YAAA,EAAc,OAAO,CAAA;AACpD,IAAA,OAAO,IAAA,CAAK,MAAM,OAAO,CAAA;AAAA,EAC1B,SAAS,KAAA,EAAO;AACf,IAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,mDAAA,EAA4C,KAAK,CAAA,CAAE,CAAA;AAChE,IAAA,OAAO,IAAA;AAAA,EACR;AACD;ACpGO,IAAM,qBAAA,GAAwB,EAAE,MAAA,CAAO;AAAA;AAAA,EAE7C,UAAA,EAAY,CAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA;AAAA,EAEhC,MAAA,EAAQ,CAAA,CAAE,OAAA,EAAQ,CAAE,QAAA,EAAS;AAAA;AAAA,EAE7B,OAAA,EAAS,CAAA,CAAE,OAAA,EAAQ,CAAE,QAAA;AACtB,CAAC;AAOM,IAAM,oBAAA,GAAuB,EAAE,MAAA,CAAO;AAAA;AAAA,EAE5C,YAAY,CAAA,CAAE,IAAA,CAAK,CAAC,MAAA,EAAQ,QAAA,EAAU,UAAU,CAAC,CAAA;AAAA;AAAA,EAEjD,IAAA,EAAM,CAAA,CAAE,MAAA,EAAO,CAAE,MAAM,mBAAA,EAAqB;AAAA,IAC3C,OAAA,EAAS;AAAA,GACT,CAAA;AAAA;AAAA,EAED,WAAA,EAAa,CAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA;AAAA,EAEjC,eAAe,CAAA,CAAE,OAAA,GAAU,QAAA,EAAS,CAAE,QAAQ,IAAI,CAAA;AAAA;AAAA,EAElD,cAAc,CAAA,CAAE,OAAA,GAAU,QAAA,EAAS,CAAE,QAAQ,IAAI,CAAA;AAAA;AAAA,EAEjD,eAAA,EAAiB,sBAAsB,QAAA;AACxC,CAAC,CAAA,CAAE,MAAA;AAAA,EACF,CAAC,IAAA,KAAS;AAET,IAAA,IAAI,IAAA,CAAK,UAAA,KAAe,UAAA,IAAc,CAAC,KAAK,eAAA,EAAiB;AAC5D,MAAA,OAAO,KAAA;AAAA,IACR;AACA,IAAA,OAAO,IAAA;AAAA,EACR,CAAA;AAAA,EACA;AAAA,IACC,OAAA,EAAS,6DAAA;AAAA,IACT,IAAA,EAAM,CAAC,iBAAiB;AAAA;AAE1B,CAAA,CAAE,MAAA;AAAA,EACD,CAAC,IAAA,KAAS;AAET,IAAA,IAAI,IAAA,CAAK,eAAA,EAAiB,MAAA,IAAU,IAAA,CAAK,iBAAiB,OAAA,EAAS;AAClE,MAAA,OAAO,KAAA;AAAA,IACR;AACA,IAAA,OAAO,IAAA;AAAA,EACR,CAAA;AAAA,EACA;AAAA,IACC,OAAA,EAAS,8CAAA;AAAA,IACT,IAAA,EAAM,CAAC,iBAAiB;AAAA;AAE1B;AAWO,IAAM,wBAAA,GAA2B,EAAE,MAAA,CAAO;AAAA;AAAA,EAEhD,YAAY,CAAA,CAAE,IAAA,CAAK,CAAC,MAAA,EAAQ,QAAA,EAAU,UAAU,CAAC,CAAA;AAAA;AAAA,EAEjD,kBAAkB,CAAA,CAAE,IAAA,CAAK,CAAC,OAAA,EAAS,SAAA,EAAW,WAAW,CAAC,CAAA;AAAA;AAAA,EAE1D,SAAA,EAAW,EAAE,MAAA,EAAO;AAAA;AAAA,EAEpB,cAAA,EAAgB,EAAE,MAAA;AACnB,CAAC;AAOM,IAAM,sBAAA,GAAyB,EAAE,MAAA,CAAO;AAAA;AAAA,EAE9C,YAAY,CAAA,CAAE,IAAA,CAAK,CAAC,MAAA,EAAQ,QAAA,EAAU,UAAU,CAAC,CAAA;AAAA;AAAA,EAEjD,SAAA,EAAW,EAAE,MAAA;AACd,CAAC;AAOM,IAAM,oBAAA,GAAuB,EAAE,MAAA,CAAO;AAAA;AAAA,EAE5C,YAAY,CAAA,CAAE,IAAA,CAAK,CAAC,MAAA,EAAQ,QAAA,EAAU,UAAU,CAAC,CAAA;AAAA;AAAA,EAEjD,IAAA,EAAM,EAAE,MAAA,EAAO;AAAA;AAAA,EAEf,eAAA,EAAiB,EAAE,MAAA,EAAO;AAAA;AAAA,EAE1B,WAAA,EAAa,CAAA,CAAE,MAAA,EAAO,CAAE,QAAA;AACzB,CAAC;AAOM,IAAM,6BAAA,GAAgC,qBAAqB,MAAA,CAAO;AAAA;AAAA,EAExE,UAAA,EAAY,CAAA,CAAE,OAAA,CAAQ,UAAU,CAAA;AAAA;AAAA,EAEhC,UAAA,EAAY,EAAE,MAAA;AACf,CAAC;AAOM,IAAM,wBAAA,GAA2B,EAAE,MAAA,CAAO;AAAA;AAAA,EAEhD,YAAY,CAAA,CAAE,IAAA,CAAK,CAAC,MAAA,EAAQ,QAAA,EAAU,UAAU,CAAC,CAAA;AAAA;AAAA,EAEjD,kBAAkB,CAAA,CAAE,IAAA,CAAK,CAAC,OAAA,EAAS,SAAA,EAAW,WAAW,CAAC,CAAA;AAAA;AAAA,EAE1D,SAAA,EAAW,EAAE,MAAA,EAAO;AAAA;AAAA,EAEpB,cAAA,EAAgB,EAAE,MAAA,EAAO;AAAA;AAAA,EAEzB,kBAAA,EAAoB,CAAA,CAAE,UAAA,CAAW,MAAM,CAAA;AAAA;AAAA,EAEvC,WAAA,EAAa,EAAE,MAAA,EAAO;AAAA;AAAA,EAEtB,kBAAA,EAAoB,EAAE,MAAA;AACvB,CAAC;;;ACtGM,IAAM,yBAAN,MAEP;AAAA,EACS,mBAAA;AAAA,EACA,iBAAA;AAAA,EACA,eAAA;AAAA,EACA,uBAAA;AAAA,EAER,WAAA,GAAc;AACb,IAAA,IAAA,CAAK,mBAAA,GAAsB,IAAI,mBAAA,EAAoB;AACnD,IAAA,IAAA,CAAK,iBAAA,GAAoB,IAAI,iBAAA,EAAkB;AAC/C,IAAA,IAAA,CAAK,eAAA,GAAkB,IAAI,eAAA,EAAgB;AAC3C,IAAA,IAAA,CAAK,uBAAA,GAA0B,IAAI,uBAAA,EAAwB;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAA,CAAS,GAAA,EAAa,MAAA,EAAuC;AAElE,IAAA,MAAM,WAAA,GAAc,oBAAA,CAAqB,SAAA,CAAU,MAAM,CAAA;AACzD,IAAA,IAAI,CAAC,YAAY,OAAA,EAAS;AACzB,MAAA,MAAM,UAAA,GAAa,WAAA,CAAY,KAAA,CAAM,MAAA,CAAO,CAAC,CAAA;AAC7C,MAAA,MAAM,IAAI,KAAA,CAAM,UAAA,CAAW,OAAO,CAAA;AAAA,IACnC;AAEA,IAAA,MAAM,EAAE,UAAA,EAAY,IAAA,EAAK,GAAI,WAAA,CAAY,IAAA;AAGzC,IAAA,MAAM,gBAAA,GAAqC;AAAA,MAC1C,UAAA;AAAA,MACA,SAAA,EAAW,OAAO,UAAU,CAAA,CAAA;AAAA,KAC7B;AAEA,IAAA,IAAA,CAAK,iBAAA,CAAkB,cAAA,CAAe,GAAA,EAAK,IAAA,EAAM,gBAAgB,CAAA;AAGjE,IAAA,IAAI,UAAA,KAAe,UAAA,IAAc,MAAA,CAAO,eAAA,EAAiB;AACxD,MAAA,IAAA,CAAK,iBAAA,CAAkB,uBAAA,CAAwB,MAAA,CAAO,eAAe,CAAA;AAAA,IACtE;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,QACL,OAAA,EACgB;AAChB,IAAA,MAAM,EAAE,GAAA,EAAK,MAAA,EAAQ,MAAA,EAAO,GAAI,OAAA;AAEhC,IAAA,MAAM,EAAE,UAAA,EAAY,IAAA,EAAK,GAAI,MAAA;AAC7B,IAAA,MAAM,eAAA,GAAkB,aAAa,IAAI,CAAA;AACzC,IAAA,MAAM,WAAA,GAAc,OAAO,WAAA,IAAe,uBAAA;AAC1C,IAAA,MAAM,aAAA,GAAgB,OAAO,aAAA,KAAkB,KAAA;AAC/C,IAAA,MAAM,YAAA,GAAe,OAAO,YAAA,KAAiB,KAAA;AAG7C,IAAA,MAAM,cAAA,GAAiB,MAAM,IAAA,CAAK,kBAAA;AAAA,MACjC,GAAA;AAAA,MACA,IAAA;AAAA,MACA,eAAA;AAAA,MACA,WAAA;AAAA,MACA;AAAA,KACD;AACA,IAAA,MAAA,CAAO,YAAA,CAAa,KAAK,cAAc,CAAA;AAGvC,IAAA,IAAI,aAAA,EAAe;AAClB,MAAA,MAAM,SAAA,GAAY,MAAM,IAAA,CAAK,iBAAA;AAAA,QAC5B,GAAA;AAAA,QACA,IAAA;AAAA,QACA,eAAA;AAAA,QACA,WAAA;AAAA,QACA;AAAA,OACD;AACA,MAAA,MAAA,CAAO,YAAA,CAAa,IAAA,CAAK,GAAG,SAAS,CAAA;AAAA,IACtC;AAGA,IAAA,IAAI,YAAA,EAAc;AACjB,MAAA,MAAM,kBAAA,GAAyC;AAAA,QAC9C,UAAA;AAAA,QACA,gBAAA,EAAkB,GAAG,UAAU,CAAA,CAAA,CAAA;AAAA,QAC/B,SAAA,EAAW,KAAK,UAAU,CAAA,EAAA,CAAA;AAAA,QAC1B,cAAA,EACC,WAAW,MAAA,CAAO,CAAC,EAAE,WAAA,EAAY,GAAI,UAAA,CAAW,KAAA,CAAM,CAAC;AAAA,OACzD;AAEA,MAAA,MAAM,KAAK,mBAAA,CAAoB,cAAA;AAAA,QAC9B,GAAA;AAAA,QACA,IAAA;AAAA,QACA,eAAA;AAAA,QACA;AAAA,OACD;AACA,MAAA,MAAA,CAAO,UAAA,GAAa,IAAA;AAAA,IACrB;AAGA,IAAA,MAAM,sBAAA;AAAA,MACL,GAAA;AAAA,MACA,GAAG,UAAU,CAAA,CAAA,CAAA;AAAA,MACb,IAAA;AAAA,MACA,CAAA,IAAA,EAAO,UAAU,CAAA,EAAA,EAAK,IAAI,CAAA,GAAA,CAAA;AAAA,MAC1B;AAAA,KACD;AAEA,IAAA,MAAA,CAAO,OAAA,GAAU,IAAA;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,WAAA,GAAuB;AACtB,IAAA,OAAO,KAAA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,YAAA,GAAqC;AACpC,IAAA,OAAO;AAAA,MACN,OAAA,EAAS,KAAA;AAAA,MACT,cAAc,EAAC;AAAA,MACf,UAAA,EAAY,KAAA;AAAA,MACZ,UAAU;AAAC,KACZ;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,kBAAA,CACb,GAAA,EACA,IAAA,EACA,eAAA,EACA,aACA,MAAA,EACkB;AAClB,IAAA,MAAM,EAAE,UAAA,EAAY,eAAA,EAAgB,GAAI,MAAA;AACxC,IAAA,MAAM,UAAUL,IAAAA,CAAK,GAAA,EAAK,KAAA,EAAO,CAAA,EAAG,UAAU,CAAA,CAAA,CAAG,CAAA;AACjD,IAAA,MAAM,QAAA,GAAWA,IAAAA,CAAK,OAAA,EAAS,CAAA,EAAG,IAAI,CAAA,GAAA,CAAK,CAAA;AAG3C,IAAA,MAAM,KAAA,CAAM,OAAA,EAAS,EAAE,SAAA,EAAW,MAAM,CAAA;AAGxC,IAAA,IAAI,cAAA;AACJ,IAAA,IAAI,eAAe,MAAA,EAAQ;AAC1B,MAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,uBAAA,CAAwB,eAAe,GAAG,CAAA;AACtE,MAAA,MAAM,WAAA,GACL,QAAA,CAAS,EAAA,CAAG,MAAA,GAAS,KACrB,QAAA,CAAS,EAAA,CAAG,MAAA,GAAS,CAAA,IACrB,SAAS,EAAA,CAAG,MAAA,GAAS,CAAA,IACrB,CAAC,CAAC,QAAA,CAAS,EAAA;AAEZ,MAAA,IAAI,WAAA,EAAa;AAChB,QAAA,MAAM,QAAA,GACL,IAAA,CAAK,uBAAA,CAAwB,uBAAA,CAAwB,QAAQ,CAAA;AAC9D,QAAA,MAAM,OAAA,GACL,IAAA,CAAK,uBAAA,CAAwB,sBAAA,CAAuB,QAAQ,CAAA;AAE7D,QAAA,cAAA,GAAiB;AAAA,UAChB,WAAA,EAAa,IAAA;AAAA,UACb,cAAA,EAAgB,OAAA;AAAA,UAChB,eAAA,EAAiB;AAAA,SAClB;AAAA,MACD,CAAA,MAAO;AACN,QAAA,cAAA,GAAiB;AAAA,UAChB,WAAA,EAAa;AAAA,SACd;AAAA,MACD;AAAA,IACD;AAEA,IAAA,IAAI,OAAA;AAEJ,IAAA,IAAI,UAAA,KAAe,cAAc,eAAA,EAAiB;AAEjD,MAAA,MAAM,UAAA,GAAa,KAAK,iBAAA,CAAkB,mBAAA;AAAA,QACzC,IAAA;AAAA,QACA;AAAA,OACD;AAEA,MAAA,MAAM,cAAA,GAA0C;AAAA,QAC/C,UAAA;AAAA,QACA,IAAA;AAAA,QACA,eAAA;AAAA,QACA,WAAA;AAAA,QACA;AAAA,OACD;AAEA,MAAA,OAAA,GAAU,IAAA,CAAK,eAAA,CAAgB,kBAAA,CAAmB,cAAc,CAAA;AAAA,IACjE,CAAA,MAAO;AACN,MAAA,OAAA,GAAU,IAAA,CAAK,gBAAgB,kBAAA,CAAmB;AAAA,QACjD,UAAA;AAAA,QACA,IAAA;AAAA,QACA,eAAA;AAAA,QACA,WAAA;AAAA,QACA;AAAA,OACA,CAAA;AAAA,IACF;AAEA,IAAA,MAAMM,SAAAA,CAAU,QAAA,EAAU,OAAA,EAAS,OAAO,CAAA;AAC1C,IAAA,OAAO,QAAA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBAAA,CACb,GAAA,EACA,IAAA,EACA,eAAA,EACA,aACA,MAAA,EACoB;AACpB,IAAA,MAAM,EAAE,UAAA,EAAY,eAAA,EAAgB,GAAI,MAAA;AACxC,IAAA,MAAM,YAAsB,EAAC;AAG7B,IAAA,MAAM,YAAA,GAAe,MAAM,IAAA,CAAK,gBAAA;AAAA,MAC/B,GAAA;AAAA,MACA,IAAA;AAAA,MACA,eAAA;AAAA,MACA,WAAA;AAAA,MACA;AAAA,KACD;AACA,IAAA,SAAA,CAAU,KAAK,YAAY,CAAA;AAG3B,IAAA,MAAM,mBAAA,GAAsB,MAAM,IAAA,CAAK,uBAAA;AAAA,MACtC,GAAA;AAAA,MACA,IAAA;AAAA,MACA,eAAA;AAAA,MACA,WAAA;AAAA,MACA,UAAA;AAAA,MACA;AAAA,KACD;AACA,IAAA,SAAA,CAAU,KAAK,mBAAmB,CAAA;AAElC,IAAA,OAAO,SAAA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,gBAAA,CACb,GAAA,EACA,IAAA,EACA,eAAA,EACA,aACA,UAAA,EACkB;AAClB,IAAA,MAAM,UAAUN,IAAAA,CAAK,GAAA,EAAK,QAAQ,MAAA,EAAQ,CAAA,EAAG,UAAU,CAAA,CAAA,CAAG,CAAA;AAC1D,IAAA,MAAM,QAAA,GAAWA,IAAAA,CAAK,OAAA,EAAS,CAAA,EAAG,IAAI,CAAA,QAAA,CAAU,CAAA;AAEhD,IAAA,MAAM,KAAA,CAAM,OAAA,EAAS,EAAE,SAAA,EAAW,MAAM,CAAA;AAExC,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,eAAA,CAAgB,oBAAA,CAAqB;AAAA,MACzD,UAAA;AAAA,MACA,IAAA;AAAA,MACA,eAAA;AAAA,MACA;AAAA,KACA,CAAA;AAED,IAAA,MAAMM,SAAAA,CAAU,QAAA,EAAU,OAAA,EAAS,OAAO,CAAA;AAC1C,IAAA,OAAO,QAAA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,uBAAA,CACb,GAAA,EACA,MACA,eAAA,EACA,WAAA,EACA,YACA,eAAA,EACkB;AAElB,IAAA,MAAM,OAAA,GAAUN,IAAAA;AAAA,MACf,GAAA;AAAA,MACA,MAAA;AAAA,MACA,aAAA;AAAA,MACA,OAAA;AAAA,MACA,UAAA,KAAe,MAAA,GAAS,EAAA,GAAK,CAAA,EAAG,UAAU,CAAA,CAAA;AAAA,KAC3C;AACA,IAAA,MAAM,QAAA,GAAWA,IAAAA,CAAK,OAAA,EAAS,CAAA,EAAG,IAAI,CAAA,KAAA,CAAO,CAAA;AAE7C,IAAA,MAAM,KAAA,CAAM,OAAA,EAAS,EAAE,SAAA,EAAW,MAAM,CAAA;AAExC,IAAA,IAAI,OAAA;AAEJ,IAAA,IAAI,UAAA,KAAe,cAAc,eAAA,EAAiB;AACjD,MAAA,MAAM,UAAA,GAAa,KAAK,iBAAA,CAAkB,mBAAA;AAAA,QACzC,IAAA;AAAA,QACA;AAAA,OACD;AAEA,MAAA,OAAA,GAAU,IAAA,CAAK,gBAAgB,2BAAA,CAA4B;AAAA,QAC1D,UAAA;AAAA,QACA,IAAA;AAAA,QACA,eAAA;AAAA,QACA,WAAA;AAAA,QACA;AAAA,OACA,CAAA;AAAA,IACF,CAAA,MAAO;AACN,MAAA,OAAA,GAAU,IAAA,CAAK,gBAAgB,2BAAA,CAA4B;AAAA,QAC1D,UAAA;AAAA,QACA,IAAA;AAAA,QACA,eAAA;AAAA,QACA;AAAA,OACA,CAAA;AAAA,IACF;AAEA,IAAA,MAAMM,SAAAA,CAAU,QAAA,EAAU,OAAA,EAAS,OAAO,CAAA;AAC1C,IAAA,OAAO,QAAA;AAAA,EACR;AACD,CAAA;;;AC7UO,IAAM,mBAAN,MAAuB;AAAA,EACrB,YAAA;AAAA,EACA,QAAA;AAAA,EAER,WAAA,GAAc;AACb,IAAA,IAAA,CAAK,YAAA,GAAe,IAAI,oBAAA,EAAqB;AAC7C,IAAA,IAAA,CAAK,QAAA,GAAW,IAAI,sBAAA,EAAuB;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,QAAA,CAAS,GAAA,EAAa,MAAA,EAAiD;AAE5E,IAAA,OAAO,KAAK,YAAA,CAAa,QAAA,CAAS,GAAA,EAAK,MAAA,EAAQ,KAAK,QAAQ,CAAA;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,eAAe,UAAA,EAAoD;AACzE,IAAA,QAAQ,UAAA;AAAY,MACnB,KAAK,MAAA;AACJ,QAAA,OAAO,WAAA;AAAA,MACR,KAAK,QAAA;AACJ,QAAA,OAAO,WAAA;AAAA,MACR,KAAK,UAAA;AACJ,QAAA,OAAO,WAAA;AAAA;AACT,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,qBACN,UAAA,EACS;AACT,IAAA,OAAO,UAAA,CAAW,OAAO,CAAC,CAAA,CAAE,aAAY,GAAI,UAAA,CAAW,MAAM,CAAC,CAAA;AAAA,EAC/D;AACD;AC9BO,IAAM,eAAN,MAAmB;AAAA,EACzB,YAAoB,MAAA,EAAsB;AAAtB,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AAAA,EAAuB;AAAA;AAAA;AAAA;AAAA,EAK3C,aAAA,GAAyB;AACxB,IAAA,OAAO,IAAI,OAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,gBAAgB,CAAA,CAC7C,WAAA;AAAA,MACA,CAAA,SAAA,EAAY,IAAA,CAAK,MAAA,CAAO,gBAAgB,CAAA,0BAAA;AAAA,KACzC,CACC,MAAA,CAAO,YAAA,EAAc,gBAAgB,CAAA,CACrC,MAAA;AAAA,MACA,uBAAA;AAAA,MACA,oEAAA;AAAA,MACA;AAAA,KACD,CACC,MAAA;AAAA,MACA,iBAAA;AAAA,MACA,CAAA,gBAAA,EAAmB,IAAA,CAAK,MAAA,CAAO,gBAAgB,CAAA,UAAA;AAAA,KAChD,CACC,MAAA,CAAO,OAAO,OAAA,KAAY;AAC1B,MAAA,MAAM,GAAA,GAAM,QAAQ,GAAA,EAAI;AAExB,MAAA,IAAI;AACH,QAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,gBAAA;AAAA,UAC3B,GAAA;AAAA,UACA,OAAA,CAAQ;AAAA,SACT;AAGA,QAAA,MAAM,QAAA,GAAW,IAAA,CAAK,cAAA,CAAe,QAAA,EAAU,QAAQ,MAAM,CAAA;AAG7D,QAAA,IAAI,QAAQ,IAAA,EAAM;AACjB,UAAA,OAAA,CAAQ,IAAI,IAAA,CAAK,SAAA,CAAU,QAAA,EAAU,IAAA,EAAM,CAAC,CAAC,CAAA;AAAA,QAC9C,CAAA,MAAO;AACN,UAAA,IAAA,CAAK,WAAW,QAAQ,CAAA;AAAA,QACzB;AAAA,MACD,SAAS,KAAA,EAAO;AACf,QAAA,OAAA,CAAQ,KAAA;AAAA,UACP,iBAAY,KAAA,YAAiB,KAAA,GAAQ,MAAM,OAAA,GAAU,MAAA,CAAO,KAAK,CAAC,CAAA;AAAA,SACnE;AACA,QAAA,OAAA,CAAQ,KAAK,CAAC,CAAA;AAAA,MACf;AAAA,IACD,CAAC,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAA,CACL,GAAA,EACA,eAAA,GAAkB,KAAA,EACM;AACxB,IAAA,MAAM,WAAyB,EAAC;AAGhC,IAAA,MAAM,YAAY,IAAA,CAAK,IAAA,CAAK,GAAA,EAAK,IAAA,CAAK,OAAO,SAAS,CAAA;AACtD,IAAA,IAAI,cAAwB,EAAC;AAE7B,IAAA,IAAI;AACH,MAAA,MAAM,KAAA,GAAQ,MAAM,EAAA,CAAG,OAAA,CAAQ,SAAS,CAAA;AACxC,MAAA,WAAA,GAAc,KAAA,CACZ,OAAO,CAAC,CAAA,KAAM,EAAE,QAAA,CAAS,KAAK,CAAA,IAAK,CAAC,CAAA,CAAE,QAAA,CAAS,UAAU,CAAC,CAAA,CAC1D,OAAO,CAAC,CAAA,KAAM,mBAAmB,CAAC,CAAA,CAAE,UAAA,CAAW,UAAU,CAAC,CAAA;AAAA,IAC7D,SAAS,KAAA,EAAO;AACf,MAAA,MAAM,IAAI,KAAA;AAAA,QACT,CAAA,EAAG,IAAA,CAAK,MAAA,CAAO,SAAS,CAAA,wDAAA;AAAA,OACzB;AAAA,IACD;AAGA,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,IAAA,CAAK,GAAA,EAAK,OAAO,UAAU,CAAA;AAClD,IAAA,MAAM,kBAAA,GAAqB,MAAM,IAAA,CAAK,kBAAA,CAAmB,SAAS,CAAA;AAGlE,IAAA,KAAA,MAAW,QAAQ,WAAA,EAAa;AAC/B,MAAA,MAAM,UAAA,GAAa,IAAA,CAAK,QAAA,CAAS,IAAA,EAAM,KAAK,CAAA;AAC5C,MAAA,MAAM,UAAA,GAAa,IAAA,CAAK,IAAA,CAAK,SAAA,EAAW,IAAI,CAAA;AAG5C,MAAA,MAAM,UAAA,GAAa,kBAAA,CAAmB,QAAA,CAAS,UAAU,CAAA;AAGzD,MAAA,MAAM,eAAe,IAAA,CAAK,IAAA;AAAA,QACzB,GAAA;AAAA,QACA,KAAK,MAAA,CAAO,WAAA;AAAA,QACZ,GAAG,UAAU,CAAA,QAAA;AAAA,OACd;AACA,MAAA,MAAM,WAAA,GAAc,MAAM,UAAA,CAAW,YAAY,CAAA;AAGjD,MAAA,MAAM,sBAAsB,IAAA,CAAK,IAAA;AAAA,QAChC,GAAA;AAAA,QACA,KAAK,MAAA,CAAO,kBAAA;AAAA,QACZ,GAAG,UAAU,CAAA,KAAA;AAAA,OACd;AACA,MAAA,MAAM,kBAAA,GAAqB,MAAM,UAAA,CAAW,mBAAmB,CAAA;AAG/D,MAAA,MAAM,WAAA,GAAc,MAAM,IAAA,CAAK,kBAAA,CAAmB,UAAU,CAAA;AAE5D,MAAA,QAAA,CAAS,IAAA,CAAK;AAAA,QACb,IAAA,EAAM,UAAA;AAAA,QACN,IAAA,EAAM,IAAA,CAAK,QAAA,CAAS,GAAA,EAAK,UAAU,CAAA;AAAA,QACnC,UAAA;AAAA,QACA,WAAA;AAAA,QACA,kBAAA;AAAA,QACA;AAAA,OACA,CAAA;AAAA,IACF;AAEA,IAAA,OAAO,QAAA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAmB,SAAA,EAAsC;AAC9D,IAAA,IAAI;AACH,MAAA,MAAM,OAAA,GAAU,MAAM,EAAA,CAAG,QAAA,CAAS,WAAW,OAAO,CAAA;AACpD,MAAA,MAAM,aAAuB,EAAC;AAE9B,MAAA,IAAI,KAAA;AAEJ,MAAA,OAAA,CAAQ,QAAQ,IAAA,CAAK,MAAA,CAAO,oBAAoB,IAAA,CAAK,OAAO,OAAO,IAAA,EAAM;AACxE,QAAA,MAAM,UAAA,GAAa,WAAA,CAAY,KAAA,CAAM,CAAC,CAAC,CAAA;AACvC,QAAA,UAAA,CAAW,KAAK,UAAU,CAAA;AAAA,MAC3B;AAEA,MAAA,OAAO,UAAA;AAAA,IACR,SAAS,KAAA,EAAO;AACf,MAAA,OAAO,EAAC;AAAA,IACT;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,cAAA,CAAe,UAAwB,MAAA,EAA8B;AACpE,IAAA,QAAQ,MAAA,CAAO,aAAY;AAAG,MAC7B,KAAK,YAAA;AACJ,QAAA,OAAO,QAAA,CAAS,MAAA,CAAO,CAAC,CAAA,KAAM,EAAE,UAAU,CAAA;AAAA,MAC3C,KAAK,cAAA;AACJ,QAAA,OAAO,SAAS,MAAA,CAAO,CAAC,CAAA,KAAM,CAAC,EAAE,UAAU,CAAA;AAAA,MAC5C,KAAK,QAAA;AACJ,QAAA,OAAO,SAAS,MAAA,CAAO,CAAC,MAAM,CAAA,CAAE,WAAA,IAAe,EAAE,kBAAkB,CAAA;AAAA,MACpE,KAAK,UAAA;AACJ,QAAA,OAAO,QAAA,CAAS,OAAO,CAAC,CAAA,KAAM,CAAC,CAAA,CAAE,WAAA,IAAe,CAAC,CAAA,CAAE,kBAAkB,CAAA;AAAA,MACtE,KAAK,KAAA;AAAA,MACL;AACC,QAAA,OAAO,QAAA;AAAA;AACT,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW,QAAA,EAA8B;AACxC,IAAA,IAAI,QAAA,CAAS,WAAW,CAAA,EAAG;AAC1B,MAAA,OAAA,CAAQ,GAAA,CAAI,CAAA,GAAA,EAAM,IAAA,CAAK,MAAA,CAAO,gBAAgB,CAAA;AAAA,CAAW,CAAA;AACzD,MAAA;AAAA,IACD;AAEA,IAAA,OAAA,CAAQ,GAAA;AAAA,MACP;AAAA,MAAA,EAAW,QAAA,CAAS,MAAM,CAAA,CAAA,EAAI,QAAA,CAAS,MAAA,KAAW,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,UAAA,GAAa,IAAA,CAAK,MAAA,CAAO,gBAAgB,CAAA;AAAA;AAAA,KAC5G;AAGA,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,GAAA,CAAI,EAAA,EAAI,GAAG,QAAA,CAAS,GAAA,CAAI,CAAC,CAAA,KAAM,CAAA,CAAE,IAAA,CAAK,MAAM,CAAC,CAAA;AACpE,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,GAAA,CAAI,EAAA,EAAI,GAAG,QAAA,CAAS,GAAA,CAAI,CAAC,CAAA,KAAM,CAAA,CAAE,IAAA,CAAK,MAAM,CAAC,CAAA;AAGpE,IAAA,MAAM,MAAA,GAAS,CAAA,EAAG,MAAA,CAAO,MAAA,CAAO,SAAS,CAAC,CAAA,sBAAA,EAAyB,MAAA,CAAO,MAAA,CAAO,SAAS,CAAC,CAAA,CAAA;AAC3F,IAAA,OAAA,CAAQ,IAAI,MAAM,CAAA;AAClB,IAAA,OAAA,CAAQ,GAAA,CAAI,GAAA,CAAI,MAAA,CAAO,MAAA,CAAO,MAAM,CAAC,CAAA;AAGrC,IAAA,KAAA,MAAW,UAAU,QAAA,EAAU;AAC9B,MAAA,MAAM,IAAA,GAAO,MAAA,CAAO,IAAA,CAAK,MAAA,CAAO,SAAS,CAAA;AACzC,MAAA,MAAM,GAAA,GAAM,MAAA,CAAO,UAAA,GAAa,UAAA,GAAQ,UAAA;AACxC,MAAA,MAAM,IAAA,GAAO,MAAA,CAAO,WAAA,GAAc,UAAA,GAAQ,UAAA;AAC1C,MAAA,MAAM,GAAA,GAAM,MAAA,CAAO,kBAAA,GAAqB,UAAA,GAAQ,UAAA;AAChD,MAAA,MAAM,IAAA,GAAO,MAAA,CAAO,IAAA,CAAK,MAAA,CAAO,SAAS,CAAA;AAEzC,MAAA,OAAA,CAAQ,GAAA,CAAI,CAAA,EAAG,IAAI,CAAA,GAAA,EAAM,GAAG,CAAA,GAAA,EAAM,IAAI,CAAA,GAAA,EAAM,GAAG,CAAA,GAAA,EAAM,IAAI,CAAA,CAAE,CAAA;AAG3D,MAAA,IAAI,MAAA,CAAO,WAAA,IAAe,MAAA,CAAO,WAAA,KAAgB,gBAAA,EAAkB;AAClE,QAAA,OAAA,CAAQ,GAAA,CAAI,GAAG,EAAA,CAAG,MAAA,CAAO,SAAS,CAAC,CAAA,GAAA,EAAM,MAAA,CAAO,WAAW,CAAA,CAAE,CAAA;AAAA,MAC9D;AAAA,IACD;AAGA,IAAA,MAAM,aAAa,QAAA,CAAS,MAAA,CAAO,CAAC,CAAA,KAAM,CAAA,CAAE,UAAU,CAAA,CAAE,MAAA;AACxD,IAAA,MAAM,gBAAgB,QAAA,CAAS,MAAA,CAAO,CAAC,CAAA,KAAM,CAAA,CAAE,WAAW,CAAA,CAAE,MAAA;AAC5D,IAAA,MAAM,uBAAuB,QAAA,CAAS,MAAA;AAAA,MACrC,CAAC,MAAM,CAAA,CAAE;AAAA,KACV,CAAE,MAAA;AAEF,IAAA,OAAA,CAAQ,IAAI,YAAY,CAAA;AACxB,IAAA,OAAA,CAAQ,IAAI,CAAA,oBAAA,EAAuB,UAAU,CAAA,CAAA,EAAI,QAAA,CAAS,MAAM,CAAA,CAAE,CAAA;AAClE,IAAA,OAAA,CAAQ,IAAI,CAAA,oBAAA,EAAuB,aAAa,CAAA,CAAA,EAAI,QAAA,CAAS,MAAM,CAAA,CAAE,CAAA;AACrE,IAAA,OAAA,CAAQ,GAAA;AAAA,MACP,CAAA,qBAAA,EAAwB,oBAAoB,CAAA,CAAA,EAAI,QAAA,CAAS,MAAM,CAAA;AAAA,KAChE;AACA,IAAA,OAAA,CAAQ,IAAI,EAAE,CAAA;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,mBAAmB,QAAA,EAAmC;AACnE,IAAA,IAAI;AACH,MAAA,MAAM,OAAA,GAAU,MAAM,EAAA,CAAG,QAAA,CAAS,UAAU,OAAO,CAAA;AAGnD,MAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,KAAA,CAAM,IAAA,CAAK,OAAO,kBAAkB,CAAA;AAE1D,MAAA,IAAI,KAAA,IAAS,KAAA,CAAM,CAAC,CAAA,EAAG;AACtB,QAAA,OAAO,MAAM,CAAC,CAAA;AAAA,MACf;AAGA,MAAA,MAAM,WAAA,GAAc,6BAAA;AACpB,MAAA,MAAM,WAAA,GAAc,OAAA,CAAQ,KAAA,CAAM,WAAW,CAAA;AAE7C,MAAA,IAAI,WAAA,IAAe,WAAA,CAAY,CAAC,CAAA,EAAG;AAClC,QAAA,OAAO,WAAA,CAAY,CAAC,CAAA,CAAE,IAAA,EAAK;AAAA,MAC5B;AAEA,MAAA,OAAO,gBAAA;AAAA,IACR,SAAS,KAAA,EAAO;AACf,MAAA,OAAO,gBAAA;AAAA,IACR;AAAA,EACD;AACD","file":"index.js","sourcesContent":["/**\n * Backup and Restore Utilities\n *\n * Provides safe file backup/restore functionality for add-auth command.\n * Creates timestamped backups and supports rollback on failure.\n */\n\nimport { cp, rm, readdir, stat } from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport { join } from \"node:path\";\n\n/**\n * Create a backup of important project files\n *\n * @param cwd - Project root directory\n * @returns Path to backup directory\n */\nexport async function createBackup(cwd: string): Promise<string> {\n\tconst timestamp = Date.now();\n\tconst backupDir = join(cwd, `.backup-auth-${timestamp}`);\n\n\t// Backup src directory\n\tconst srcDir = join(cwd, \"src\");\n\tif (existsSync(srcDir)) {\n\t\tawait cp(srcDir, join(backupDir, \"src\"), { recursive: true });\n\t}\n\n\t// Backup important config files\n\tconst filesToBackup = [\n\t\t\"package.json\",\n\t\t\"wrangler.toml\",\n\t\t\"wrangler.jsonc\",\n\t\t\"wrangler.json\",\n\t\t\"vercel.json\",\n\t\t\"next.config.js\",\n\t\t\"next.config.mjs\",\n\t\t\"next.config.ts\",\n\t\t\"README.md\",\n\t\t\".gitignore\",\n\t\t\".env\",\n\t\t\".env.local\",\n\t];\n\n\tfor (const file of filesToBackup) {\n\t\tconst filePath = join(cwd, file);\n\t\tif (existsSync(filePath)) {\n\t\t\tawait cp(filePath, join(backupDir, file));\n\t\t}\n\t}\n\n\treturn backupDir;\n}\n\n/**\n * Restore project from backup directory\n *\n * @param backupDir - Path to backup directory\n * @param cwd - Project root directory\n */\nexport async function restoreFromBackup(\n\tbackupDir: string,\n\tcwd: string,\n): Promise<void> {\n\tif (!existsSync(backupDir)) {\n\t\tthrow new Error(`Backup directory not found: ${backupDir}`);\n\t}\n\n\t// Restore src directory\n\tconst backupSrcDir = join(backupDir, \"src\");\n\tif (existsSync(backupSrcDir)) {\n\t\tconst targetSrcDir = join(cwd, \"src\");\n\n\t\t// Remove current src directory if it exists\n\t\tif (existsSync(targetSrcDir)) {\n\t\t\tawait rm(targetSrcDir, { recursive: true, force: true });\n\t\t}\n\n\t\t// Restore from backup\n\t\tawait cp(backupSrcDir, targetSrcDir, { recursive: true });\n\t}\n\n\t// Restore config files\n\tconst backupFiles = await readdir(backupDir);\n\n\tfor (const file of backupFiles) {\n\t\tif (file === \"src\") {\n\t\t\tcontinue; // Already handled\n\t\t}\n\n\t\tconst backupFilePath = join(backupDir, file);\n\t\tconst targetFilePath = join(cwd, file);\n\n\t\t// Only restore if it's a file, not a directory\n\t\tconst stats = await stat(backupFilePath);\n\t\tif (stats.isFile()) {\n\t\t\tawait cp(backupFilePath, targetFilePath);\n\t\t}\n\t}\n}\n\n/**\n * Remove backup directory\n *\n * @param backupDir - Path to backup directory\n */\nexport async function removeBackup(backupDir: string): Promise<void> {\n\tif (existsSync(backupDir)) {\n\t\tawait rm(backupDir, { recursive: true, force: true });\n\t}\n}\n\n/**\n * List all backup directories in a project\n *\n * @param cwd - Project root directory\n * @returns Array of backup directory paths\n */\nexport async function listBackups(cwd: string): Promise<string[]> {\n\tif (!existsSync(cwd)) {\n\t\treturn [];\n\t}\n\n\tconst entries = await readdir(cwd);\n\tconst backups: string[] = [];\n\n\tfor (const entry of entries) {\n\t\tif (entry.startsWith(\".backup-auth-\")) {\n\t\t\tconst fullPath = join(cwd, entry);\n\t\t\tconst stats = await stat(fullPath);\n\n\t\t\tif (stats.isDirectory()) {\n\t\t\t\tbackups.push(fullPath);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Sort by timestamp (newest first)\n\treturn backups.sort().reverse();\n}\n","/**\n * Scaffold Orchestrator\n *\n * Implements the Template Method pattern to orchestrate scaffolding operations.\n * Eliminates duplication by extracting common flow: validate → backup → execute → cleanup/rollback.\n *\n * Strategies implement only their specific logic, while orchestrator handles:\n * - Validation coordination\n * - Backup/restore on failure\n * - Error handling\n * - Success cleanup\n */\n\nimport {\n\tcreateBackup,\n\trestoreFromBackup,\n\tremoveBackup,\n} from \"../backup-restore.js\";\nimport type {\n\tScaffoldStrategy,\n\tScaffoldContext,\n\tScaffoldOptions,\n} from \"./types.js\";\n\n/**\n * Orchestrator for scaffolding operations\n *\n * Uses Strategy Pattern to delegate specific logic while handling common orchestration\n */\nexport class ScaffoldOrchestrator<TConfig = any, TResult extends Record<string, any> = any> {\n\t/**\n\t * Execute scaffolding with given strategy\n\t *\n\t * Template Method that defines the scaffolding algorithm:\n\t * 1. Create context\n\t * 2. Validate\n\t * 3. Backup (if needed)\n\t * 4. Execute strategy\n\t * 5. Cleanup backup on success\n\t * 6. Rollback on failure\n\t *\n\t * @param cwd - Current working directory\n\t * @param config - Configuration for scaffolding\n\t * @param strategy - Strategy to execute\n\t * @param options - Optional orchestration options\n\t * @returns Result from strategy\n\t */\n\tasync scaffold(\n\t\tcwd: string,\n\t\tconfig: TConfig,\n\t\tstrategy: ScaffoldStrategy<TConfig, TResult>,\n\t\toptions: ScaffoldOptions = {},\n\t): Promise<TResult> {\n\t\t// Create context\n\t\tconst context = this.createContext(cwd, config, strategy);\n\n\t\t// Dry run mode - validate only\n\t\tif (options.dryRun) {\n\t\t\tawait strategy.validate(cwd, config);\n\t\t\treturn context.result;\n\t\t}\n\n\t\ttry {\n\t\t\t// Step 1: Validation\n\t\t\tawait strategy.validate(cwd, config);\n\n\t\t\t// Step 2: Backup (if needed and not skipped)\n\t\t\tif (strategy.needsBackup() && !options.skipBackup) {\n\t\t\t\tcontext.backupDir = await createBackup(cwd);\n\t\t\t}\n\n\t\t\t// Step 3: Execute strategy-specific logic\n\t\t\tawait strategy.execute(context);\n\n\t\t\t// Step 4: Cleanup backup on success\n\t\t\tif (context.backupDir) {\n\t\t\t\tawait removeBackup(context.backupDir);\n\t\t\t\tcontext.backupDir = undefined;\n\t\t\t}\n\n\t\t\treturn context.result;\n\t\t} catch (error) {\n\t\t\t// Step 5: Rollback on failure\n\t\t\tif (context.backupDir) {\n\t\t\t\ttry {\n\t\t\t\t\tawait restoreFromBackup(context.backupDir, cwd);\n\t\t\t\t\tawait removeBackup(context.backupDir);\n\t\t\t\t} catch (rollbackError) {\n\t\t\t\t\t// Add rollback failure to error context\n\t\t\t\t\tconst rollbackMsg =\n\t\t\t\t\t\trollbackError instanceof Error\n\t\t\t\t\t\t\t? rollbackError.message\n\t\t\t\t\t\t\t: String(rollbackError);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Original error: ${error instanceof Error ? error.message : String(error)}\\nRollback also failed: ${rollbackMsg}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Create scaffolding context\n\t *\n\t * @param cwd - Current working directory\n\t * @param config - Configuration\n\t * @param strategy - Strategy (used to create initial result)\n\t * @returns Initial context\n\t */\n\tprivate createContext(\n\t\tcwd: string,\n\t\tconfig: TConfig,\n\t\tstrategy: ScaffoldStrategy<TConfig, TResult>,\n\t): ScaffoldContext<TConfig, TResult> {\n\t\treturn {\n\t\t\tcwd,\n\t\t\tconfig,\n\t\t\tresult: strategy.createResult(),\n\t\t\tmetadata: {},\n\t\t};\n\t}\n}\n","/**\n * Registration Service\n *\n * Handles entity registration in src/index.ts\n * Shared logic for adding imports and registration calls\n */\n\nimport { readFile, writeFile } from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport { join } from \"node:path\";\n\n/**\n * Configuration for entity registration\n */\nexport interface RegistrationConfig {\n\t/** Entity type (tool, prompt, resource) */\n\tentityType: \"tool\" | \"prompt\" | \"resource\";\n\t/** Entity type plural (tools, prompts, resources) */\n\tentityTypePlural: \"tools\" | \"prompts\" | \"resources\";\n\t/** Directory path (e.g., \"./tools/\") */\n\tdirectory: string;\n\t/** Function name suffix (e.g., \"Tool\", \"Prompt\", \"Resource\") */\n\tfunctionSuffix: string;\n}\n\n/**\n * Service for managing entity registrations in index.ts\n */\nexport class RegistrationService {\n\tprivate static readonly ENTITY_ORDER = [\"tool\", \"prompt\", \"resource\"];\n\n\t/**\n\t * Register an entity in src/index.ts\n\t */\n\tasync registerEntity(\n\t\tcwd: string,\n\t\tname: string,\n\t\tcapitalizedName: string,\n\t\tconfig: RegistrationConfig,\n\t): Promise<void> {\n\t\tconst indexPath = join(cwd, \"src\", \"index.ts\");\n\n\t\tif (!existsSync(indexPath)) {\n\t\t\tthrow new Error(\"src/index.ts not found\");\n\t\t}\n\n\t\tconst content = await readFile(indexPath, \"utf-8\");\n\t\tconst functionName = `register${capitalizedName}${config.functionSuffix}`;\n\n\t\t// Check if already registered\n\t\tif (content.includes(functionName)) {\n\t\t\tconsole.warn(\n\t\t\t\t`  ⚠️  ${config.entityType.charAt(0).toUpperCase() + config.entityType.slice(1)} already registered in src/index.ts`,\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Detect if function needs env parameter by reading the tool file\n\t\tconst needsEnv = await this.functionNeedsEnv(\n\t\t\tcwd,\n\t\t\tname,\n\t\t\tfunctionName,\n\t\t\tconfig,\n\t\t);\n\n\t\t// Add import and registration call\n\t\tconst importStatement = `import { ${functionName} } from \"${config.directory}${name}.js\";`;\n\t\tconst registrationCall = needsEnv\n\t\t\t? `\\t\\t${functionName}(this.server, this.env);`\n\t\t\t: `\\t\\t${functionName}(this.server);`;\n\n\t\tlet updatedContent = this.addImport(content, importStatement, config);\n\t\tupdatedContent = this.addRegistrationCall(\n\t\t\tupdatedContent,\n\t\t\tregistrationCall,\n\t\t\tconfig,\n\t\t);\n\n\t\tawait writeFile(indexPath, updatedContent, \"utf-8\");\n\t}\n\n\t/**\n\t * Check if an entity is already registered\n\t */\n\tasync isRegistered(\n\t\tcwd: string,\n\t\tcapitalizedName: string,\n\t\tconfig: RegistrationConfig,\n\t): Promise<boolean> {\n\t\tconst indexPath = join(cwd, \"src\", \"index.ts\");\n\n\t\tif (!existsSync(indexPath)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst content = await readFile(indexPath, \"utf-8\");\n\t\tconst functionName = `register${capitalizedName}${config.functionSuffix}`;\n\n\t\treturn content.includes(functionName);\n\t}\n\n\t/**\n\t * Add import statement to the file\n\t */\n\tprivate addImport(\n\t\tcontent: string,\n\t\timportStatement: string,\n\t\tconfig: RegistrationConfig,\n\t): string {\n\t\tlet updatedContent = content;\n\t\tconst currentTypeRegex = this.getImportRegex(config.directory);\n\n\t\t// Try to add after imports of the same type\n\t\tconst currentTypeMatches = Array.from(content.matchAll(currentTypeRegex));\n\n\t\tif (currentTypeMatches.length > 0) {\n\t\t\tconst lastMatch = currentTypeMatches[currentTypeMatches.length - 1];\n\t\t\tconst insertPos = lastMatch.index! + lastMatch[0].length;\n\t\t\treturn (\n\t\t\t\tcontent.slice(0, insertPos) +\n\t\t\t\t`\\n${importStatement}` +\n\t\t\t\tcontent.slice(insertPos)\n\t\t\t);\n\t\t}\n\n\t\t// No imports of same type, try fallback types in order\n\t\tconst currentIndex = RegistrationService.ENTITY_ORDER.indexOf(\n\t\t\tconfig.entityType,\n\t\t);\n\n\t\t// Try to add after previous entity types\n\t\tfor (let i = currentIndex - 1; i >= 0; i--) {\n\t\t\tconst fallbackType = RegistrationService.ENTITY_ORDER[i];\n\t\t\tconst fallbackDir = `./${fallbackType}s/`;\n\t\t\tconst fallbackRegex = this.getImportRegex(fallbackDir);\n\t\t\tconst fallbackMatches = Array.from(content.matchAll(fallbackRegex));\n\n\t\t\tif (fallbackMatches.length > 0) {\n\t\t\t\tconst lastMatch = fallbackMatches[fallbackMatches.length - 1];\n\t\t\t\tconst insertPos = lastMatch.index! + lastMatch[0].length;\n\t\t\t\tconst comment = `\\n\\n// ${config.entityTypePlural.charAt(0).toUpperCase() + config.entityTypePlural.slice(1)}\\n`;\n\t\t\t\treturn (\n\t\t\t\t\tcontent.slice(0, insertPos) +\n\t\t\t\t\tcomment +\n\t\t\t\t\timportStatement +\n\t\t\t\t\tcontent.slice(insertPos)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Add after any imports\n\t\tconst lastImportMatch = content.match(\n\t\t\t/import\\s+[^;]+;(?=\\s*\\n\\s*(?:\\/\\*|\\/\\/|\\n|export|class))/g,\n\t\t);\n\n\t\tif (lastImportMatch) {\n\t\t\tconst lastImport = lastImportMatch[lastImportMatch.length - 1];\n\t\t\tconst insertPos = content.indexOf(lastImport) + lastImport.length;\n\t\t\tconst comment = `\\n\\n// ${config.entityTypePlural.charAt(0).toUpperCase() + config.entityTypePlural.slice(1)}\\n`;\n\t\t\treturn (\n\t\t\t\tcontent.slice(0, insertPos) +\n\t\t\t\tcomment +\n\t\t\t\timportStatement +\n\t\t\t\tcontent.slice(insertPos)\n\t\t\t);\n\t\t}\n\n\t\treturn updatedContent;\n\t}\n\n\t/**\n\t * Add registration call to init() method\n\t */\n\tprivate addRegistrationCall(\n\t\tcontent: string,\n\t\tregistrationCall: string,\n\t\tconfig: RegistrationConfig,\n\t): string {\n\t\tconst initMethodRegex = /async\\s+init\\(\\)\\s*\\{([^}]*)\\}/;\n\t\tconst initMatch = content.match(initMethodRegex);\n\n\t\tif (!initMatch) {\n\t\t\treturn content;\n\t\t}\n\n\t\tconst initBody = initMatch[1];\n\t\tconst currentTypePattern = `register\\\\w+${config.functionSuffix}\\\\(this\\\\.server\\\\);`;\n\t\tconst currentTypeRegex = new RegExp(`\\\\s+${currentTypePattern}`, \"g\");\n\t\tconst currentTypeMatches = initBody.match(currentTypeRegex);\n\n\t\t// Add after registrations of the same type\n\t\tif (currentTypeMatches) {\n\t\t\tconst lastCall = currentTypeMatches[currentTypeMatches.length - 1];\n\t\t\tconst insertPos =\n\t\t\t\tinitMatch.index! + initMatch[0].lastIndexOf(lastCall) + lastCall.length;\n\t\t\treturn (\n\t\t\t\tcontent.slice(0, insertPos) +\n\t\t\t\t`\\n${registrationCall}` +\n\t\t\t\tcontent.slice(insertPos)\n\t\t\t);\n\t\t}\n\n\t\t// Try fallback types in order\n\t\tconst currentIndex = RegistrationService.ENTITY_ORDER.indexOf(\n\t\t\tconfig.entityType,\n\t\t);\n\n\t\tfor (let i = currentIndex - 1; i >= 0; i--) {\n\t\t\tconst fallbackType = RegistrationService.ENTITY_ORDER[i];\n\t\t\tconst fallbackSuffix =\n\t\t\t\tfallbackType.charAt(0).toUpperCase() + fallbackType.slice(1);\n\t\t\tconst fallbackPattern = `register\\\\w+${fallbackSuffix}\\\\(this\\\\.server\\\\);`;\n\t\t\tconst fallbackRegex = new RegExp(`\\\\s+${fallbackPattern}`, \"g\");\n\t\t\tconst fallbackMatches = initBody.match(fallbackRegex);\n\n\t\t\tif (fallbackMatches) {\n\t\t\t\tconst lastCall = fallbackMatches[fallbackMatches.length - 1];\n\t\t\t\tconst insertPos =\n\t\t\t\t\tinitMatch.index! +\n\t\t\t\t\tinitMatch[0].lastIndexOf(lastCall) +\n\t\t\t\t\tlastCall.length;\n\t\t\t\tconst comment = `\\n\\n\\t\\t// Register all ${config.entityTypePlural}\\n`;\n\t\t\t\treturn (\n\t\t\t\t\tcontent.slice(0, insertPos) +\n\t\t\t\t\tcomment +\n\t\t\t\t\tregistrationCall +\n\t\t\t\t\tcontent.slice(insertPos)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Add at start of init method\n\t\tconst insertPos = initMatch.index! + initMatch[0].indexOf(\"{\") + 1;\n\t\tconst comment = `\\n\\t\\t// Register all ${config.entityTypePlural}\\n`;\n\t\treturn (\n\t\t\tcontent.slice(0, insertPos) +\n\t\t\tcomment +\n\t\t\tregistrationCall +\n\t\t\tcontent.slice(insertPos)\n\t\t);\n\t}\n\n\t/**\n\t * Get import regex pattern for a directory\n\t */\n\tprivate getImportRegex(directory: string): RegExp {\n\t\t// Escape special regex characters in directory\n\t\tconst escapedDir = directory.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n\t\treturn new RegExp(\n\t\t\t`import\\\\s+\\\\{[^}]+\\\\}\\\\s+from\\\\s+[\"']${escapedDir}[^\"']+[\"'];`,\n\t\t\t\"g\",\n\t\t);\n\t}\n\n\t/**\n\t * Detect if a registration function needs the env parameter\n\t * Reads the entity file and checks the function signature\n\t */\n\tprivate async functionNeedsEnv(\n\t\tcwd: string,\n\t\tname: string,\n\t\tfunctionName: string,\n\t\tconfig: RegistrationConfig,\n\t): Promise<boolean> {\n\t\ttry {\n\t\t\tconst entityPath = join(\n\t\t\t\tcwd,\n\t\t\t\t\"src\",\n\t\t\t\tconfig.entityTypePlural,\n\t\t\t\t`${name}.ts`,\n\t\t\t);\n\n\t\t\tif (!existsSync(entityPath)) {\n\t\t\t\treturn false; // File doesn't exist, assume no env needed\n\t\t\t}\n\n\t\t\tconst entityContent = await readFile(entityPath, \"utf-8\");\n\n\t\t\t// Look for the function declaration\n\t\t\t// Pattern: export function functionName(server: McpServer, env?: Env)\n\t\t\t// OR: export function functionName(server: McpServer, env: Env)\n\t\t\tconst functionPattern = new RegExp(\n\t\t\t\t`export\\\\s+function\\\\s+${functionName}\\\\s*\\\\([^)]*env[^)]*\\\\)`,\n\t\t\t\t\"i\",\n\t\t\t);\n\n\t\t\treturn functionPattern.test(entityContent);\n\t\t} catch (error) {\n\t\t\t// If we can't read the file, assume no env needed\n\t\t\treturn false;\n\t\t}\n\t}\n}\n","/**\n * Validation Service\n *\n * Handles entity validation for add commands\n * Shared logic for validating names, projects, and options\n */\n\nimport { existsSync } from \"node:fs\";\nimport { join } from \"node:path\";\n\n/**\n * Configuration for entity validation\n */\nexport interface ValidationConfig {\n\t/** Entity type (tool, prompt, resource) */\n\tentityType: \"tool\" | \"prompt\" | \"resource\";\n\t/** Directory where entity file will be created */\n\tsourceDir: string;\n}\n\n/**\n * Options for resource-specific validation\n */\nexport interface ResourceOptions {\n\tstatic?: boolean;\n\tdynamic?: boolean;\n\turiPattern?: string;\n}\n\n/**\n * Service for validating entity creation\n */\nexport class ValidationService {\n\t/**\n\t * Validate entity name format\n\t *\n\t * Names must:\n\t * - Start with a lowercase letter\n\t * - Contain only lowercase letters, numbers, and hyphens\n\t * - Follow kebab-case convention\n\t *\n\t * @throws Error if name is invalid\n\t */\n\tvalidateName(name: string, config: ValidationConfig): void {\n\t\tconst nameRegex = /^[a-z][a-z0-9-]*$/;\n\n\t\tif (!nameRegex.test(name)) {\n\t\t\tconst entityName =\n\t\t\t\tconfig.entityType.charAt(0).toUpperCase() + config.entityType.slice(1);\n\t\t\tthrow new Error(\n\t\t\t\t`${entityName} name must be lowercase with hyphens (e.g., my-${config.entityType})`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Validate we're in a valid MCP project\n\t *\n\t * @throws Error if not in a valid project\n\t */\n\tvalidateProject(cwd: string): void {\n\t\tconst packageJsonPath = join(cwd, \"package.json\");\n\n\t\tif (!existsSync(packageJsonPath)) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Not in a valid project directory (no package.json found)\",\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Check if entity file already exists\n\t *\n\t * @throws Error if entity file already exists\n\t */\n\tvalidateFileNotExists(cwd: string, name: string, config: ValidationConfig): void {\n\t\tconst filePath = join(cwd, config.sourceDir, `${name}.ts`);\n\n\t\tif (existsSync(filePath)) {\n\t\t\tconst entityName =\n\t\t\t\tconfig.entityType.charAt(0).toUpperCase() + config.entityType.slice(1);\n\t\t\tthrow new Error(`${entityName} already exists: ${filePath}`);\n\t\t}\n\t}\n\n\t/**\n\t * Validate all basic requirements for entity creation\n\t *\n\t * @throws Error if any validation fails\n\t */\n\tvalidateEntity(cwd: string, name: string, config: ValidationConfig): void {\n\t\tthis.validateName(name, config);\n\t\tthis.validateProject(cwd);\n\t\tthis.validateFileNotExists(cwd, name, config);\n\t}\n\n\t/**\n\t * Validate resource-specific options\n\t *\n\t * @throws Error if options are invalid\n\t */\n\tvalidateResourceOptions(options: ResourceOptions): void {\n\t\tif (options.static && options.dynamic) {\n\t\t\tthrow new Error(\"Cannot use both --static and --dynamic flags\");\n\t\t}\n\t}\n\n\t/**\n\t * Determine URI pattern for a resource\n\t *\n\t * - If uriPattern is explicitly provided, use it\n\t * - If --dynamic flag is set, use dynamic pattern (resource://{id})\n\t * - Otherwise, default to static pattern (config://name)\n\t */\n\tdetermineUriPattern(\n\t\tname: string,\n\t\toptions: ResourceOptions,\n\t): string {\n\t\tif (options.uriPattern) {\n\t\t\treturn options.uriPattern;\n\t\t}\n\n\t\tif (options.dynamic) {\n\t\t\t// Explicit dynamic pattern\n\t\t\treturn \"resource://{id}\";\n\t\t}\n\n\t\t// Default to static pattern (simpler, more common)\n\t\treturn `config://${name}`;\n\t}\n}\n","/**\n * Template Service\n *\n * Handles file content generation from templates\n * Shared logic for generating entity files, unit tests, and integration tests\n */\n\nimport Handlebars from \"handlebars\";\nimport { readFileSync, statSync } from \"node:fs\";\nimport { join, dirname } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\n\n/**\n * Binding context for template generation\n */\nexport interface BindingContext {\n\t/** Whether the project has any bindings configured */\n\thasBindings: boolean;\n\t/** Compact binding summary (e.g., \"KV: MY_CACHE | D1: USER_DB | AI: AI\") */\n\tbindingSummary?: string;\n\t/** Array of binding examples with imports and usage */\n\tbindingExamples?: Array<{\n\t\ttype: string;\n\t\tbindingName: string;\n\t\thelperClass?: string; // Optional for AI (no helper class)\n\t\timportStatement?: string; // Optional for AI (no import needed)\n\t\tusageExample: string;\n\t}>;\n}\n\n/**\n * Configuration for template generation\n */\nexport interface TemplateConfig {\n\t/** Entity type (tool, prompt, resource) */\n\tentityType: \"tool\" | \"prompt\" | \"resource\";\n\t/** Entity name in kebab-case */\n\tname: string;\n\t/** Entity name in PascalCase */\n\tcapitalizedName: string;\n\t/** Description of the entity */\n\tdescription: string;\n\t/** Binding context (optional - only for tools that may use bindings) */\n\tbindingContext?: BindingContext;\n}\n\n/**\n * Resource-specific template options\n */\nexport interface ResourceTemplateOptions extends TemplateConfig {\n\t/** URI pattern for the resource */\n\turiPattern: string;\n}\n\n/**\n * Service for generating entity file content from templates\n */\nexport class TemplateService {\n\tprivate templateCache = new Map<string, HandlebarsTemplateDelegate>();\n\tprivate templatesDir: string;\n\n\tconstructor() {\n\t\t// Get the project root directory (where templates/ folder is)\n\t\tconst __filename = fileURLToPath(import.meta.url);\n\t\tconst __dirname = dirname(__filename);\n\n\t\t// Find templates directory by searching upward from current file\n\t\t// Works from both dist/cli.js and dist/core/commands/shared/\n\t\tlet currentDir = __dirname;\n\t\tlet templatesPath = \"\";\n\n\t\t// Search up to 5 levels for templates/scaffolding\n\t\tfor (let i = 0; i < 5; i++) {\n\t\t\tconst candidatePath = join(currentDir, \"templates/scaffolding\");\n\t\t\ttry {\n\t\t\t\t// Check if directory exists (sync is ok in constructor)\n\t\t\t\tif (statSync(candidatePath).isDirectory()) {\n\t\t\t\t\ttemplatesPath = candidatePath;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Directory doesn't exist, try parent\n\t\t\t}\n\t\t\tcurrentDir = dirname(currentDir);\n\t\t}\n\n\t\tif (!templatesPath) {\n\t\t\tthrow new Error(\n\t\t\t\t`Could not locate templates/scaffolding directory. Searched from: ${__dirname}`,\n\t\t\t);\n\t\t}\n\n\t\tthis.templatesDir = templatesPath;\n\t}\n\n\t/**\n\t * Load and compile a Handlebars template\n\t */\n\tprivate loadTemplate(templatePath: string): HandlebarsTemplateDelegate {\n\t\t// Check cache first\n\t\tif (this.templateCache.has(templatePath)) {\n\t\t\treturn this.templateCache.get(templatePath)!;\n\t\t}\n\n\t\t// Load template from file\n\t\tconst fullPath = join(this.templatesDir, templatePath);\n\t\tconst templateContent = readFileSync(fullPath, \"utf-8\");\n\n\t\t// Compile template\n\t\tconst compiled = Handlebars.compile(templateContent, { noEscape: true });\n\n\t\t// Cache it\n\t\tthis.templateCache.set(templatePath, compiled);\n\n\t\treturn compiled;\n\t}\n\n\t/**\n\t * Generate tool file content\n\t */\n\tgenerateToolFile(config: TemplateConfig): string {\n\t\tconst template = this.loadTemplate(\"entities/tool.hbs\");\n\t\t// Pass full config including bindingContext\n\t\treturn template(config);\n\t}\n\n\t/**\n\t * Generate prompt file content\n\t */\n\tgeneratePromptFile(config: TemplateConfig): string {\n\t\tconst template = this.loadTemplate(\"entities/prompt.hbs\");\n\t\treturn template(config);\n\t}\n\n\t/**\n\t * Generate resource file content\n\t */\n\tgenerateResourceFile(config: ResourceTemplateOptions): string {\n\t\tconst { uriPattern } = config;\n\n\t\t// Check if URI pattern has variables\n\t\tconst hasVariables = uriPattern.includes(\"{\") && uriPattern.includes(\"}\");\n\n\t\t// Extract variable names from pattern\n\t\tconst variables = hasVariables\n\t\t\t? Array.from(uriPattern.matchAll(/\\{(\\w+)\\}/g)).map((m) => m[1])\n\t\t\t: [];\n\n\t\t// Prepare template context\n\t\tconst context = {\n\t\t\t...config,\n\t\t\thasVariables,\n\t\t\tvariables,\n\t\t\tvariablesJoined: variables.join(\", \"),\n\t\t};\n\n\t\tconst template = this.loadTemplate(\"entities/resource.hbs\");\n\t\treturn template(context);\n\t}\n\n\t/**\n\t * Generate entity file content based on entity type\n\t */\n\tgenerateEntityFile(\n\t\tconfig: TemplateConfig | ResourceTemplateOptions,\n\t): string {\n\t\tswitch (config.entityType) {\n\t\t\tcase \"tool\":\n\t\t\t\treturn this.generateToolFile(config);\n\t\t\tcase \"prompt\":\n\t\t\t\treturn this.generatePromptFile(config);\n\t\t\tcase \"resource\":\n\t\t\t\tif (!(\"uriPattern\" in config)) {\n\t\t\t\t\tthrow new Error(\"Resource template config must include uriPattern\");\n\t\t\t\t}\n\t\t\t\treturn this.generateResourceFile(config);\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown entity type: ${(config as TemplateConfig).entityType}`);\n\t\t}\n\t}\n\n\t/**\n\t * Generate unit test file content\n\t */\n\tgenerateUnitTestFile(config: TemplateConfig): string {\n\t\tconst { entityType, name, capitalizedName } = config;\n\t\tconst entityTypePlural = `${entityType}s`;\n\t\tconst functionSuffix =\n\t\t\tentityType.charAt(0).toUpperCase() + entityType.slice(1);\n\n\t\t// Prepare template context\n\t\tconst context = {\n\t\t\t...config,\n\t\t\tentityTypePlural,\n\t\t\tfunctionSuffix,\n\t\t\tisToolType: entityType === \"tool\",\n\t\t\tisPromptType: entityType === \"prompt\",\n\t\t\tisResourceType: entityType === \"resource\",\n\t\t};\n\n\t\tconst template = this.loadTemplate(\"unit-tests/main.hbs\");\n\t\treturn template(context);\n\t}\n\n\t/**\n\t * Generate integration test YAML content\n\t */\n\tgenerateIntegrationTestYaml(config: TemplateConfig | ResourceTemplateOptions): string {\n\t\tconst { entityType, name, description } = config;\n\n\t\tif (entityType === \"tool\") {\n\t\t\treturn this.generateToolIntegrationYaml(name, description);\n\t\t} else if (entityType === \"prompt\") {\n\t\t\treturn this.generatePromptIntegrationYaml(name, description);\n\t\t} else if (entityType === \"resource\") {\n\t\t\tconst uriPattern = (config as ResourceTemplateOptions).uriPattern;\n\t\t\treturn this.generateResourceIntegrationYaml(name, description, uriPattern);\n\t\t}\n\n\t\tthrow new Error(`Unknown entity type: ${entityType}`);\n\t}\n\n\t/**\n\t * Generate tool integration test YAML\n\t */\n\tprivate generateToolIntegrationYaml(name: string, description: string): string {\n\t\tconst context = {\n\t\t\tname,\n\t\t\tnameWithSpaces: name.replace(/_/g, \" \"),\n\t\t\tdescription: description || `Verify that ${name} tool works correctly`,\n\t\t};\n\n\t\tconst template = this.loadTemplate(\"integration-tests/tool.yaml.hbs\");\n\t\treturn template(context);\n\t}\n\n\t/**\n\t * Generate prompt integration test YAML\n\t */\n\tprivate generatePromptIntegrationYaml(\n\t\tname: string,\n\t\tdescription: string,\n\t): string {\n\t\tconst context = {\n\t\t\tname,\n\t\t\tnameWithSpaces: name.replace(/_/g, \" \"),\n\t\t\tdescription: description || `Verify that ${name} prompt works correctly`,\n\t\t};\n\n\t\tconst template = this.loadTemplate(\"integration-tests/prompt.yaml.hbs\");\n\t\treturn template(context);\n\t}\n\n\t/**\n\t * Generate resource integration test YAML\n\t */\n\tprivate generateResourceIntegrationYaml(\n\t\tname: string,\n\t\tdescription: string,\n\t\turiPattern: string,\n\t): string {\n\t\tconst context = {\n\t\t\tname,\n\t\t\tnameWithSpaces: name.replace(/_/g, \" \"),\n\t\t\tdescription: description || \"Test resource\",\n\t\t\turiPattern,\n\t\t\turiPatternNoVars: uriPattern.replace(/\\{[^}]+\\}/g, \"\"),\n\t\t};\n\n\t\tconst template = this.loadTemplate(\"integration-tests/resource.yaml.hbs\");\n\t\treturn template(context);\n\t}\n}\n","/**\n * Wrangler Configuration Utilities\n *\n * Shared utilities for reading and writing wrangler configuration files.\n * Supports both TOML and JSONC formats.\n */\n\nimport { existsSync } from \"node:fs\";\nimport { join } from \"node:path\";\nimport stripJsonComments from \"strip-json-comments\";\n\n/**\n * Detect which wrangler config file exists\n * Prioritizes: wrangler.jsonc > wrangler.json > wrangler.toml\n */\nexport function getWranglerConfigPath(cwd: string): string | null {\n\tconst configFiles = [\"wrangler.jsonc\", \"wrangler.json\", \"wrangler.toml\"];\n\tfor (const file of configFiles) {\n\t\tconst path = join(cwd, file);\n\t\tif (existsSync(path)) {\n\t\t\treturn path;\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Parse JSONC (JSON with comments)\n */\nexport function parseJSONC(content: string): any {\n\tconst stripped = stripJsonComments(content);\n\treturn JSON.parse(stripped);\n}\n\n/**\n * Format JSON with proper indentation (tabs)\n */\nexport function formatJSON(obj: any): string {\n\treturn JSON.stringify(obj, null, \"\\t\");\n}\n","/**\n * Shared Utility Functions\n *\n * Common utilities used across multiple commands.\n * All functions are pure and have no side effects.\n */\n\nimport { access } from \"node:fs/promises\";\n\n/**\n * Convert kebab-case to PascalCase\n *\n * @param str - String in kebab-case format\n * @returns String in PascalCase format\n *\n * @example\n * toPascalCase(\"my-tool-name\") → \"MyToolName\"\n * toPascalCase(\"api-client\") → \"ApiClient\"\n */\nexport function toPascalCase(str: string): string {\n\treturn str\n\t\t.split(\"-\")\n\t\t.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n\t\t.join(\"\");\n}\n\n/**\n * Convert PascalCase to kebab-case\n *\n * @param str - String in PascalCase format\n * @returns String in kebab-case format\n *\n * @example\n * toKebabCase(\"MyToolName\") → \"my-tool-name\"\n * toKebabCase(\"APIClient\") → \"api-client\"\n */\nexport function toKebabCase(str: string): string {\n\treturn str\n\t\t.replace(/([A-Z])/g, \"-$1\")\n\t\t.toLowerCase()\n\t\t.replace(/^-/, \"\");\n}\n\n/**\n * Check if a file exists\n *\n * @param filePath - Path to check\n * @returns true if file exists, false otherwise\n *\n * @example\n * await fileExists(\"/path/to/file.ts\") → true\n * await fileExists(\"/non/existent.ts\") → false\n */\nexport async function fileExists(filePath: string): Promise<boolean> {\n\ttry {\n\t\tawait access(filePath);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Capitalize first letter of a string\n *\n * @param str - String to capitalize\n * @returns String with first letter capitalized\n *\n * @example\n * capitalize(\"hello\") → \"Hello\"\n * capitalize(\"world\") → \"World\"\n */\nexport function capitalize(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n","/**\n * Binding Detection Service\n *\n * Detects Cloudflare bindings (KV, D1, R2, AI) configured in wrangler.jsonc.\n * Used by tool scaffolding to generate context-aware templates with binding usage examples.\n */\n\nimport { existsSync } from \"node:fs\";\nimport { readFile } from \"node:fs/promises\";\nimport type { Phase1BindingType, Phase2BindingType } from \"@/types/binding-types.js\";\nimport { getWranglerConfigPath, parseJSONC } from \"./config/wrangler-utils.js\";\nimport { toPascalCase } from \"./utils.js\";\n\n/**\n * Detected bindings organized by type\n */\nexport interface DetectedBindings {\n\tkv: string[]; // e.g., ['MY_CACHE', 'SESSION_STORE']\n\td1: string[]; // e.g., ['USER_DB', 'ANALYTICS_DB']\n\tr2: string[]; // e.g., ['MY_BUCKET', 'UPLOADS']\n\tai?: string; // e.g., 'AI' (singleton binding)\n}\n\n/**\n * Binding usage example with import and usage code\n */\nexport interface BindingExample {\n\ttype: Phase1BindingType | Phase2BindingType;\n\tbindingName: string;\n\thelperClass?: string; // Optional for AI (no helper class)\n\timportStatement?: string; // Optional for AI (no import needed)\n\tusageExample: string;\n}\n\n/**\n * Service for detecting configured Cloudflare bindings\n */\nexport class BindingDetectionService {\n\t/**\n\t * Detect all bindings configured in wrangler.jsonc\n\t *\n\t * @param cwd - Project root directory\n\t * @returns Detected bindings organized by type\n\t */\n\tasync detectBindings(cwd: string): Promise<DetectedBindings> {\n\t\tconst bindings: DetectedBindings = {\n\t\t\tkv: [],\n\t\t\td1: [],\n\t\t\tr2: [],\n\t\t};\n\n\t\tconst wranglerPath = getWranglerConfigPath(cwd);\n\t\tif (!wranglerPath || !existsSync(wranglerPath)) {\n\t\t\treturn bindings; // No wrangler config = no bindings\n\t\t}\n\n\t\ttry {\n\t\t\tconst content = await readFile(wranglerPath, \"utf-8\");\n\t\t\tconst config = parseJSONC(content);\n\n\t\t\t// Detect KV namespaces\n\t\t\tif (Array.isArray(config.kv_namespaces)) {\n\t\t\t\tbindings.kv = config.kv_namespaces\n\t\t\t\t\t.map((ns: any) => ns.binding)\n\t\t\t\t\t.filter((b: any) => typeof b === \"string\" && b.length > 0);\n\t\t\t}\n\n\t\t\t// Detect D1 databases\n\t\t\tif (Array.isArray(config.d1_databases)) {\n\t\t\t\tbindings.d1 = config.d1_databases\n\t\t\t\t\t.map((db: any) => db.binding)\n\t\t\t\t\t.filter((b: any) => typeof b === \"string\" && b.length > 0);\n\t\t\t}\n\n\t\t\t// Detect R2 buckets\n\t\t\tif (Array.isArray(config.r2_buckets)) {\n\t\t\t\tbindings.r2 = config.r2_buckets\n\t\t\t\t\t.map((bucket: any) => bucket.binding)\n\t\t\t\t\t.filter((b: any) => typeof b === \"string\" && b.length > 0);\n\t\t\t}\n\n\t\t\t// Detect AI binding (singleton)\n\t\t\tif (config.ai && typeof config.ai.binding === \"string\" && config.ai.binding.length > 0) {\n\t\t\t\tbindings.ai = config.ai.binding;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Graceful fallback: If parsing fails, return empty bindings\n\t\t\t// Don't throw - we don't want to break tool scaffolding\n\t\t\tconsole.warn(\n\t\t\t\t`Warning: Could not parse wrangler config: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t);\n\t\t}\n\n\t\treturn bindings;\n\t}\n\n\t/**\n\t * Check if project has any bindings configured\n\t *\n\t * @param cwd - Project root directory\n\t * @returns True if at least one binding is configured\n\t */\n\tasync hasAnyBindings(cwd: string): Promise<boolean> {\n\t\tconst bindings = await this.detectBindings(cwd);\n\t\treturn (\n\t\t\tbindings.kv.length > 0 ||\n\t\t\tbindings.d1.length > 0 ||\n\t\t\tbindings.r2.length > 0 ||\n\t\t\t!!bindings.ai\n\t\t);\n\t}\n\n\t/**\n\t * Generate binding usage examples for template comments\n\t *\n\t * @param bindings - Detected bindings\n\t * @returns Array of binding examples with imports and usage\n\t */\n\tgenerateBindingExamples(bindings: DetectedBindings): BindingExample[] {\n\t\tconst examples: BindingExample[] = [];\n\n\t\t// Generate KV examples\n\t\tfor (const bindingName of bindings.kv) {\n\t\t\tconst helperClass = this.getHelperClassName(bindingName, \"kv\");\n\t\t\tconst helperFile = this.getHelperFileName(bindingName, \"kv\");\n\n\t\t\texamples.push({\n\t\t\t\ttype: \"kv\",\n\t\t\t\tbindingName,\n\t\t\t\thelperClass,\n\t\t\t\timportStatement: `import { ${helperClass} } from \"../utils/bindings/${helperFile}.js\";`,\n\t\t\t\tusageExample: [\n\t\t\t\t\t`const cache = new ${helperClass}(env.${bindingName});`,\n\t\t\t\t\t`const data = await cache.get<MyType>('key');`,\n\t\t\t\t\t`await cache.set('key', { value: 'data' }, { expirationTtl: 3600 });`,\n\t\t\t\t].join(\"\\n// \"),\n\t\t\t});\n\t\t}\n\n\t\t// Generate D1 examples\n\t\tfor (const bindingName of bindings.d1) {\n\t\t\tconst helperClass = this.getHelperClassName(bindingName, \"d1\");\n\t\t\tconst helperFile = this.getHelperFileName(bindingName, \"d1\");\n\n\t\t\texamples.push({\n\t\t\t\ttype: \"d1\",\n\t\t\t\tbindingName,\n\t\t\t\thelperClass,\n\t\t\t\timportStatement: `import { ${helperClass} } from \"../utils/bindings/${helperFile}.js\";`,\n\t\t\t\tusageExample: [\n\t\t\t\t\t`const db = new ${helperClass}(env.${bindingName});`,\n\t\t\t\t\t`const users = await db.query<User>('SELECT * FROM users WHERE active = ?', [true]);`,\n\t\t\t\t\t`await db.execute('INSERT INTO logs (message) VALUES (?)', ['User logged in']);`,\n\t\t\t\t].join(\"\\n// \"),\n\t\t\t});\n\t\t}\n\n\t\t// Generate R2 examples\n\t\tfor (const bindingName of bindings.r2) {\n\t\t\tconst helperClass = this.getHelperClassName(bindingName, \"r2\");\n\t\t\tconst helperFile = this.getHelperFileName(bindingName, \"r2\");\n\n\t\t\texamples.push({\n\t\t\t\ttype: \"r2\",\n\t\t\t\tbindingName,\n\t\t\t\thelperClass,\n\t\t\t\timportStatement: `import { ${helperClass} } from \"../utils/bindings/${helperFile}.js\";`,\n\t\t\t\tusageExample: [\n\t\t\t\t\t`const bucket = new ${helperClass}(env.${bindingName});`,\n\t\t\t\t\t`await bucket.putText('files/readme.txt', 'Hello World');`,\n\t\t\t\t\t`const content = await bucket.getText('files/readme.txt');`,\n\t\t\t\t].join(\"\\n// \"),\n\t\t\t});\n\t\t}\n\n\t\t// Generate AI examples (no helper class - direct binding usage)\n\t\tif (bindings.ai) {\n\t\t\texamples.push({\n\t\t\t\ttype: \"ai\",\n\t\t\t\tbindingName: bindings.ai,\n\t\t\t\tusageExample: [\n\t\t\t\t\t`// RAG with LLM:`,\n\t\t\t\t\t`const ragResult = await env.${bindings.ai}.aiSearch('my-instance', 'query text');`,\n\t\t\t\t\t``,\n\t\t\t\t\t`// Vector-only search:`,\n\t\t\t\t\t`const searchResult = await env.${bindings.ai}.search('my-instance', 'query text');`,\n\t\t\t\t].join(\"\\n// \"),\n\t\t\t});\n\t\t}\n\n\t\treturn examples;\n\t}\n\n\t/**\n\t * Generate compact binding summary for template comments\n\t * Format: \"KV: MY_CACHE, SESSION_STORE | D1: USER_DB | R2: UPLOADS | AI: AI\"\n\t *\n\t * @param bindings - Detected bindings\n\t * @returns Compact summary string\n\t */\n\tgenerateBindingSummary(bindings: DetectedBindings): string {\n\t\tconst parts: string[] = [];\n\n\t\tif (bindings.kv.length > 0) {\n\t\t\tparts.push(`KV: ${bindings.kv.join(\", \")}`);\n\t\t}\n\t\tif (bindings.d1.length > 0) {\n\t\t\tparts.push(`D1: ${bindings.d1.join(\", \")}`);\n\t\t}\n\t\tif (bindings.r2.length > 0) {\n\t\t\tparts.push(`R2: ${bindings.r2.join(\", \")}`);\n\t\t}\n\t\tif (bindings.ai) {\n\t\t\tparts.push(`AI: ${bindings.ai}`);\n\t\t}\n\n\t\treturn parts.join(\" | \");\n\t}\n\n\t/**\n\t * Get helper class name for a binding\n\t * Example: MY_CACHE (kv) -> MyCacheKV\n\t */\n\tprivate getHelperClassName(\n\t\tbindingName: string,\n\t\tbindingType: Phase1BindingType,\n\t): string {\n\t\tconst baseName = toPascalCase(bindingName.toLowerCase().replace(/_/g, \"-\"));\n\t\tconst suffix = bindingType.toUpperCase();\n\t\treturn `${baseName}${suffix}`;\n\t}\n\n\t/**\n\t * Get helper file name for a binding\n\t * Example: MY_CACHE (kv) -> kv-my-cache\n\t */\n\tprivate getHelperFileName(\n\t\tbindingName: string,\n\t\tbindingType: Phase1BindingType,\n\t): string {\n\t\tconst fileName = bindingName.toLowerCase().replace(/_/g, \"-\");\n\t\treturn `${bindingType}-${fileName}`;\n\t}\n}\n","/**\n * Template Metadata Management\n *\n * Functions for reading and updating .mcp-template.json\n */\n\nimport { readFile, writeFile } from \"node:fs/promises\";\nimport { join } from \"node:path\";\nimport { existsSync } from \"node:fs\";\n\n/**\n * Entity metadata structure\n */\nexport interface EntityMetadata {\n\tname: string;\n\tfile: string;\n\tregistered: boolean;\n\thasUnitTest: boolean;\n\thasIntegrationTest: boolean;\n}\n\n/**\n * Supported entity types\n */\nexport type EntityType = \"tools\" | \"prompts\" | \"resources\";\n\n/**\n * Update .mcp-template.json with new entity metadata\n *\n * @param cwd - Current working directory\n * @param entityType - Type of entity (tools, prompts, resources)\n * @param name - Entity name (kebab-case)\n * @param fileSubpath - Path to entity file relative to project root (e.g., \"src/tools/my-tool.ts\")\n * @param hasTests - Whether tests were generated\n *\n * @example\n * await updateTemplateMetadata(\n *   process.cwd(),\n *   \"tools\",\n *   \"my-tool\",\n *   \"src/tools/my-tool.ts\",\n *   true\n * );\n */\nexport async function updateTemplateMetadata(\n\tcwd: string,\n\tentityType: EntityType,\n\tname: string,\n\tfileSubpath: string,\n\thasTests: boolean,\n): Promise<void> {\n\tconst metadataPath = join(cwd, \".mcp-template.json\");\n\n\tif (!existsSync(metadataPath)) {\n\t\treturn; // Optional file\n\t}\n\n\ttry {\n\t\tconst content = await readFile(metadataPath, \"utf-8\");\n\t\tconst metadata = JSON.parse(content);\n\n\t\t// Initialize array if it doesn't exist\n\t\tif (!metadata[entityType]) {\n\t\t\tmetadata[entityType] = [];\n\t\t}\n\n\t\t// Add new entity\n\t\tconst entityMetadata: EntityMetadata = {\n\t\t\tname,\n\t\t\tfile: fileSubpath,\n\t\t\tregistered: true,\n\t\t\thasUnitTest: hasTests,\n\t\t\thasIntegrationTest: hasTests,\n\t\t};\n\n\t\tmetadata[entityType].push(entityMetadata);\n\n\t\tawait writeFile(metadataPath, JSON.stringify(metadata, null, \"\\t\"), \"utf-8\");\n\t} catch (error) {\n\t\tconsole.warn(`  ⚠️  Could not update .mcp-template.json: ${error}`);\n\t}\n}\n\n/**\n * Read template metadata from .mcp-template.json\n *\n * @param cwd - Current working directory\n * @returns Parsed metadata or null if file doesn't exist\n *\n * @example\n * const metadata = await readTemplateMetadata(process.cwd());\n * if (metadata) {\n *   console.log(metadata.tools);\n * }\n */\nexport async function readTemplateMetadata(\n\tcwd: string,\n): Promise<Record<string, unknown> | null> {\n\tconst metadataPath = join(cwd, \".mcp-template.json\");\n\n\tif (!existsSync(metadataPath)) {\n\t\treturn null;\n\t}\n\n\ttry {\n\t\tconst content = await readFile(metadataPath, \"utf-8\");\n\t\treturn JSON.parse(content);\n\t} catch (error) {\n\t\tconsole.warn(`  ⚠️  Could not read .mcp-template.json: ${error}`);\n\t\treturn null;\n\t}\n}\n","/**\n * Zod Schemas for Configuration Validation\n *\n * Provides runtime validation and type safety for all service configurations\n */\n\nimport { z } from \"zod\";\n\n/**\n * Schema for resource-specific options\n */\nexport const ResourceOptionsSchema = z.object({\n\t/** URI pattern for the resource */\n\turiPattern: z.string().optional(),\n\t/** Whether this is a static resource */\n\tstatic: z.boolean().optional(),\n\t/** Whether this is a dynamic resource with variables */\n\tdynamic: z.boolean().optional(),\n});\n\nexport type ResourceOptions = z.infer<typeof ResourceOptionsSchema>;\n\n/**\n * Schema for entity scaffolding configuration\n */\nexport const ScaffoldConfigSchema = z.object({\n\t/** Entity type (tool, prompt, resource) */\n\tentityType: z.enum([\"tool\", \"prompt\", \"resource\"]),\n\t/** Entity name in kebab-case */\n\tname: z.string().regex(/^[a-z][a-z0-9-]*$/, {\n\t\tmessage: \"Entity name must be lowercase with hyphens (e.g., my-entity)\",\n\t}),\n\t/** Description of the entity */\n\tdescription: z.string().optional(),\n\t/** Whether to generate test files (default: true) */\n\tgenerateTests: z.boolean().optional().default(true),\n\t/** Whether to auto-register in index.ts (default: true) */\n\tautoRegister: z.boolean().optional().default(true),\n\t/** Resource-specific options (required for resources) */\n\tresourceOptions: ResourceOptionsSchema.optional(),\n}).refine(\n\t(data) => {\n\t\t// If entity type is resource, resourceOptions must be provided\n\t\tif (data.entityType === \"resource\" && !data.resourceOptions) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\t{\n\t\tmessage: \"Resource options are required when entityType is 'resource'\",\n\t\tpath: [\"resourceOptions\"],\n\t}\n).refine(\n\t(data) => {\n\t\t// Cannot have both static and dynamic flags set\n\t\tif (data.resourceOptions?.static && data.resourceOptions?.dynamic) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\t{\n\t\tmessage: \"Cannot use both --static and --dynamic flags\",\n\t\tpath: [\"resourceOptions\"],\n\t}\n);\n\n// Input type (before validation/defaults applied)\nexport type ScaffoldConfig = z.input<typeof ScaffoldConfigSchema>;\n\n// Output type (after validation/defaults applied)\nexport type ValidatedScaffoldConfig = z.output<typeof ScaffoldConfigSchema>;\n\n/**\n * Schema for registration service configuration\n */\nexport const RegistrationConfigSchema = z.object({\n\t/** Entity type */\n\tentityType: z.enum([\"tool\", \"prompt\", \"resource\"]),\n\t/** Entity type plural form */\n\tentityTypePlural: z.enum([\"tools\", \"prompts\", \"resources\"]),\n\t/** Import directory path */\n\tdirectory: z.string(),\n\t/** Function name suffix */\n\tfunctionSuffix: z.string(),\n});\n\nexport type RegistrationConfig = z.infer<typeof RegistrationConfigSchema>;\n\n/**\n * Schema for validation service configuration\n */\nexport const ValidationConfigSchema = z.object({\n\t/** Entity type */\n\tentityType: z.enum([\"tool\", \"prompt\", \"resource\"]),\n\t/** Directory where entity file will be created */\n\tsourceDir: z.string(),\n});\n\nexport type ValidationConfig = z.infer<typeof ValidationConfigSchema>;\n\n/**\n * Schema for template configuration\n */\nexport const TemplateConfigSchema = z.object({\n\t/** Entity type */\n\tentityType: z.enum([\"tool\", \"prompt\", \"resource\"]),\n\t/** Entity name in kebab-case */\n\tname: z.string(),\n\t/** Capitalized name (PascalCase) */\n\tcapitalizedName: z.string(),\n\t/** Entity description */\n\tdescription: z.string().optional(),\n});\n\nexport type TemplateConfig = z.infer<typeof TemplateConfigSchema>;\n\n/**\n * Schema for resource template options (extends TemplateConfig)\n */\nexport const ResourceTemplateOptionsSchema = TemplateConfigSchema.extend({\n\t/** Entity type must be resource */\n\tentityType: z.literal(\"resource\"),\n\t/** URI pattern for the resource */\n\turiPattern: z.string(),\n});\n\nexport type ResourceTemplateOptions = z.infer<typeof ResourceTemplateOptionsSchema>;\n\n/**\n * Schema for entity lister configuration\n */\nexport const EntityListerConfigSchema = z.object({\n\t/** Entity type */\n\tentityType: z.enum([\"tool\", \"prompt\", \"resource\"]),\n\t/** Entity type plural form */\n\tentityTypePlural: z.enum([\"tools\", \"prompts\", \"resources\"]),\n\t/** Directory where entities are stored */\n\tdirectory: z.string(),\n\t/** Function name suffix */\n\tfunctionSuffix: z.string(),\n\t/** Regex pattern to extract description from file */\n\tdescriptionPattern: z.instanceof(RegExp),\n\t/** Command name for CLI */\n\tcommandName: z.string(),\n\t/** Command description for CLI */\n\tcommandDescription: z.string(),\n});\n\nexport type EntityListerConfig = z.infer<typeof EntityListerConfigSchema>;\n","/**\n * Entity Scaffold Strategy\n *\n * Strategy for scaffolding MCP entities (tools, prompts, resources).\n * Implements only entity-specific logic while orchestrator handles common flow.\n */\n\nimport { mkdir, writeFile } from \"node:fs/promises\";\nimport { join } from \"node:path\";\nimport { RegistrationService } from \"../registration-service.js\";\nimport { ValidationService } from \"../validation-service.js\";\nimport { TemplateService } from \"../template-service.js\";\nimport { BindingDetectionService } from \"../binding-detection-service.js\";\nimport { updateTemplateMetadata } from \"../metadata.js\";\nimport { toPascalCase } from \"../utils.js\";\nimport { ScaffoldConfigSchema, type ScaffoldConfig } from \"../schemas.js\";\nimport type { RegistrationConfig } from \"../registration-service.js\";\nimport type { ValidationConfig, ResourceOptions } from \"../validation-service.js\";\nimport type { ResourceTemplateOptions } from \"../template-service.js\";\nimport type {\n\tScaffoldStrategy,\n\tScaffoldContext,\n} from \"../orchestration/types.js\";\n\n/**\n * Result of entity scaffolding operation\n */\nexport interface EntityScaffoldResult {\n\t/** Whether scaffolding was successful */\n\tsuccess: boolean;\n\t/** Files that were created */\n\tfilesCreated: string[];\n\t/** Whether entity was registered */\n\tregistered: boolean;\n\t/** Any warnings or messages */\n\tmessages: string[];\n}\n\n/**\n * Strategy for scaffolding entities\n *\n * Handles: tools, prompts, resources\n * Does NOT need backup/rollback (low risk - only creates new files)\n */\nexport class EntityScaffoldStrategy\n\timplements ScaffoldStrategy<ScaffoldConfig, EntityScaffoldResult>\n{\n\tprivate registrationService: RegistrationService;\n\tprivate validationService: ValidationService;\n\tprivate templateService: TemplateService;\n\tprivate bindingDetectionService: BindingDetectionService;\n\n\tconstructor() {\n\t\tthis.registrationService = new RegistrationService();\n\t\tthis.validationService = new ValidationService();\n\t\tthis.templateService = new TemplateService();\n\t\tthis.bindingDetectionService = new BindingDetectionService();\n\t}\n\n\t/**\n\t * Validate entity configuration\n\t */\n\tasync validate(cwd: string, config: ScaffoldConfig): Promise<void> {\n\t\t// Validate configuration with Zod\n\t\tconst parseResult = ScaffoldConfigSchema.safeParse(config);\n\t\tif (!parseResult.success) {\n\t\t\tconst firstError = parseResult.error.errors[0];\n\t\t\tthrow new Error(firstError.message);\n\t\t}\n\n\t\tconst { entityType, name } = parseResult.data;\n\n\t\t// Validate entity\n\t\tconst validationConfig: ValidationConfig = {\n\t\t\tentityType,\n\t\t\tsourceDir: `src/${entityType}s`,\n\t\t};\n\n\t\tthis.validationService.validateEntity(cwd, name, validationConfig);\n\n\t\t// Handle resource-specific validation\n\t\tif (entityType === \"resource\" && config.resourceOptions) {\n\t\t\tthis.validationService.validateResourceOptions(config.resourceOptions);\n\t\t}\n\t}\n\n\t/**\n\t * Execute entity scaffolding\n\t *\n\t * 1. Generate entity file\n\t * 2. Generate test files (if enabled)\n\t * 3. Register entity (if enabled)\n\t * 4. Update metadata\n\t */\n\tasync execute(\n\t\tcontext: ScaffoldContext<ScaffoldConfig, EntityScaffoldResult>,\n\t): Promise<void> {\n\t\tconst { cwd, config, result } = context;\n\n\t\tconst { entityType, name } = config;\n\t\tconst capitalizedName = toPascalCase(name);\n\t\tconst description = config.description || \"TODO: Add description\";\n\t\tconst generateTests = config.generateTests !== false; // Default true\n\t\tconst autoRegister = config.autoRegister !== false; // Default true\n\n\t\t// 1. Generate entity file\n\t\tconst entityFilePath = await this.generateEntityFile(\n\t\t\tcwd,\n\t\t\tname,\n\t\t\tcapitalizedName,\n\t\t\tdescription,\n\t\t\tconfig,\n\t\t);\n\t\tresult.filesCreated.push(entityFilePath);\n\n\t\t// 2. Generate test files\n\t\tif (generateTests) {\n\t\t\tconst testFiles = await this.generateTestFiles(\n\t\t\t\tcwd,\n\t\t\t\tname,\n\t\t\t\tcapitalizedName,\n\t\t\t\tdescription,\n\t\t\t\tconfig,\n\t\t\t);\n\t\t\tresult.filesCreated.push(...testFiles);\n\t\t}\n\n\t\t// 3. Register entity\n\t\tif (autoRegister) {\n\t\t\tconst registrationConfig: RegistrationConfig = {\n\t\t\t\tentityType,\n\t\t\t\tentityTypePlural: `${entityType}s`,\n\t\t\t\tdirectory: `./${entityType}s/`,\n\t\t\t\tfunctionSuffix:\n\t\t\t\t\tentityType.charAt(0).toUpperCase() + entityType.slice(1),\n\t\t\t};\n\n\t\t\tawait this.registrationService.registerEntity(\n\t\t\t\tcwd,\n\t\t\t\tname,\n\t\t\t\tcapitalizedName,\n\t\t\t\tregistrationConfig,\n\t\t\t);\n\t\t\tresult.registered = true;\n\t\t}\n\n\t\t// 4. Update metadata\n\t\tawait updateTemplateMetadata(\n\t\t\tcwd,\n\t\t\t`${entityType}s`,\n\t\t\tname,\n\t\t\t`src/${entityType}s/${name}.ts`,\n\t\t\tgenerateTests,\n\t\t);\n\n\t\tresult.success = true;\n\t}\n\n\t/**\n\t * Entities don't need backup (low risk)\n\t */\n\tneedsBackup(): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create initial result object\n\t */\n\tcreateResult(): EntityScaffoldResult {\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tfilesCreated: [],\n\t\t\tregistered: false,\n\t\t\tmessages: [],\n\t\t};\n\t}\n\n\t/**\n\t * Generate the main entity file\n\t */\n\tprivate async generateEntityFile(\n\t\tcwd: string,\n\t\tname: string,\n\t\tcapitalizedName: string,\n\t\tdescription: string,\n\t\tconfig: ScaffoldConfig,\n\t): Promise<string> {\n\t\tconst { entityType, resourceOptions } = config;\n\t\tconst dirPath = join(cwd, \"src\", `${entityType}s`);\n\t\tconst filePath = join(dirPath, `${name}.ts`);\n\n\t\t// Create directory if it doesn't exist\n\t\tawait mkdir(dirPath, { recursive: true });\n\n\t\t// Detect bindings for tools (only tools need env parameter for bindings)\n\t\tlet bindingContext;\n\t\tif (entityType === \"tool\") {\n\t\t\tconst bindings = await this.bindingDetectionService.detectBindings(cwd);\n\t\t\tconst hasBindings =\n\t\t\t\tbindings.kv.length > 0 ||\n\t\t\t\tbindings.d1.length > 0 ||\n\t\t\t\tbindings.r2.length > 0 ||\n\t\t\t\t!!bindings.ai;\n\n\t\t\tif (hasBindings) {\n\t\t\t\tconst examples =\n\t\t\t\t\tthis.bindingDetectionService.generateBindingExamples(bindings);\n\t\t\t\tconst summary =\n\t\t\t\t\tthis.bindingDetectionService.generateBindingSummary(bindings);\n\n\t\t\t\tbindingContext = {\n\t\t\t\t\thasBindings: true,\n\t\t\t\t\tbindingSummary: summary,\n\t\t\t\t\tbindingExamples: examples,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tbindingContext = {\n\t\t\t\t\thasBindings: false,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tlet content: string;\n\n\t\tif (entityType === \"resource\" && resourceOptions) {\n\t\t\t// Determine URI pattern for resources\n\t\t\tconst uriPattern = this.validationService.determineUriPattern(\n\t\t\t\tname,\n\t\t\t\tresourceOptions,\n\t\t\t);\n\n\t\t\tconst resourceConfig: ResourceTemplateOptions = {\n\t\t\t\tentityType,\n\t\t\t\tname,\n\t\t\t\tcapitalizedName,\n\t\t\t\tdescription,\n\t\t\t\turiPattern,\n\t\t\t};\n\n\t\t\tcontent = this.templateService.generateEntityFile(resourceConfig);\n\t\t} else {\n\t\t\tcontent = this.templateService.generateEntityFile({\n\t\t\t\tentityType,\n\t\t\t\tname,\n\t\t\t\tcapitalizedName,\n\t\t\t\tdescription,\n\t\t\t\tbindingContext,\n\t\t\t});\n\t\t}\n\n\t\tawait writeFile(filePath, content, \"utf-8\");\n\t\treturn filePath;\n\t}\n\n\t/**\n\t * Generate unit and integration test files\n\t */\n\tprivate async generateTestFiles(\n\t\tcwd: string,\n\t\tname: string,\n\t\tcapitalizedName: string,\n\t\tdescription: string,\n\t\tconfig: ScaffoldConfig,\n\t): Promise<string[]> {\n\t\tconst { entityType, resourceOptions } = config;\n\t\tconst testFiles: string[] = [];\n\n\t\t// Unit test file\n\t\tconst unitTestPath = await this.generateUnitTest(\n\t\t\tcwd,\n\t\t\tname,\n\t\t\tcapitalizedName,\n\t\t\tdescription,\n\t\t\tentityType,\n\t\t);\n\t\ttestFiles.push(unitTestPath);\n\n\t\t// Integration test file (YAML)\n\t\tconst integrationTestPath = await this.generateIntegrationTest(\n\t\t\tcwd,\n\t\t\tname,\n\t\t\tcapitalizedName,\n\t\t\tdescription,\n\t\t\tentityType,\n\t\t\tresourceOptions,\n\t\t);\n\t\ttestFiles.push(integrationTestPath);\n\n\t\treturn testFiles;\n\t}\n\n\t/**\n\t * Generate unit test file\n\t */\n\tprivate async generateUnitTest(\n\t\tcwd: string,\n\t\tname: string,\n\t\tcapitalizedName: string,\n\t\tdescription: string,\n\t\tentityType: \"tool\" | \"prompt\" | \"resource\",\n\t): Promise<string> {\n\t\tconst dirPath = join(cwd, \"test\", \"unit\", `${entityType}s`);\n\t\tconst filePath = join(dirPath, `${name}.test.ts`);\n\n\t\tawait mkdir(dirPath, { recursive: true });\n\n\t\tconst content = this.templateService.generateUnitTestFile({\n\t\t\tentityType,\n\t\t\tname,\n\t\t\tcapitalizedName,\n\t\t\tdescription,\n\t\t});\n\n\t\tawait writeFile(filePath, content, \"utf-8\");\n\t\treturn filePath;\n\t}\n\n\t/**\n\t * Generate integration test file (YAML)\n\t */\n\tprivate async generateIntegrationTest(\n\t\tcwd: string,\n\t\tname: string,\n\t\tcapitalizedName: string,\n\t\tdescription: string,\n\t\tentityType: \"tool\" | \"prompt\" | \"resource\",\n\t\tresourceOptions?: ResourceOptions,\n\t): Promise<string> {\n\t\t// Tools go directly in specs/, others in subdirectories\n\t\tconst dirPath = join(\n\t\t\tcwd,\n\t\t\t\"test\",\n\t\t\t\"integration\",\n\t\t\t\"specs\",\n\t\t\tentityType === \"tool\" ? \"\" : `${entityType}s`,\n\t\t);\n\t\tconst filePath = join(dirPath, `${name}.yaml`);\n\n\t\tawait mkdir(dirPath, { recursive: true });\n\n\t\tlet content: string;\n\n\t\tif (entityType === \"resource\" && resourceOptions) {\n\t\t\tconst uriPattern = this.validationService.determineUriPattern(\n\t\t\t\tname,\n\t\t\t\tresourceOptions,\n\t\t\t);\n\n\t\t\tcontent = this.templateService.generateIntegrationTestYaml({\n\t\t\t\tentityType,\n\t\t\t\tname,\n\t\t\t\tcapitalizedName,\n\t\t\t\tdescription,\n\t\t\t\turiPattern,\n\t\t\t});\n\t\t} else {\n\t\t\tcontent = this.templateService.generateIntegrationTestYaml({\n\t\t\t\tentityType,\n\t\t\t\tname,\n\t\t\t\tcapitalizedName,\n\t\t\t\tdescription,\n\t\t\t});\n\t\t}\n\n\t\tawait writeFile(filePath, content, \"utf-8\");\n\t\treturn filePath;\n\t}\n}\n","/**\n * Entity Scaffolder\n *\n * Facade for entity scaffolding using the orchestration pattern.\n * Delegates to ScaffoldOrchestrator + EntityScaffoldStrategy to eliminate duplication.\n */\n\nimport { ScaffoldOrchestrator } from \"./orchestration/index.js\";\nimport { EntityScaffoldStrategy } from \"./strategies/entity-scaffold-strategy.js\";\nimport type { ScaffoldConfig } from \"./schemas.js\";\n\n// Re-export ScaffoldConfig type for external use\nexport type { ScaffoldConfig };\n\n/**\n * Result of scaffolding operation\n */\nexport interface ScaffoldResult {\n\t/** Whether scaffolding was successful */\n\tsuccess: boolean;\n\t/** Files that were created */\n\tfilesCreated: string[];\n\t/** Whether entity was registered */\n\tregistered: boolean;\n\t/** Any warnings or messages */\n\tmessages: string[];\n}\n\n/**\n * Service for scaffolding MCP entities\n *\n * Facade that delegates to ScaffoldOrchestrator + EntityScaffoldStrategy.\n * This maintains the same public API while using the refactored architecture.\n */\nexport class EntityScaffolder {\n\tprivate orchestrator: ScaffoldOrchestrator<ScaffoldConfig, ScaffoldResult>;\n\tprivate strategy: EntityScaffoldStrategy;\n\n\tconstructor() {\n\t\tthis.orchestrator = new ScaffoldOrchestrator();\n\t\tthis.strategy = new EntityScaffoldStrategy();\n\t}\n\n\t/**\n\t * Scaffold a new entity\n\t *\n\t * @param cwd Current working directory (project root)\n\t * @param config Scaffolding configuration\n\t * @returns Result with created files and registration status\n\t */\n\tasync scaffold(cwd: string, config: ScaffoldConfig): Promise<ScaffoldResult> {\n\t\t// Delegate to orchestrator + strategy\n\t\treturn this.orchestrator.scaffold(cwd, config, this.strategy);\n\t}\n\n\t/**\n\t * Get emoji for entity type (for console output)\n\t */\n\tstatic getEntityEmoji(entityType: \"tool\" | \"prompt\" | \"resource\"): string {\n\t\tswitch (entityType) {\n\t\t\tcase \"tool\":\n\t\t\t\treturn \"🔧\";\n\t\t\tcase \"prompt\":\n\t\t\t\treturn \"📝\";\n\t\t\tcase \"resource\":\n\t\t\t\treturn \"📦\";\n\t\t}\n\t}\n\n\t/**\n\t * Get entity type display name\n\t */\n\tstatic getEntityDisplayName(\n\t\tentityType: \"tool\" | \"prompt\" | \"resource\",\n\t): string {\n\t\treturn entityType.charAt(0).toUpperCase() + entityType.slice(1);\n\t}\n}\n","/**\n * Entity Lister - Shared logic for listing MCP entities\n *\n * Provides a unified way to list tools, prompts, and resources\n * with their registration and test status.\n */\n\nimport { Command } from \"commander\";\nimport fs from \"node:fs/promises\";\nimport path from \"node:path\";\nimport { toKebabCase, fileExists } from \"./utils.js\";\n\n/**\n * Configuration for entity listing\n */\nexport interface EntityConfig {\n\t/** Entity type (singular) */\n\tentityType: \"tool\" | \"prompt\" | \"resource\";\n\t/** Entity type (plural) */\n\tentityTypePlural: \"tools\" | \"prompts\" | \"resources\";\n\t/** Source directory (e.g., 'src/tools') */\n\tsourceDir: string;\n\t/** Pattern to match registrations in index.ts */\n\tregistrationPattern: RegExp;\n\t/** Unit test directory (e.g., 'test/unit/tools') */\n\tunitTestDir: string;\n\t/** Integration test directory (e.g., 'test/integration/specs') */\n\tintegrationTestDir: string;\n\t/** Pattern to extract description from entity file */\n\tdescriptionPattern: RegExp;\n}\n\n/**\n * Entity information\n */\nexport interface EntityInfo {\n\tname: string;\n\tfile: string;\n\tregistered: boolean;\n\thasUnitTest: boolean;\n\thasIntegrationTest: boolean;\n\tdescription?: string;\n}\n\n/**\n * Generic entity lister\n */\nexport class EntityLister {\n\tconstructor(private config: EntityConfig) {}\n\n\t/**\n\t * Create Commander command for listing entities\n\t */\n\tcreateCommand(): Command {\n\t\treturn new Command(this.config.entityTypePlural)\n\t\t\t.description(\n\t\t\t\t`List all ${this.config.entityTypePlural} in the MCP server project`,\n\t\t\t)\n\t\t\t.option(\"-j, --json\", \"Output as JSON\")\n\t\t\t.option(\n\t\t\t\t\"-f, --filter <status>\",\n\t\t\t\t\"Filter by status (all, registered, unregistered, tested, untested)\",\n\t\t\t\t\"all\",\n\t\t\t)\n\t\t\t.option(\n\t\t\t\t\"--show-examples\",\n\t\t\t\t`Include example ${this.config.entityTypePlural} in output`,\n\t\t\t)\n\t\t\t.action(async (options) => {\n\t\t\t\tconst cwd = process.cwd();\n\n\t\t\t\ttry {\n\t\t\t\t\tconst entities = await this.discoverEntities(\n\t\t\t\t\t\tcwd,\n\t\t\t\t\t\toptions.showExamples,\n\t\t\t\t\t);\n\n\t\t\t\t\t// Filter entities\n\t\t\t\t\tconst filtered = this.filterEntities(entities, options.filter);\n\n\t\t\t\t\t// Output\n\t\t\t\t\tif (options.json) {\n\t\t\t\t\t\tconsole.log(JSON.stringify(filtered, null, 2));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.printTable(filtered);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`❌ Error: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t\t\t);\n\t\t\t\t\tprocess.exit(1);\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Discover all entities in the project\n\t */\n\tasync discoverEntities(\n\t\tcwd: string,\n\t\tincludeExamples = false,\n\t): Promise<EntityInfo[]> {\n\t\tconst entities: EntityInfo[] = [];\n\n\t\t// 1. Scan source directory\n\t\tconst sourceDir = path.join(cwd, this.config.sourceDir);\n\t\tlet entityFiles: string[] = [];\n\n\t\ttry {\n\t\t\tconst files = await fs.readdir(sourceDir);\n\t\t\tentityFiles = files\n\t\t\t\t.filter((f) => f.endsWith(\".ts\") && !f.endsWith(\".test.ts\"))\n\t\t\t\t.filter((f) => includeExamples || !f.startsWith(\"_example\"));\n\t\t} catch (error) {\n\t\t\tthrow new Error(\n\t\t\t\t`${this.config.sourceDir}/ directory not found. Are you in an MCP server project?`,\n\t\t\t);\n\t\t}\n\n\t\t// 2. Check index.ts for registrations\n\t\tconst indexPath = path.join(cwd, \"src\", \"index.ts\");\n\t\tconst registeredEntities = await this.checkRegistrations(indexPath);\n\n\t\t// 3. Build entity info\n\t\tfor (const file of entityFiles) {\n\t\t\tconst entityName = path.basename(file, \".ts\");\n\t\t\tconst entityPath = path.join(sourceDir, file);\n\n\t\t\t// Check registration\n\t\t\tconst registered = registeredEntities.includes(entityName);\n\n\t\t\t// Check unit test\n\t\t\tconst unitTestPath = path.join(\n\t\t\t\tcwd,\n\t\t\t\tthis.config.unitTestDir,\n\t\t\t\t`${entityName}.test.ts`,\n\t\t\t);\n\t\t\tconst hasUnitTest = await fileExists(unitTestPath);\n\n\t\t\t// Check integration test\n\t\t\tconst integrationTestPath = path.join(\n\t\t\t\tcwd,\n\t\t\t\tthis.config.integrationTestDir,\n\t\t\t\t`${entityName}.yaml`,\n\t\t\t);\n\t\t\tconst hasIntegrationTest = await fileExists(integrationTestPath);\n\n\t\t\t// Try to extract description from file\n\t\t\tconst description = await this.extractDescription(entityPath);\n\n\t\t\tentities.push({\n\t\t\t\tname: entityName,\n\t\t\t\tfile: path.relative(cwd, entityPath),\n\t\t\t\tregistered,\n\t\t\t\thasUnitTest,\n\t\t\t\thasIntegrationTest,\n\t\t\t\tdescription,\n\t\t\t});\n\t\t}\n\n\t\treturn entities;\n\t}\n\n\t/**\n\t * Check which entities are registered in src/index.ts\n\t */\n\tasync checkRegistrations(indexPath: string): Promise<string[]> {\n\t\ttry {\n\t\t\tconst content = await fs.readFile(indexPath, \"utf-8\");\n\t\t\tconst registered: string[] = [];\n\n\t\t\tlet match: RegExpExecArray | null;\n\n\t\t\twhile ((match = this.config.registrationPattern.exec(content)) !== null) {\n\t\t\t\tconst entityName = toKebabCase(match[1]);\n\t\t\t\tregistered.push(entityName);\n\t\t\t}\n\n\t\t\treturn registered;\n\t\t} catch (error) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Filter entities by status\n\t */\n\tfilterEntities(entities: EntityInfo[], filter: string): EntityInfo[] {\n\t\tswitch (filter.toLowerCase()) {\n\t\t\tcase \"registered\":\n\t\t\t\treturn entities.filter((e) => e.registered);\n\t\t\tcase \"unregistered\":\n\t\t\t\treturn entities.filter((e) => !e.registered);\n\t\t\tcase \"tested\":\n\t\t\t\treturn entities.filter((e) => e.hasUnitTest || e.hasIntegrationTest);\n\t\t\tcase \"untested\":\n\t\t\t\treturn entities.filter((e) => !e.hasUnitTest && !e.hasIntegrationTest);\n\t\t\tcase \"all\":\n\t\t\tdefault:\n\t\t\t\treturn entities;\n\t\t}\n\t}\n\n\t/**\n\t * Print entities in a formatted table\n\t */\n\tprintTable(entities: EntityInfo[]): void {\n\t\tif (entities.length === 0) {\n\t\t\tconsole.log(`No ${this.config.entityTypePlural} found.\\n`);\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`\\nFound ${entities.length} ${entities.length === 1 ? this.config.entityType : this.config.entityTypePlural}:\\n`,\n\t\t);\n\n\t\t// Calculate column widths\n\t\tconst nameWidth = Math.max(10, ...entities.map((e) => e.name.length));\n\t\tconst fileWidth = Math.max(20, ...entities.map((e) => e.file.length));\n\n\t\t// Header\n\t\tconst header = `${\"NAME\".padEnd(nameWidth)} | REG | UNIT | INT | ${\"FILE\".padEnd(fileWidth)}`;\n\t\tconsole.log(header);\n\t\tconsole.log(\"=\".repeat(header.length));\n\n\t\t// Rows\n\t\tfor (const entity of entities) {\n\t\t\tconst name = entity.name.padEnd(nameWidth);\n\t\t\tconst reg = entity.registered ? \" ✓ \" : \" ✗ \";\n\t\t\tconst unit = entity.hasUnitTest ? \" ✓ \" : \" ✗ \";\n\t\t\tconst int = entity.hasIntegrationTest ? \" ✓ \" : \" ✗ \";\n\t\t\tconst file = entity.file.padEnd(fileWidth);\n\n\t\t\tconsole.log(`${name} | ${reg} | ${unit} | ${int} | ${file}`);\n\n\t\t\t// Show description if available\n\t\t\tif (entity.description && entity.description !== \"No description\") {\n\t\t\t\tconsole.log(`${\"\".padEnd(nameWidth)}   ${entity.description}`);\n\t\t\t}\n\t\t}\n\n\t\t// Summary\n\t\tconst registered = entities.filter((e) => e.registered).length;\n\t\tconst withUnitTests = entities.filter((e) => e.hasUnitTest).length;\n\t\tconst withIntegrationTests = entities.filter(\n\t\t\t(e) => e.hasIntegrationTest,\n\t\t).length;\n\n\t\tconsole.log(\"\\nSummary:\");\n\t\tconsole.log(`  Registered:       ${registered}/${entities.length}`);\n\t\tconsole.log(`  Unit tests:       ${withUnitTests}/${entities.length}`);\n\t\tconsole.log(\n\t\t\t`  Integration tests: ${withIntegrationTests}/${entities.length}`,\n\t\t);\n\t\tconsole.log(\"\");\n\t}\n\n\t/**\n\t * Extract description from entity file\n\t */\n\tprivate async extractDescription(filePath: string): Promise<string> {\n\t\ttry {\n\t\t\tconst content = await fs.readFile(filePath, \"utf-8\");\n\n\t\t\t// Look for server.{tool|prompt|resource}() call and extract description parameter\n\t\t\tconst match = content.match(this.config.descriptionPattern);\n\n\t\t\tif (match && match[2]) {\n\t\t\t\treturn match[2];\n\t\t\t}\n\n\t\t\t// Fallback: look for file header comment\n\t\t\tconst headerRegex = /\\/\\*\\*[\\s\\S]*?\\*\\s*([^\\n]+)/;\n\t\t\tconst headerMatch = content.match(headerRegex);\n\n\t\t\tif (headerMatch && headerMatch[1]) {\n\t\t\t\treturn headerMatch[1].trim();\n\t\t\t}\n\n\t\t\treturn \"No description\";\n\t\t} catch (error) {\n\t\t\treturn \"No description\";\n\t\t}\n\t}\n}\n"]}