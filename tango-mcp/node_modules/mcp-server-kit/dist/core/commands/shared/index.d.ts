import { z } from 'zod';
import { Command } from 'commander';

/**
 * Zod Schemas for Configuration Validation
 *
 * Provides runtime validation and type safety for all service configurations
 */

/**
 * Schema for resource-specific options
 */
declare const ResourceOptionsSchema: z.ZodObject<{
    /** URI pattern for the resource */
    uriPattern: z.ZodOptional<z.ZodString>;
    /** Whether this is a static resource */
    static: z.ZodOptional<z.ZodBoolean>;
    /** Whether this is a dynamic resource with variables */
    dynamic: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    uriPattern?: string | undefined;
    static?: boolean | undefined;
    dynamic?: boolean | undefined;
}, {
    uriPattern?: string | undefined;
    static?: boolean | undefined;
    dynamic?: boolean | undefined;
}>;
type ResourceOptions$1 = z.infer<typeof ResourceOptionsSchema>;
/**
 * Schema for entity scaffolding configuration
 */
declare const ScaffoldConfigSchema: z.ZodEffects<z.ZodEffects<z.ZodObject<{
    /** Entity type (tool, prompt, resource) */
    entityType: z.ZodEnum<["tool", "prompt", "resource"]>;
    /** Entity name in kebab-case */
    name: z.ZodString;
    /** Description of the entity */
    description: z.ZodOptional<z.ZodString>;
    /** Whether to generate test files (default: true) */
    generateTests: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    /** Whether to auto-register in index.ts (default: true) */
    autoRegister: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    /** Resource-specific options (required for resources) */
    resourceOptions: z.ZodOptional<z.ZodObject<{
        /** URI pattern for the resource */
        uriPattern: z.ZodOptional<z.ZodString>;
        /** Whether this is a static resource */
        static: z.ZodOptional<z.ZodBoolean>;
        /** Whether this is a dynamic resource with variables */
        dynamic: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        uriPattern?: string | undefined;
        static?: boolean | undefined;
        dynamic?: boolean | undefined;
    }, {
        uriPattern?: string | undefined;
        static?: boolean | undefined;
        dynamic?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    name: string;
    entityType: "prompt" | "tool" | "resource";
    generateTests: boolean;
    autoRegister: boolean;
    description?: string | undefined;
    resourceOptions?: {
        uriPattern?: string | undefined;
        static?: boolean | undefined;
        dynamic?: boolean | undefined;
    } | undefined;
}, {
    name: string;
    entityType: "prompt" | "tool" | "resource";
    description?: string | undefined;
    generateTests?: boolean | undefined;
    autoRegister?: boolean | undefined;
    resourceOptions?: {
        uriPattern?: string | undefined;
        static?: boolean | undefined;
        dynamic?: boolean | undefined;
    } | undefined;
}>, {
    name: string;
    entityType: "prompt" | "tool" | "resource";
    generateTests: boolean;
    autoRegister: boolean;
    description?: string | undefined;
    resourceOptions?: {
        uriPattern?: string | undefined;
        static?: boolean | undefined;
        dynamic?: boolean | undefined;
    } | undefined;
}, {
    name: string;
    entityType: "prompt" | "tool" | "resource";
    description?: string | undefined;
    generateTests?: boolean | undefined;
    autoRegister?: boolean | undefined;
    resourceOptions?: {
        uriPattern?: string | undefined;
        static?: boolean | undefined;
        dynamic?: boolean | undefined;
    } | undefined;
}>, {
    name: string;
    entityType: "prompt" | "tool" | "resource";
    generateTests: boolean;
    autoRegister: boolean;
    description?: string | undefined;
    resourceOptions?: {
        uriPattern?: string | undefined;
        static?: boolean | undefined;
        dynamic?: boolean | undefined;
    } | undefined;
}, {
    name: string;
    entityType: "prompt" | "tool" | "resource";
    description?: string | undefined;
    generateTests?: boolean | undefined;
    autoRegister?: boolean | undefined;
    resourceOptions?: {
        uriPattern?: string | undefined;
        static?: boolean | undefined;
        dynamic?: boolean | undefined;
    } | undefined;
}>;
type ScaffoldConfig = z.input<typeof ScaffoldConfigSchema>;
type ValidatedScaffoldConfig = z.output<typeof ScaffoldConfigSchema>;
/**
 * Schema for registration service configuration
 */
declare const RegistrationConfigSchema: z.ZodObject<{
    /** Entity type */
    entityType: z.ZodEnum<["tool", "prompt", "resource"]>;
    /** Entity type plural form */
    entityTypePlural: z.ZodEnum<["tools", "prompts", "resources"]>;
    /** Import directory path */
    directory: z.ZodString;
    /** Function name suffix */
    functionSuffix: z.ZodString;
}, "strip", z.ZodTypeAny, {
    entityType: "prompt" | "tool" | "resource";
    entityTypePlural: "tools" | "prompts" | "resources";
    directory: string;
    functionSuffix: string;
}, {
    entityType: "prompt" | "tool" | "resource";
    entityTypePlural: "tools" | "prompts" | "resources";
    directory: string;
    functionSuffix: string;
}>;
type RegistrationConfig$1 = z.infer<typeof RegistrationConfigSchema>;
/**
 * Schema for validation service configuration
 */
declare const ValidationConfigSchema: z.ZodObject<{
    /** Entity type */
    entityType: z.ZodEnum<["tool", "prompt", "resource"]>;
    /** Directory where entity file will be created */
    sourceDir: z.ZodString;
}, "strip", z.ZodTypeAny, {
    entityType: "prompt" | "tool" | "resource";
    sourceDir: string;
}, {
    entityType: "prompt" | "tool" | "resource";
    sourceDir: string;
}>;
type ValidationConfig$1 = z.infer<typeof ValidationConfigSchema>;
/**
 * Schema for template configuration
 */
declare const TemplateConfigSchema: z.ZodObject<{
    /** Entity type */
    entityType: z.ZodEnum<["tool", "prompt", "resource"]>;
    /** Entity name in kebab-case */
    name: z.ZodString;
    /** Capitalized name (PascalCase) */
    capitalizedName: z.ZodString;
    /** Entity description */
    description: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    name: string;
    entityType: "prompt" | "tool" | "resource";
    capitalizedName: string;
    description?: string | undefined;
}, {
    name: string;
    entityType: "prompt" | "tool" | "resource";
    capitalizedName: string;
    description?: string | undefined;
}>;
type TemplateConfig$1 = z.infer<typeof TemplateConfigSchema>;
/**
 * Schema for resource template options (extends TemplateConfig)
 */
declare const ResourceTemplateOptionsSchema: z.ZodObject<{
    name: z.ZodString;
    capitalizedName: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
} & {
    entityType: z.ZodLiteral<"resource">;
    uriPattern: z.ZodString;
}, "strip", z.ZodTypeAny, {
    name: string;
    uriPattern: string;
    entityType: "resource";
    capitalizedName: string;
    description?: string | undefined;
}, {
    name: string;
    uriPattern: string;
    entityType: "resource";
    capitalizedName: string;
    description?: string | undefined;
}>;
type ResourceTemplateOptions$1 = z.infer<typeof ResourceTemplateOptionsSchema>;
/**
 * Schema for entity lister configuration
 */
declare const EntityListerConfigSchema: z.ZodObject<{
    /** Entity type */
    entityType: z.ZodEnum<["tool", "prompt", "resource"]>;
    /** Entity type plural form */
    entityTypePlural: z.ZodEnum<["tools", "prompts", "resources"]>;
    /** Directory where entities are stored */
    directory: z.ZodString;
    /** Function name suffix */
    functionSuffix: z.ZodString;
    /** Regex pattern to extract description from file */
    descriptionPattern: z.ZodType<RegExp, z.ZodTypeDef, RegExp>;
    /** Command name for CLI */
    commandName: z.ZodString;
    /** Command description for CLI */
    commandDescription: z.ZodString;
}, "strip", z.ZodTypeAny, {
    entityType: "prompt" | "tool" | "resource";
    entityTypePlural: "tools" | "prompts" | "resources";
    directory: string;
    functionSuffix: string;
    descriptionPattern: RegExp;
    commandName: string;
    commandDescription: string;
}, {
    entityType: "prompt" | "tool" | "resource";
    entityTypePlural: "tools" | "prompts" | "resources";
    directory: string;
    functionSuffix: string;
    descriptionPattern: RegExp;
    commandName: string;
    commandDescription: string;
}>;
type EntityListerConfig = z.infer<typeof EntityListerConfigSchema>;

/**
 * Entity Scaffolder
 *
 * Facade for entity scaffolding using the orchestration pattern.
 * Delegates to ScaffoldOrchestrator + EntityScaffoldStrategy to eliminate duplication.
 */

/**
 * Result of scaffolding operation
 */
interface ScaffoldResult {
    /** Whether scaffolding was successful */
    success: boolean;
    /** Files that were created */
    filesCreated: string[];
    /** Whether entity was registered */
    registered: boolean;
    /** Any warnings or messages */
    messages: string[];
}
/**
 * Service for scaffolding MCP entities
 *
 * Facade that delegates to ScaffoldOrchestrator + EntityScaffoldStrategy.
 * This maintains the same public API while using the refactored architecture.
 */
declare class EntityScaffolder {
    private orchestrator;
    private strategy;
    constructor();
    /**
     * Scaffold a new entity
     *
     * @param cwd Current working directory (project root)
     * @param config Scaffolding configuration
     * @returns Result with created files and registration status
     */
    scaffold(cwd: string, config: ScaffoldConfig): Promise<ScaffoldResult>;
    /**
     * Get emoji for entity type (for console output)
     */
    static getEntityEmoji(entityType: "tool" | "prompt" | "resource"): string;
    /**
     * Get entity type display name
     */
    static getEntityDisplayName(entityType: "tool" | "prompt" | "resource"): string;
}

/**
 * Entity Lister - Shared logic for listing MCP entities
 *
 * Provides a unified way to list tools, prompts, and resources
 * with their registration and test status.
 */

/**
 * Configuration for entity listing
 */
interface EntityConfig {
    /** Entity type (singular) */
    entityType: "tool" | "prompt" | "resource";
    /** Entity type (plural) */
    entityTypePlural: "tools" | "prompts" | "resources";
    /** Source directory (e.g., 'src/tools') */
    sourceDir: string;
    /** Pattern to match registrations in index.ts */
    registrationPattern: RegExp;
    /** Unit test directory (e.g., 'test/unit/tools') */
    unitTestDir: string;
    /** Integration test directory (e.g., 'test/integration/specs') */
    integrationTestDir: string;
    /** Pattern to extract description from entity file */
    descriptionPattern: RegExp;
}
/**
 * Entity information
 */
interface EntityInfo {
    name: string;
    file: string;
    registered: boolean;
    hasUnitTest: boolean;
    hasIntegrationTest: boolean;
    description?: string;
}
/**
 * Generic entity lister
 */
declare class EntityLister {
    private config;
    constructor(config: EntityConfig);
    /**
     * Create Commander command for listing entities
     */
    createCommand(): Command;
    /**
     * Discover all entities in the project
     */
    discoverEntities(cwd: string, includeExamples?: boolean): Promise<EntityInfo[]>;
    /**
     * Check which entities are registered in src/index.ts
     */
    checkRegistrations(indexPath: string): Promise<string[]>;
    /**
     * Filter entities by status
     */
    filterEntities(entities: EntityInfo[], filter: string): EntityInfo[];
    /**
     * Print entities in a formatted table
     */
    printTable(entities: EntityInfo[]): void;
    /**
     * Extract description from entity file
     */
    private extractDescription;
}

/**
 * Validation Service
 *
 * Handles entity validation for add commands
 * Shared logic for validating names, projects, and options
 */
/**
 * Configuration for entity validation
 */
interface ValidationConfig {
    /** Entity type (tool, prompt, resource) */
    entityType: "tool" | "prompt" | "resource";
    /** Directory where entity file will be created */
    sourceDir: string;
}
/**
 * Options for resource-specific validation
 */
interface ResourceOptions {
    static?: boolean;
    dynamic?: boolean;
    uriPattern?: string;
}
/**
 * Service for validating entity creation
 */
declare class ValidationService {
    /**
     * Validate entity name format
     *
     * Names must:
     * - Start with a lowercase letter
     * - Contain only lowercase letters, numbers, and hyphens
     * - Follow kebab-case convention
     *
     * @throws Error if name is invalid
     */
    validateName(name: string, config: ValidationConfig): void;
    /**
     * Validate we're in a valid MCP project
     *
     * @throws Error if not in a valid project
     */
    validateProject(cwd: string): void;
    /**
     * Check if entity file already exists
     *
     * @throws Error if entity file already exists
     */
    validateFileNotExists(cwd: string, name: string, config: ValidationConfig): void;
    /**
     * Validate all basic requirements for entity creation
     *
     * @throws Error if any validation fails
     */
    validateEntity(cwd: string, name: string, config: ValidationConfig): void;
    /**
     * Validate resource-specific options
     *
     * @throws Error if options are invalid
     */
    validateResourceOptions(options: ResourceOptions): void;
    /**
     * Determine URI pattern for a resource
     *
     * - If uriPattern is explicitly provided, use it
     * - If --dynamic flag is set, use dynamic pattern (resource://{id})
     * - Otherwise, default to static pattern (config://name)
     */
    determineUriPattern(name: string, options: ResourceOptions): string;
}

/**
 * Registration Service
 *
 * Handles entity registration in src/index.ts
 * Shared logic for adding imports and registration calls
 */
/**
 * Configuration for entity registration
 */
interface RegistrationConfig {
    /** Entity type (tool, prompt, resource) */
    entityType: "tool" | "prompt" | "resource";
    /** Entity type plural (tools, prompts, resources) */
    entityTypePlural: "tools" | "prompts" | "resources";
    /** Directory path (e.g., "./tools/") */
    directory: string;
    /** Function name suffix (e.g., "Tool", "Prompt", "Resource") */
    functionSuffix: string;
}
/**
 * Service for managing entity registrations in index.ts
 */
declare class RegistrationService {
    private static readonly ENTITY_ORDER;
    /**
     * Register an entity in src/index.ts
     */
    registerEntity(cwd: string, name: string, capitalizedName: string, config: RegistrationConfig): Promise<void>;
    /**
     * Check if an entity is already registered
     */
    isRegistered(cwd: string, capitalizedName: string, config: RegistrationConfig): Promise<boolean>;
    /**
     * Add import statement to the file
     */
    private addImport;
    /**
     * Add registration call to init() method
     */
    private addRegistrationCall;
    /**
     * Get import regex pattern for a directory
     */
    private getImportRegex;
    /**
     * Detect if a registration function needs the env parameter
     * Reads the entity file and checks the function signature
     */
    private functionNeedsEnv;
}

/**
 * Template Service
 *
 * Handles file content generation from templates
 * Shared logic for generating entity files, unit tests, and integration tests
 */
/**
 * Binding context for template generation
 */
interface BindingContext {
    /** Whether the project has any bindings configured */
    hasBindings: boolean;
    /** Compact binding summary (e.g., "KV: MY_CACHE | D1: USER_DB | AI: AI") */
    bindingSummary?: string;
    /** Array of binding examples with imports and usage */
    bindingExamples?: Array<{
        type: string;
        bindingName: string;
        helperClass?: string;
        importStatement?: string;
        usageExample: string;
    }>;
}
/**
 * Configuration for template generation
 */
interface TemplateConfig {
    /** Entity type (tool, prompt, resource) */
    entityType: "tool" | "prompt" | "resource";
    /** Entity name in kebab-case */
    name: string;
    /** Entity name in PascalCase */
    capitalizedName: string;
    /** Description of the entity */
    description: string;
    /** Binding context (optional - only for tools that may use bindings) */
    bindingContext?: BindingContext;
}
/**
 * Resource-specific template options
 */
interface ResourceTemplateOptions extends TemplateConfig {
    /** URI pattern for the resource */
    uriPattern: string;
}
/**
 * Service for generating entity file content from templates
 */
declare class TemplateService {
    private templateCache;
    private templatesDir;
    constructor();
    /**
     * Load and compile a Handlebars template
     */
    private loadTemplate;
    /**
     * Generate tool file content
     */
    generateToolFile(config: TemplateConfig): string;
    /**
     * Generate prompt file content
     */
    generatePromptFile(config: TemplateConfig): string;
    /**
     * Generate resource file content
     */
    generateResourceFile(config: ResourceTemplateOptions): string;
    /**
     * Generate entity file content based on entity type
     */
    generateEntityFile(config: TemplateConfig | ResourceTemplateOptions): string;
    /**
     * Generate unit test file content
     */
    generateUnitTestFile(config: TemplateConfig): string;
    /**
     * Generate integration test YAML content
     */
    generateIntegrationTestYaml(config: TemplateConfig | ResourceTemplateOptions): string;
    /**
     * Generate tool integration test YAML
     */
    private generateToolIntegrationYaml;
    /**
     * Generate prompt integration test YAML
     */
    private generatePromptIntegrationYaml;
    /**
     * Generate resource integration test YAML
     */
    private generateResourceIntegrationYaml;
}

/**
 * Binding Types - Type definitions for Cloudflare binding scaffolding
 *
 * This module defines types for scaffolding Cloudflare Workers bindings
 * (KV, D1, R2, Queues, etc.) in MCP servers.
 */
/**
 * Supported Cloudflare binding types
 *
 * Phase 1: kv, d1, r2 (implemented)
 * Phase 2: ai (implemented)
 * Phase 3: queues
 * Phase 4: vectorize, hyperdrive
 */
type BindingType = 'kv' | 'd1' | 'r2' | 'queues' | 'ai' | 'vectorize' | 'hyperdrive';
/**
 * Phase 1 binding types (storage primitives)
 */
type Phase1BindingType = Extract<BindingType, 'kv' | 'd1' | 'r2'>;
/**
 * Phase 2 binding types (AI/ML primitives)
 */
type Phase2BindingType = Extract<BindingType, 'ai'>;

/**
 * Binding Detection Service
 *
 * Detects Cloudflare bindings (KV, D1, R2, AI) configured in wrangler.jsonc.
 * Used by tool scaffolding to generate context-aware templates with binding usage examples.
 */

/**
 * Detected bindings organized by type
 */
interface DetectedBindings {
    kv: string[];
    d1: string[];
    r2: string[];
    ai?: string;
}
/**
 * Binding usage example with import and usage code
 */
interface BindingExample {
    type: Phase1BindingType | Phase2BindingType;
    bindingName: string;
    helperClass?: string;
    importStatement?: string;
    usageExample: string;
}
/**
 * Service for detecting configured Cloudflare bindings
 */
declare class BindingDetectionService {
    /**
     * Detect all bindings configured in wrangler.jsonc
     *
     * @param cwd - Project root directory
     * @returns Detected bindings organized by type
     */
    detectBindings(cwd: string): Promise<DetectedBindings>;
    /**
     * Check if project has any bindings configured
     *
     * @param cwd - Project root directory
     * @returns True if at least one binding is configured
     */
    hasAnyBindings(cwd: string): Promise<boolean>;
    /**
     * Generate binding usage examples for template comments
     *
     * @param bindings - Detected bindings
     * @returns Array of binding examples with imports and usage
     */
    generateBindingExamples(bindings: DetectedBindings): BindingExample[];
    /**
     * Generate compact binding summary for template comments
     * Format: "KV: MY_CACHE, SESSION_STORE | D1: USER_DB | R2: UPLOADS | AI: AI"
     *
     * @param bindings - Detected bindings
     * @returns Compact summary string
     */
    generateBindingSummary(bindings: DetectedBindings): string;
    /**
     * Get helper class name for a binding
     * Example: MY_CACHE (kv) -> MyCacheKV
     */
    private getHelperClassName;
    /**
     * Get helper file name for a binding
     * Example: MY_CACHE (kv) -> kv-my-cache
     */
    private getHelperFileName;
}

/**
 * Supported entity types
 */
type EntityType = "tools" | "prompts" | "resources";
/**
 * Update .mcp-template.json with new entity metadata
 *
 * @param cwd - Current working directory
 * @param entityType - Type of entity (tools, prompts, resources)
 * @param name - Entity name (kebab-case)
 * @param fileSubpath - Path to entity file relative to project root (e.g., "src/tools/my-tool.ts")
 * @param hasTests - Whether tests were generated
 *
 * @example
 * await updateTemplateMetadata(
 *   process.cwd(),
 *   "tools",
 *   "my-tool",
 *   "src/tools/my-tool.ts",
 *   true
 * );
 */
declare function updateTemplateMetadata(cwd: string, entityType: EntityType, name: string, fileSubpath: string, hasTests: boolean): Promise<void>;
/**
 * Read template metadata from .mcp-template.json
 *
 * @param cwd - Current working directory
 * @returns Parsed metadata or null if file doesn't exist
 *
 * @example
 * const metadata = await readTemplateMetadata(process.cwd());
 * if (metadata) {
 *   console.log(metadata.tools);
 * }
 */
declare function readTemplateMetadata(cwd: string): Promise<Record<string, unknown> | null>;

/**
 * Shared Utility Functions
 *
 * Common utilities used across multiple commands.
 * All functions are pure and have no side effects.
 */
/**
 * Convert kebab-case to PascalCase
 *
 * @param str - String in kebab-case format
 * @returns String in PascalCase format
 *
 * @example
 * toPascalCase("my-tool-name") → "MyToolName"
 * toPascalCase("api-client") → "ApiClient"
 */
declare function toPascalCase(str: string): string;
/**
 * Convert PascalCase to kebab-case
 *
 * @param str - String in PascalCase format
 * @returns String in kebab-case format
 *
 * @example
 * toKebabCase("MyToolName") → "my-tool-name"
 * toKebabCase("APIClient") → "api-client"
 */
declare function toKebabCase(str: string): string;
/**
 * Check if a file exists
 *
 * @param filePath - Path to check
 * @returns true if file exists, false otherwise
 *
 * @example
 * await fileExists("/path/to/file.ts") → true
 * await fileExists("/non/existent.ts") → false
 */
declare function fileExists(filePath: string): Promise<boolean>;

export { type BindingContext, BindingDetectionService, type BindingExample, type DetectedBindings, type EntityConfig, type EntityInfo, EntityLister, type EntityListerConfig, EntityListerConfigSchema, EntityScaffolder, type RegistrationConfig, RegistrationConfigSchema, type RegistrationConfig$1 as RegistrationConfigType, RegistrationService, type ResourceOptions, ResourceOptionsSchema, type ResourceOptions$1 as ResourceOptionsType, type ResourceTemplateOptions, ResourceTemplateOptionsSchema, type ResourceTemplateOptions$1 as ResourceTemplateOptionsType, type ScaffoldConfig, ScaffoldConfigSchema, type ScaffoldConfig as ScaffoldConfigType, type ScaffoldResult, type TemplateConfig, TemplateConfigSchema, type TemplateConfig$1 as TemplateConfigType, TemplateService, type ValidatedScaffoldConfig, type ValidationConfig, ValidationConfigSchema, type ValidationConfig$1 as ValidationConfigType, ValidationService, fileExists, readTemplateMetadata, toKebabCase, toPascalCase, updateTemplateMetadata };
